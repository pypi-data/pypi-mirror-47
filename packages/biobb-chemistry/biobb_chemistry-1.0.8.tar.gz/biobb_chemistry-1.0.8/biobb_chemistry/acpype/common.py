""" Common functions for package biobb_chemistry.acpype """
import os.path
import glob
import shutil
from biobb_common.tools import file_utils as fu

def check_input_path(path, out_log, classname):
	""" Checks input file """ 
	if not os.path.exists(path):
		fu.log(classname + ': Unexisting input file, exiting', out_log)
		raise SystemExit(classname + ': Unexisting input file')
	filename, file_extension = os.path.splitext(path)
	if not is_valid_input(file_extension[1:]):
		fu.log(classname + ': Format %s in input file is not compatible' % file_extension[1:], out_log)
		raise SystemExit(classname + ': Format %s in input file is not compatible' % file_extension[1:])
	# if file input has no path, add cwd because execution is launched on tmp folder
	if(os.path.basename(path) == path or not os.path.isabs(path)):
		path = os.path.join(os.getcwd(), path)

	return path

def check_output_path(path, type, out_log, classname):
	""" Checks output path """ 
	if os.path.dirname(path) and not os.path.exists(os.path.dirname(path)):
		fu.log(classname + ': Unexisting output %s output folder, exiting' % type, out_log)
		raise SystemExit(classname + ': Unexisting %s output folder' % type)
	filename, file_extension = os.path.splitext(path)
	if type != file_extension[1:]:
		fu.log(classname + ': Format %s in %s input file is not compatible' % (file_extension[1:], type), out_log)
		raise SystemExit(classname + ': Format %s in %s input file is not compatible' % (file_extension[1:], type))

	return path

def get_binary_path(properties, type):
	""" Gets binary path """
	return properties.get(type, get_default_value(type))

def get_basename(basename, out_log):
	""" Checks if provided basename value is correct """
	bsn = str(basename)
	if basename == '':
		fu.log('No basename provided, default value %s assigned' % get_default_value('basename'), out_log)
		bsn = get_default_value('basename')

	return bsn

def get_charge(charge, out_log):
	""" Checks if provided charge value is correct """
	ch = charge
	if ch == '':
		fu.log('No charge provided, default value %s assigned' % get_default_value('charge'), out_log)
		ch = get_default_value('charge')

	if not isinstance(ch, int):
		fu.log('Value %s is not compatible as a charge value, default value %d assigned' % (ch, get_default_value('charge')), out_log)
		ch = get_default_value('charge')

	return str(ch)

def get_default_value(key):
	""" Gives default values according to the given key """
	default_values = {
		"charge": 0,
		"basename": "BBB",
		"acpype_path": "acpype",
		"AcpypeParamsGMX": {
			"topology": "GROMACS",
			"suffix": "_GMX."
		},
		"AcpypeParamsAC": {
			"topology": "Antechamber",
			"suffix": "_AC."
		},
		"AcpypeParamsGMXOPLS": {
			"topology": "OPLS/AA",
			"suffix": "_GMX_OPLS."
		},
		"AcpypeParamsCNS": {
			"topology": "GROMACS",
			"suffix": "_CNS."
		}
	}

	return default_values[key]

def is_valid_input(ext):
	""" Checks if input file format is compatible with Acpype """
	formats = ["pdb", "mdl", "mol2"]

	return ext in formats

def process_output(tmp_folder, files_folder, basename, class_params, output_files, out_log):
	""" Moves and removes temporal files generated by the wrapper """
	path = os.path.join(tmp_folder, files_folder)
	suffix = class_params['suffix']
	src_files = glob.glob(path + '/' + basename + suffix + '*')
	print(src_files)
	# copy files for the requested topology to the output_path
	for file_name in src_files:
		if (os.path.isfile(file_name)):
			filename, file_extension = os.path.splitext(file_name)
			shutil.copy(file_name, output_files[file_extension[1:]])
			fu.log('File %s succesfully created' % output_files[file_extension[1:]], out_log)

	# remove temporary folder
	fu.rm(tmp_folder)
	fu.log('Removed temporary folder: %s' % tmp_folder, out_log)

def process_output_gmx(tmp_folder, files_folder, basename, class_params, output_files, out_log):
	""" Moves and removes temporal files generated by the wrapper """
	path = os.path.join(tmp_folder, files_folder)
	suffix = class_params['suffix']
	src_files = glob.glob(path + '/' + basename + suffix + '*')
	print(src_files)
	# copy files for the requested topology to the output_path
	for file_name in src_files:
		if (os.path.isfile(file_name)):
			filename, file_extension = os.path.splitext(file_name)
			# in top files for gromacs, replace file.itp by name given by user
			if(file_extension[1:] == 'top'):
				with open(file_name) as f:
					newText = f.read().replace(basename + '_GMX.itp', os.path.basename(output_files['itp']))
				with open(file_name, "w") as f:
					f.write(newText)
			shutil.copy(file_name, output_files[file_extension[1:]])
			fu.log('File %s succesfully created' % output_files[file_extension[1:]], out_log)

	# remove temporary folder
	fu.rm(tmp_folder)
	fu.log('Removed temporary folder: %s' % tmp_folder, out_log)
