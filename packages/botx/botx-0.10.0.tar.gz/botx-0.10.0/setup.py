# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['botx', 'botx.bot', 'botx.bot.dispatcher', 'botx.types']

package_data = \
{'': ['*']}

install_requires = \
['pydantic>=0.26,<0.27']

extras_require = \
{'async': ['aiojobs>=0.2.2,<0.3.0', 'aiohttp>=3.5.4,<4.0.0'],
 'docs': ['sphinx>=1.8,<2.0', 'sphinx_rtd_theme>=0.4.3,<0.5.0'],
 'sync': ['requests>=2.22,<3.0'],
 'test': ['pytest>=4.5,<5.0',
          'pytest-cov>=2.7,<3.0',
          'pytest-asyncio>=0.10.0,<0.11.0',
          'responses>=0.10.6,<0.11.0',
          'aresponses>=1.1,<2.0']}

setup_kwargs = {
    'name': 'botx',
    'version': '0.10.0',
    'description': 'Python implementation for Express BotX API',
    'long_description': '# pyBotX\nVersion: 1.0.0a9\n###### tags: `documentation`, `library`, `botx`, `sdk`, `python`, `bots`\n\n## Содержание\n1. [Требования](#requirements)\n2. [Пример бота](#simple-example)\n3. [Доступные типы](#types)\n\n## Требования <a id="requirements"/>\n1. HTTP-сервер с двумя обработчиками для зарезервированных endpoints:\n    * `/status` \n    * `/command`\n\n## Пример бота <a id="simple-example"/>\n```python\nimport json\n\nfrom aiohttp import web\nfrom botx import AsyncBot, Message, BotCredentials\n\nCREDENTIALS = {\n  "known_cts": {\n    "random.cts.com": [\n      {\n        "host": "random.cts.com",\n        "secret_key": "secret"\n      },\n      None\n    ]\n  }\n}\n\nbot = AsyncBot(credentials=BotCredentials(**CREDENTIALS))\nrouter = web.RouteTableDef()\n\n@bot.command(description=\'Send back command argument\')\nasync def echo(message: Message, bot: AsyncBot):\n    await bot.send_message(message.command.cmd_arg, message.sync_id, message.bot_id, message.host)\n\n@router.get(\'/status\')\nasync def status(request: web.Request) -> web.Response:\n    return web.json_response((await bot.parse_status()).dict())\n\n@router.post(\'/command\')    \nasync def command(request: web.Request) -> web.Response:\n    try:\n        data = await request.json()\n    except json.JSONDecodeError:\n        return web.json_response({"status": "bad request"}, status=400)\n\n    await bot.parse_command(data)\n    return web.json_response({"status": "accepted"}, status=202)\n\nasync def start_bot_on_startup(app: web.Application):\n    await bot.start()\n    \nasync def stop_bot_on_shutdown(app: web.Application):\n    await bot.stop()\n\nasync def create_app():\n    app = web.Application()\n    \n    app.add_routes(router)\n    app.on_startup.append(start_bot_on_startup)\n    app.on_shutdown.append(stop_bot_on_shutdown)\n    \n    await bot.start()\n    \n    return app\n\n\ndef main():\n    web.run_app(create_app(), host="0.0.0.0", port=8000)\n\n\nif __name__ == "__main__":\n    main()\n```\n\n## Доступные типы <a id="types"/>\nВсе типы поддерживают конвертацию в dict или в json, с помощью соответсвующих методов.\n1. Элементы интерфейса:\n   * BubbleElement:\n     * command: str\n     * label: Optional[str] = self.command\n   * KeyboardElement:\n     * command: str\n     * label: Optional[str] = self.command\n   * CommandUIElement:\n     * type: str\n     * label: str\n     * order: Optional[int] = None\n     * value: Optional[Any] = None\n     * name: Optional[str] = None\n     * disabled: Optional[bool] = None\n   * MenuCommand:\n     * description: str\n     * body: str\n     * name: str\n     * options: Dict[str, Any] = {}\n     * elements: List[CommandUIElement] = []\n2. Перечисления:\n   * StatusEnum:\n      * ok: str = "ok"\n      * error: str = "error"\n   * ResponseRecipientsEnum:\n      * all: str = "all"\n   * ChatTypeEnum:\n     * chat: str = "chat"\n     * group_chat: str = "group_chat"\n   * RequestTypeEnum:\n      * status: str = "status"\n      * command: str = "command"\n   * MentionTypeEnum:\n      * user: str = "user"\n      * all: str = "all"\n      * cts: str = "cts"\n      * channel: str = "channel"\n3. Типы в сообщениях:\n   * SyncID(UUID)\n   * File:\n     * data: str\n     * file_name: str\n     * file: BinaryIO | [readonly property]\n     * raw_data: bytes | [readonly property]\n     * media_type: str | [readonly property]\n     * from_file(file: Union[TextIO, BinaryIO]) -> File | [classmethod]\n   * MentionUser:\n     * user_huid: UUID\n     * name: str\n   * Mention:\n     * mention_type: MentionTypeEnum = MentionTypeEnum.user\n     * mention_data: MentionUser\n   * MessageUser:\n      * user_huid: Optional[UUID]\n      * group_chat_id: UUID\n      * chat_type: ChatTypeEnum\n      * ad_login: Optional[str]\n      * ad_domain: Optional[str]\n      * username: Optional[str]\n      * host: str\n   * MessageCommand:\n      * body: str\n      * data: Dict[str, Any] = {}\n      * cmd: str | [readonly property]\n      * cmd_arg: str | [readonly property]\n   * Message:\n      * sync_id: SyncID\n      * command: MessageCommand\n      * file: Optional[File] = None\n      * user: MessageUser | ["from" при конвертации в dict и в json]\n      * bot_id: UUID\n      * body: str | [readonly property]\n      * data: Dict[str, Any] | [readonly property]\n      * user_huid: Optional[UUID] | [readonly property]\n      * ad_login: Optional[str] | [readonly property]\n      * group_chat_id: UUID | [readonly property]\n      * chat_type: ChatTypeEnum | [readonly property]\n      * host: str | [readonly property]\n4. Типы в статусе:\n   * StatusResult:\n     * enabled: bool = True\n     * status_message: str = "Bot is working"\n     * commands: List[MenuCommand] = []\n   * Status:\n     * status: StatusEnum = StatusEnum.ok\n     * result: StatusResult = StatusResult()\n5. Типы для авторизации бота:\n   * CTS:\n     * host: str\n     * secret_key: str\n     * calculate_signature(bot_id: UUID) -> str\n   * CTSCredentials:\n     * bot_id: UUID\n     * token: str\n   * BotCredentials:\n     * known_cts: Dict[str, Tuple[CTS, Optional[CTSCredentials]]] = {}\n\n## Классы для использования ботами <a id="types"/>\n1. CommandHandler:\n    * name: str\n    * command: str\n    * description: str\n    * func: Callable\n    * exclude_from_status: bool = False\n    * use_as_default_handler: bool = False\n    * options: Dict[str, Any] = {}\n    * elements: List[CommandUIElement] = []\n    * system_command_handler: bool = False\n    * to_status_command() -> Optional[MenuCommand]\n2. CommandRouter:\n   * add_handler(handler: CommandHandler)\n   * add_commands(router: CommandRouter)\n   * command(func: Optional[Callable] = None,\n        *,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        body: Optional[str] = None,\n        use_as_default_handler: bool = False,\n        exclude_from_status: bool = False,\n        system_command_handler: bool = False) -> Callable | [decorator]\n   * Bot | AsyncBot [часть методов асинхронные]\n     * \\_\\_init__(*, credentials: Optional[BotCredentials] = None,\n        disable_credentials: bool = False) # в зависимости от бота могут быть дополнительные аргументы\n     * start()\n     * stop()\n     * parse_status() -> Status\n     * parse_command(data: Dict[str, Any]) -> bool\n     * send_message(text: str,\n        chat_id: Union[SyncID, UUID, List[UUID]],\n        bot_id: UUID,\n        host: str,\n        *,\n        file: Optional[Union[TextIO, BinaryIO]] = None,\n        recipients: Union[List[UUID], str] = ResponseRecipientsEnum.all,\n        mentions: Optional[List[Mention]] = None,\n        bubble: Optional[List[List[BubbleElement]]] = None,\n        keyboard: Optional[List[List[KeyboardElement]]] = None) -> Tuple[str, int]\n     * send_file(self,\n        file: Union[TextIO, BinaryIO],\n        chat_id: Union[SyncID, UUID],\n        bot_id: UUID,\n        host: str) -> Tuple[str, int]\n',
    'author': 'Michael Morozov',
    'author_email': 'mmorozov@ccsteam.ru',
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
