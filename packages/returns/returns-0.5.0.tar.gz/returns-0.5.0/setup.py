# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['returns', 'returns.primitives']

package_data = \
{'': ['*']}

install_requires = \
['typing-extensions>=3.7,<4.0']

setup_kwargs = {
    'name': 'returns',
    'version': '0.5.0',
    'description': 'Make your functions return something meaningful, typed, and safe!',
    'long_description': '[![Returns logo](https://raw.githubusercontent.com/dry-python/brand/master/logo/returns.png)](https://github.com/dry-python/returns)\n\n-----\n\n[![Build Status](https://travis-ci.org/dry-python/returns.svg?branch=master)](https://travis-ci.org/dry-python/returns) [![Coverage Status](https://coveralls.io/repos/github/dry-python/returns/badge.svg?branch=master)](https://coveralls.io/github/dry-python/returns?branch=master) [![Documentation Status](https://readthedocs.org/projects/returns/badge/?version=latest)](https://returns.readthedocs.io/en/latest/?badge=latest) [![Python Version](https://img.shields.io/pypi/pyversions/returns.svg)](https://pypi.org/project/returns/) [![wemake-python-styleguide](https://img.shields.io/badge/style-wemake-000000.svg)](https://github.com/wemake-services/wemake-python-styleguide)\n\n-----\n\nMake your functions return something meaningful, typed, and safe!\n\n\n## Features\n\n- Provides a bunch of primitives to write declarative business logic\n- Enforces [Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/)\n- Fully typed with annotations and checked with `mypy`, [PEP561 compatible](https://www.python.org/dev/peps/pep-0561/)\n- Pythonic and pleasant to write and to read (!)\n- WIP: `asyncio` support\n\n\n## Installation\n\n```bash\npip install returns\n```\n\nMake sure you know how to get started, [check out our docs](https://returns.readthedocs.io/en/latest/)!\n\n\n## Why?\n\nConsider this code that you can find in **any** `python` project.\n\n### Straight-forward approach\n\n```python\nimport requests\n\ndef fetch_user_profile(user_id: int) -> \'UserProfile\':\n    """Fetches UserProfile dict from foreign API."""\n    response = requests.get(\'/api/users/{0}\'.format(user_id))\n    response.raise_for_status()\n    return response.json()\n```\n\nSeems legit, does not it?\nIt also seems like a pretty straight forward code to test.\nAll you need is to mock `requests.get` to return the structure you need.\n\nBut, there are hidden problems in this tiny code sample\nthat are almost impossible to spot at the first glance.\n\n### Hidden problems\n\nLet\'s have a look at the exact same code,\nbut with the all hidden problems explained.\n\n```python\nimport requests\n\ndef fetch_user_profile(user_id: int) -> \'UserProfile\':\n    """Fetches UserProfile dict from foreign API."""\n    response = requests.get(\'/api/users/{0}\'.format(user_id))\n\n    # What if we try to find user that does not exist?\n    # Or network will go down? Or the server will return 500?\n    # In this case the next line will fail with an exception.\n    # We need to handle all possible errors in this function\n    # and do not return corrupt data to consumers.\n    response.raise_for_status()\n\n    # What if we have received invalid JSON?\n    # Next line will raise an exception!\n    return response.json()\n```\n\nNow, all (probably all?) problems are clear.\nHow can we be sure that this function will be safe\nto use inside our complex business logic?\n\nWe really can not be sure!\nWe will have to create **lots** of `try` and `except` cases\njust to catch the expected exceptions.\n\nOur code will become complex and unreadable with all this mess!\n\n\n### Pipeline example\n\n\n```python\nimport requests\nfrom returns.functions import pipeline, safe\nfrom returns.result import Result\n\nclass FetchUserProfile(object):\n    """Single responsibility callable object that fetches user profile."""\n\n    #: You can later use dependency injection to replace `requests`\n    #: with any other http library (or even a custom service).\n    _http = requests\n\n    @pipeline\n    def __call__(self, user_id: int) -> Result[\'UserProfile\', Exception]:\n        """Fetches UserProfile dict from foreign API."""\n        response = self._make_request(user_id).unwrap()\n        return self._parse_json(response)\n\n    @safe\n    def _make_request(self, user_id: int) -> requests.Response:\n        response = self._http.get(\'/api/users/{0}\'.format(user_id))\n        response.raise_for_status()\n        return response\n\n    @safe\n    def _parse_json(self, response: requests.Response) -> \'UserProfile\':\n        return response.json()\n```\n\nNow we have a clean and a safe way to express our business need.\nWe start from making a request, that might fail at any moment.\n\nNow, instead of returning a regular value\nit returns a wrapped value inside a special container\nthanks to the\n[@safe](https://returns.readthedocs.io/en/latest/pages/functions.html#returns.functions.safe)\ndecorator.\n\nIt will return [Success[Response] or Failure[Exception]](https://returns.readthedocs.io/en/latest/pages/result.html).\nAnd will never throw this exception at us.\n\nWhen we will need raw value, we can use `.unwrap()` method to get it.\nIf the result is `Failure[Exception]` we will actually raise an exception at this point.\nBut it is safe to use `.unwrap()` inside [@pipeline](https://returns.readthedocs.io/en/latest/pages/functions.html#returns.functions.pipeline)\nfunctions.\nBecause it will catch this exception and wrap it inside a new `Failure[Exception]`!\n\nAnd we can clearly see all result patterns that might happen in this particular case:\n- `Success[UserProfile]`\n- `Failure[HttpException]`\n- `Failure[JsonDecodeException]`\n\nAnd we can work with each of them precisely.\n\nWhat more? [Go to the docs!](https://returns.readthedocs.io)\n\n## License\n\nMIT.\n',
    'author': 'sobolevn',
    'author_email': 'mail@sobolevn.me',
    'url': 'https://returns.readthedocs.io',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
