# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_antimony', [dirname(__file__)])
        except ImportError:
            import _antimony
            return _antimony
        if fp is not None:
            try:
                _mod = imp.load_module('_antimony', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _antimony = swig_import_helper()
    del swig_import_helper
else:
    import _antimony
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _antimony.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _antimony.SwigPyIterator_value(self)

    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _antimony.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _antimony.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _antimony.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _antimony.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _antimony.SwigPyIterator_copy(self)

    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _antimony.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _antimony.SwigPyIterator___next__(self)

    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _antimony.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _antimony.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _antimony.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _antimony.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _antimony.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _antimony.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _antimony.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _antimony.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _antimony.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class UnsignedLongVector(_object):
    """Proxy of C++ std::vector<(unsigned long)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnsignedLongVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UnsignedLongVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(UnsignedLongVector self) -> SwigPyIterator"""
        return _antimony.UnsignedLongVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(UnsignedLongVector self) -> bool"""
        return _antimony.UnsignedLongVector___nonzero__(self)

    def __bool__(self):
        """__bool__(UnsignedLongVector self) -> bool"""
        return _antimony.UnsignedLongVector___bool__(self)

    def __len__(self):
        """__len__(UnsignedLongVector self) -> std::vector< unsigned long >::size_type"""
        return _antimony.UnsignedLongVector___len__(self)

    def pop(self):
        """pop(UnsignedLongVector self) -> std::vector< unsigned long >::value_type"""
        return _antimony.UnsignedLongVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(UnsignedLongVector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> UnsignedLongVector"""
        return _antimony.UnsignedLongVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(UnsignedLongVector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, 
            UnsignedLongVector v=std::vector< unsigned long,std::allocator< unsigned long > >())
        __setslice__(UnsignedLongVector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        """
        return _antimony.UnsignedLongVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(UnsignedLongVector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _antimony.UnsignedLongVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(UnsignedLongVector self, std::vector< unsigned long >::difference_type i)
        __delitem__(UnsignedLongVector self, PySliceObject * slice)
        """
        return _antimony.UnsignedLongVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(UnsignedLongVector self, PySliceObject * slice) -> UnsignedLongVector
        __getitem__(UnsignedLongVector self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _antimony.UnsignedLongVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(UnsignedLongVector self, PySliceObject * slice, UnsignedLongVector v)
        __setitem__(UnsignedLongVector self, PySliceObject * slice)
        __setitem__(UnsignedLongVector self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _antimony.UnsignedLongVector___setitem__(self, *args)

    def append(self, *args):
        """append(UnsignedLongVector self, std::vector< unsigned long >::value_type const & x)"""
        return _antimony.UnsignedLongVector_append(self, *args)

    def empty(self):
        """empty(UnsignedLongVector self) -> bool"""
        return _antimony.UnsignedLongVector_empty(self)

    def size(self):
        """size(UnsignedLongVector self) -> std::vector< unsigned long >::size_type"""
        return _antimony.UnsignedLongVector_size(self)

    def clear(self):
        """clear(UnsignedLongVector self)"""
        return _antimony.UnsignedLongVector_clear(self)

    def swap(self, *args):
        """swap(UnsignedLongVector self, UnsignedLongVector v)"""
        return _antimony.UnsignedLongVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(UnsignedLongVector self) -> std::vector< unsigned long >::allocator_type"""
        return _antimony.UnsignedLongVector_get_allocator(self)

    def begin(self):
        """begin(UnsignedLongVector self) -> std::vector< unsigned long >::iterator"""
        return _antimony.UnsignedLongVector_begin(self)

    def end(self):
        """end(UnsignedLongVector self) -> std::vector< unsigned long >::iterator"""
        return _antimony.UnsignedLongVector_end(self)

    def rbegin(self):
        """rbegin(UnsignedLongVector self) -> std::vector< unsigned long >::reverse_iterator"""
        return _antimony.UnsignedLongVector_rbegin(self)

    def rend(self):
        """rend(UnsignedLongVector self) -> std::vector< unsigned long >::reverse_iterator"""
        return _antimony.UnsignedLongVector_rend(self)

    def pop_back(self):
        """pop_back(UnsignedLongVector self)"""
        return _antimony.UnsignedLongVector_pop_back(self)

    def erase(self, *args):
        """
        erase(UnsignedLongVector self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(UnsignedLongVector self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _antimony.UnsignedLongVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(unsigned long)> self) -> UnsignedLongVector
        __init__(std::vector<(unsigned long)> self, UnsignedLongVector arg2) -> UnsignedLongVector
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size) -> UnsignedLongVector
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> UnsignedLongVector
        """
        this = _antimony.new_UnsignedLongVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(UnsignedLongVector self, std::vector< unsigned long >::value_type const & x)"""
        return _antimony.UnsignedLongVector_push_back(self, *args)

    def front(self):
        """front(UnsignedLongVector self) -> std::vector< unsigned long >::value_type const &"""
        return _antimony.UnsignedLongVector_front(self)

    def back(self):
        """back(UnsignedLongVector self) -> std::vector< unsigned long >::value_type const &"""
        return _antimony.UnsignedLongVector_back(self)

    def assign(self, *args):
        """assign(UnsignedLongVector self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _antimony.UnsignedLongVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(UnsignedLongVector self, std::vector< unsigned long >::size_type new_size)
        resize(UnsignedLongVector self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _antimony.UnsignedLongVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(UnsignedLongVector self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(UnsignedLongVector self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, 
            std::vector< unsigned long >::value_type const & x)
        """
        return _antimony.UnsignedLongVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(UnsignedLongVector self, std::vector< unsigned long >::size_type n)"""
        return _antimony.UnsignedLongVector_reserve(self, *args)

    def capacity(self):
        """capacity(UnsignedLongVector self) -> std::vector< unsigned long >::size_type"""
        return _antimony.UnsignedLongVector_capacity(self)

    __swig_destroy__ = _antimony.delete_UnsignedLongVector
    __del__ = lambda self : None;
UnsignedLongVector_swigregister = _antimony.UnsignedLongVector_swigregister
UnsignedLongVector_swigregister(UnsignedLongVector)

class DoubleVector(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(DoubleVector self) -> SwigPyIterator"""
        return _antimony.DoubleVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(DoubleVector self) -> bool"""
        return _antimony.DoubleVector___nonzero__(self)

    def __bool__(self):
        """__bool__(DoubleVector self) -> bool"""
        return _antimony.DoubleVector___bool__(self)

    def __len__(self):
        """__len__(DoubleVector self) -> std::vector< double >::size_type"""
        return _antimony.DoubleVector___len__(self)

    def pop(self):
        """pop(DoubleVector self) -> std::vector< double >::value_type"""
        return _antimony.DoubleVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DoubleVector"""
        return _antimony.DoubleVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            DoubleVector v=std::vector< double,std::allocator< double > >())
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _antimony.DoubleVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _antimony.DoubleVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(DoubleVector self, std::vector< double >::difference_type i)
        __delitem__(DoubleVector self, PySliceObject * slice)
        """
        return _antimony.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(DoubleVector self, PySliceObject * slice) -> DoubleVector
        __getitem__(DoubleVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _antimony.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(DoubleVector self, PySliceObject * slice, DoubleVector v)
        __setitem__(DoubleVector self, PySliceObject * slice)
        __setitem__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _antimony.DoubleVector___setitem__(self, *args)

    def append(self, *args):
        """append(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _antimony.DoubleVector_append(self, *args)

    def empty(self):
        """empty(DoubleVector self) -> bool"""
        return _antimony.DoubleVector_empty(self)

    def size(self):
        """size(DoubleVector self) -> std::vector< double >::size_type"""
        return _antimony.DoubleVector_size(self)

    def clear(self):
        """clear(DoubleVector self)"""
        return _antimony.DoubleVector_clear(self)

    def swap(self, *args):
        """swap(DoubleVector self, DoubleVector v)"""
        return _antimony.DoubleVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(DoubleVector self) -> std::vector< double >::allocator_type"""
        return _antimony.DoubleVector_get_allocator(self)

    def begin(self):
        """begin(DoubleVector self) -> std::vector< double >::iterator"""
        return _antimony.DoubleVector_begin(self)

    def end(self):
        """end(DoubleVector self) -> std::vector< double >::iterator"""
        return _antimony.DoubleVector_end(self)

    def rbegin(self):
        """rbegin(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _antimony.DoubleVector_rbegin(self)

    def rend(self):
        """rend(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _antimony.DoubleVector_rend(self)

    def pop_back(self):
        """pop_back(DoubleVector self)"""
        return _antimony.DoubleVector_pop_back(self)

    def erase(self, *args):
        """
        erase(DoubleVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DoubleVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _antimony.DoubleVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> DoubleVector
        __init__(std::vector<(double)> self, DoubleVector arg2) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DoubleVector
        """
        this = _antimony.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _antimony.DoubleVector_push_back(self, *args)

    def front(self):
        """front(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _antimony.DoubleVector_front(self)

    def back(self):
        """back(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _antimony.DoubleVector_back(self)

    def assign(self, *args):
        """assign(DoubleVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _antimony.DoubleVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(DoubleVector self, std::vector< double >::size_type new_size)
        resize(DoubleVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _antimony.DoubleVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _antimony.DoubleVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(DoubleVector self, std::vector< double >::size_type n)"""
        return _antimony.DoubleVector_reserve(self, *args)

    def capacity(self):
        """capacity(DoubleVector self) -> std::vector< double >::size_type"""
        return _antimony.DoubleVector_capacity(self)

    __swig_destroy__ = _antimony.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _antimony.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class DoubleVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(DoubleVectorVector self) -> SwigPyIterator"""
        return _antimony.DoubleVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(DoubleVectorVector self) -> bool"""
        return _antimony.DoubleVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(DoubleVectorVector self) -> bool"""
        return _antimony.DoubleVectorVector___bool__(self)

    def __len__(self):
        """__len__(DoubleVectorVector self) -> std::vector< std::vector< double > >::size_type"""
        return _antimony.DoubleVectorVector___len__(self)

    def pop(self):
        """pop(DoubleVectorVector self) -> DoubleVector"""
        return _antimony.DoubleVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> DoubleVectorVector"""
        return _antimony.DoubleVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, 
            DoubleVectorVector v=std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >())
        __setslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        """
        return _antimony.DoubleVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _antimony.DoubleVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(DoubleVectorVector self, PySliceObject * slice)
        """
        return _antimony.DoubleVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(DoubleVectorVector self, PySliceObject * slice) -> DoubleVectorVector
        __getitem__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i) -> DoubleVector
        """
        return _antimony.DoubleVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(DoubleVectorVector self, PySliceObject * slice, DoubleVectorVector v)
        __setitem__(DoubleVectorVector self, PySliceObject * slice)
        __setitem__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, DoubleVector x)
        """
        return _antimony.DoubleVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(DoubleVectorVector self, DoubleVector x)"""
        return _antimony.DoubleVectorVector_append(self, *args)

    def empty(self):
        """empty(DoubleVectorVector self) -> bool"""
        return _antimony.DoubleVectorVector_empty(self)

    def size(self):
        """size(DoubleVectorVector self) -> std::vector< std::vector< double > >::size_type"""
        return _antimony.DoubleVectorVector_size(self)

    def clear(self):
        """clear(DoubleVectorVector self)"""
        return _antimony.DoubleVectorVector_clear(self)

    def swap(self, *args):
        """swap(DoubleVectorVector self, DoubleVectorVector v)"""
        return _antimony.DoubleVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(DoubleVectorVector self) -> std::vector< std::vector< double > >::allocator_type"""
        return _antimony.DoubleVectorVector_get_allocator(self)

    def begin(self):
        """begin(DoubleVectorVector self) -> std::vector< std::vector< double > >::iterator"""
        return _antimony.DoubleVectorVector_begin(self)

    def end(self):
        """end(DoubleVectorVector self) -> std::vector< std::vector< double > >::iterator"""
        return _antimony.DoubleVectorVector_end(self)

    def rbegin(self):
        """rbegin(DoubleVectorVector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _antimony.DoubleVectorVector_rbegin(self)

    def rend(self):
        """rend(DoubleVectorVector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _antimony.DoubleVectorVector_rend(self)

    def pop_back(self):
        """pop_back(DoubleVectorVector self)"""
        return _antimony.DoubleVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(DoubleVectorVector self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(DoubleVectorVector self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _antimony.DoubleVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> DoubleVectorVector
        __init__(std::vector<(std::vector<(double)>)> self, DoubleVectorVector arg2) -> DoubleVectorVector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> DoubleVectorVector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, DoubleVector value) -> DoubleVectorVector
        """
        this = _antimony.new_DoubleVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(DoubleVectorVector self, DoubleVector x)"""
        return _antimony.DoubleVectorVector_push_back(self, *args)

    def front(self):
        """front(DoubleVectorVector self) -> DoubleVector"""
        return _antimony.DoubleVectorVector_front(self)

    def back(self):
        """back(DoubleVectorVector self) -> DoubleVector"""
        return _antimony.DoubleVectorVector_back(self)

    def assign(self, *args):
        """assign(DoubleVectorVector self, std::vector< std::vector< double > >::size_type n, DoubleVector x)"""
        return _antimony.DoubleVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(DoubleVectorVector self, std::vector< std::vector< double > >::size_type new_size)
        resize(DoubleVectorVector self, std::vector< std::vector< double > >::size_type new_size, DoubleVector x)
        """
        return _antimony.DoubleVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(DoubleVectorVector self, std::vector< std::vector< double > >::iterator pos, DoubleVector x) -> std::vector< std::vector< double > >::iterator
        insert(DoubleVectorVector self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, 
            DoubleVector x)
        """
        return _antimony.DoubleVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(DoubleVectorVector self, std::vector< std::vector< double > >::size_type n)"""
        return _antimony.DoubleVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(DoubleVectorVector self) -> std::vector< std::vector< double > >::size_type"""
        return _antimony.DoubleVectorVector_capacity(self)

    __swig_destroy__ = _antimony.delete_DoubleVectorVector
    __del__ = lambda self : None;
DoubleVectorVector_swigregister = _antimony.DoubleVectorVector_swigregister
DoubleVectorVector_swigregister(DoubleVectorVector)

class StringVector(_object):
    """Proxy of C++ std::vector<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(StringVector self) -> SwigPyIterator"""
        return _antimony.StringVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(StringVector self) -> bool"""
        return _antimony.StringVector___nonzero__(self)

    def __bool__(self):
        """__bool__(StringVector self) -> bool"""
        return _antimony.StringVector___bool__(self)

    def __len__(self):
        """__len__(StringVector self) -> std::vector< std::string >::size_type"""
        return _antimony.StringVector___len__(self)

    def pop(self):
        """pop(StringVector self) -> std::vector< std::string >::value_type"""
        return _antimony.StringVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> StringVector"""
        return _antimony.StringVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, 
            StringVector v=std::vector< std::string,std::allocator< std::string > >())
        __setslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        """
        return _antimony.StringVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _antimony.StringVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(StringVector self, std::vector< std::string >::difference_type i)
        __delitem__(StringVector self, PySliceObject * slice)
        """
        return _antimony.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(StringVector self, PySliceObject * slice) -> StringVector
        __getitem__(StringVector self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _antimony.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(StringVector self, PySliceObject * slice, StringVector v)
        __setitem__(StringVector self, PySliceObject * slice)
        __setitem__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _antimony.StringVector___setitem__(self, *args)

    def append(self, *args):
        """append(StringVector self, std::vector< std::string >::value_type const & x)"""
        return _antimony.StringVector_append(self, *args)

    def empty(self):
        """empty(StringVector self) -> bool"""
        return _antimony.StringVector_empty(self)

    def size(self):
        """size(StringVector self) -> std::vector< std::string >::size_type"""
        return _antimony.StringVector_size(self)

    def clear(self):
        """clear(StringVector self)"""
        return _antimony.StringVector_clear(self)

    def swap(self, *args):
        """swap(StringVector self, StringVector v)"""
        return _antimony.StringVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(StringVector self) -> std::vector< std::string >::allocator_type"""
        return _antimony.StringVector_get_allocator(self)

    def begin(self):
        """begin(StringVector self) -> std::vector< std::string >::iterator"""
        return _antimony.StringVector_begin(self)

    def end(self):
        """end(StringVector self) -> std::vector< std::string >::iterator"""
        return _antimony.StringVector_end(self)

    def rbegin(self):
        """rbegin(StringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _antimony.StringVector_rbegin(self)

    def rend(self):
        """rend(StringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _antimony.StringVector_rend(self)

    def pop_back(self):
        """pop_back(StringVector self)"""
        return _antimony.StringVector_pop_back(self)

    def erase(self, *args):
        """
        erase(StringVector self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(StringVector self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _antimony.StringVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::string)> self) -> StringVector
        __init__(std::vector<(std::string)> self, StringVector arg2) -> StringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> StringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> StringVector
        """
        this = _antimony.new_StringVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(StringVector self, std::vector< std::string >::value_type const & x)"""
        return _antimony.StringVector_push_back(self, *args)

    def front(self):
        """front(StringVector self) -> std::vector< std::string >::value_type const &"""
        return _antimony.StringVector_front(self)

    def back(self):
        """back(StringVector self) -> std::vector< std::string >::value_type const &"""
        return _antimony.StringVector_back(self)

    def assign(self, *args):
        """assign(StringVector self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _antimony.StringVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(StringVector self, std::vector< std::string >::size_type new_size)
        resize(StringVector self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _antimony.StringVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(StringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(StringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, 
            std::vector< std::string >::value_type const & x)
        """
        return _antimony.StringVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(StringVector self, std::vector< std::string >::size_type n)"""
        return _antimony.StringVector_reserve(self, *args)

    def capacity(self):
        """capacity(StringVector self) -> std::vector< std::string >::size_type"""
        return _antimony.StringVector_capacity(self)

    __swig_destroy__ = _antimony.delete_StringVector
    __del__ = lambda self : None;
StringVector_swigregister = _antimony.StringVector_swigregister
StringVector_swigregister(StringVector)

class StringVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::string)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(StringVectorVector self) -> SwigPyIterator"""
        return _antimony.StringVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(StringVectorVector self) -> bool"""
        return _antimony.StringVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(StringVectorVector self) -> bool"""
        return _antimony.StringVectorVector___bool__(self)

    def __len__(self):
        """__len__(StringVectorVector self) -> std::vector< std::vector< std::string > >::size_type"""
        return _antimony.StringVectorVector___len__(self)

    def pop(self):
        """pop(StringVectorVector self) -> StringVector"""
        return _antimony.StringVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(StringVectorVector self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j) -> StringVectorVector"""
        return _antimony.StringVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(StringVectorVector self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j, 
            StringVectorVector v=std::vector< std::vector< std::string,std::allocator< std::string > >,std::allocator< std::vector< std::string,std::allocator< std::string > > > >())
        __setslice__(StringVectorVector self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j)
        """
        return _antimony.StringVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(StringVectorVector self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j)"""
        return _antimony.StringVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(StringVectorVector self, std::vector< std::vector< std::string > >::difference_type i)
        __delitem__(StringVectorVector self, PySliceObject * slice)
        """
        return _antimony.StringVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(StringVectorVector self, PySliceObject * slice) -> StringVectorVector
        __getitem__(StringVectorVector self, std::vector< std::vector< std::string > >::difference_type i) -> StringVector
        """
        return _antimony.StringVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(StringVectorVector self, PySliceObject * slice, StringVectorVector v)
        __setitem__(StringVectorVector self, PySliceObject * slice)
        __setitem__(StringVectorVector self, std::vector< std::vector< std::string > >::difference_type i, StringVector x)
        """
        return _antimony.StringVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(StringVectorVector self, StringVector x)"""
        return _antimony.StringVectorVector_append(self, *args)

    def empty(self):
        """empty(StringVectorVector self) -> bool"""
        return _antimony.StringVectorVector_empty(self)

    def size(self):
        """size(StringVectorVector self) -> std::vector< std::vector< std::string > >::size_type"""
        return _antimony.StringVectorVector_size(self)

    def clear(self):
        """clear(StringVectorVector self)"""
        return _antimony.StringVectorVector_clear(self)

    def swap(self, *args):
        """swap(StringVectorVector self, StringVectorVector v)"""
        return _antimony.StringVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(StringVectorVector self) -> std::vector< std::vector< std::string > >::allocator_type"""
        return _antimony.StringVectorVector_get_allocator(self)

    def begin(self):
        """begin(StringVectorVector self) -> std::vector< std::vector< std::string > >::iterator"""
        return _antimony.StringVectorVector_begin(self)

    def end(self):
        """end(StringVectorVector self) -> std::vector< std::vector< std::string > >::iterator"""
        return _antimony.StringVectorVector_end(self)

    def rbegin(self):
        """rbegin(StringVectorVector self) -> std::vector< std::vector< std::string > >::reverse_iterator"""
        return _antimony.StringVectorVector_rbegin(self)

    def rend(self):
        """rend(StringVectorVector self) -> std::vector< std::vector< std::string > >::reverse_iterator"""
        return _antimony.StringVectorVector_rend(self)

    def pop_back(self):
        """pop_back(StringVectorVector self)"""
        return _antimony.StringVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(StringVectorVector self, std::vector< std::vector< std::string > >::iterator pos) -> std::vector< std::vector< std::string > >::iterator
        erase(StringVectorVector self, std::vector< std::vector< std::string > >::iterator first, std::vector< std::vector< std::string > >::iterator last) -> std::vector< std::vector< std::string > >::iterator
        """
        return _antimony.StringVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(std::string)>)> self) -> StringVectorVector
        __init__(std::vector<(std::vector<(std::string)>)> self, StringVectorVector arg2) -> StringVectorVector
        __init__(std::vector<(std::vector<(std::string)>)> self, std::vector< std::vector< std::string > >::size_type size) -> StringVectorVector
        __init__(std::vector<(std::vector<(std::string)>)> self, std::vector< std::vector< std::string > >::size_type size, StringVector value) -> StringVectorVector
        """
        this = _antimony.new_StringVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(StringVectorVector self, StringVector x)"""
        return _antimony.StringVectorVector_push_back(self, *args)

    def front(self):
        """front(StringVectorVector self) -> StringVector"""
        return _antimony.StringVectorVector_front(self)

    def back(self):
        """back(StringVectorVector self) -> StringVector"""
        return _antimony.StringVectorVector_back(self)

    def assign(self, *args):
        """assign(StringVectorVector self, std::vector< std::vector< std::string > >::size_type n, StringVector x)"""
        return _antimony.StringVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(StringVectorVector self, std::vector< std::vector< std::string > >::size_type new_size)
        resize(StringVectorVector self, std::vector< std::vector< std::string > >::size_type new_size, StringVector x)
        """
        return _antimony.StringVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(StringVectorVector self, std::vector< std::vector< std::string > >::iterator pos, StringVector x) -> std::vector< std::vector< std::string > >::iterator
        insert(StringVectorVector self, std::vector< std::vector< std::string > >::iterator pos, std::vector< std::vector< std::string > >::size_type n, 
            StringVector x)
        """
        return _antimony.StringVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(StringVectorVector self, std::vector< std::vector< std::string > >::size_type n)"""
        return _antimony.StringVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(StringVectorVector self) -> std::vector< std::vector< std::string > >::size_type"""
        return _antimony.StringVectorVector_capacity(self)

    __swig_destroy__ = _antimony.delete_StringVectorVector
    __del__ = lambda self : None;
StringVectorVector_swigregister = _antimony.StringVectorVector_swigregister
StringVectorVector_swigregister(StringVectorVector)

LIBANTIMONY_VERSION_STRING = _antimony.LIBANTIMONY_VERSION_STRING
rdBecomes = _antimony.rdBecomes
rdActivates = _antimony.rdActivates
rdInhibits = _antimony.rdInhibits
rdInfluences = _antimony.rdInfluences
rdBecomesIrreversibly = _antimony.rdBecomesIrreversibly
varSpeciesUndef = _antimony.varSpeciesUndef
varFormulaUndef = _antimony.varFormulaUndef
varDNA = _antimony.varDNA
varFormulaOperator = _antimony.varFormulaOperator
varReactionGene = _antimony.varReactionGene
varReactionUndef = _antimony.varReactionUndef
varInteraction = _antimony.varInteraction
varUndefined = _antimony.varUndefined
varModule = _antimony.varModule
varEvent = _antimony.varEvent
varCompartment = _antimony.varCompartment
varStrand = _antimony.varStrand
varUnitDefinition = _antimony.varUnitDefinition
varDeleted = _antimony.varDeleted
varConstraint = _antimony.varConstraint
varSboTermWrapper = _antimony.varSboTermWrapper
allSymbols = _antimony.allSymbols
allSpecies = _antimony.allSpecies
allFormulas = _antimony.allFormulas
allDNA = _antimony.allDNA
allOperators = _antimony.allOperators
allGenes = _antimony.allGenes
allReactions = _antimony.allReactions
allInteractions = _antimony.allInteractions
allEvents = _antimony.allEvents
allCompartments = _antimony.allCompartments
allUnknown = _antimony.allUnknown
varSpecies = _antimony.varSpecies
varFormulas = _antimony.varFormulas
varOperators = _antimony.varOperators
varCompartments = _antimony.varCompartments
constSpecies = _antimony.constSpecies
constFormulas = _antimony.constFormulas
constOperators = _antimony.constOperators
constCompartments = _antimony.constCompartments
subModules = _antimony.subModules
expandedStrands = _antimony.expandedStrands
modularStrands = _antimony.modularStrands
allUnits = _antimony.allUnits
allDeleted = _antimony.allDeleted
allConstraints = _antimony.allConstraints
constDEFAULT = _antimony.constDEFAULT
constVAR = _antimony.constVAR
constCONST = _antimony.constCONST
formulaINITIAL = _antimony.formulaINITIAL
formulaASSIGNMENT = _antimony.formulaASSIGNMENT
formulaRATE = _antimony.formulaRATE
formulaKINETIC = _antimony.formulaKINETIC
formulaTRIGGER = _antimony.formulaTRIGGER
delFull = _antimony.delFull
delEventPriority = _antimony.delEventPriority
delEventDelay = _antimony.delEventDelay
delEventAssignment = _antimony.delEventAssignment
delRateRule = _antimony.delRateRule
delInitialAssignment = _antimony.delInitialAssignment
delAssignmentRule = _antimony.delAssignmentRule
delReactant = _antimony.delReactant
delProduct = _antimony.delProduct
delKineticLaw = _antimony.delKineticLaw
delModifier = _antimony.delModifier
delInteraction = _antimony.delInteraction
constNONE = _antimony.constNONE
constGT = _antimony.constGT
constLT = _antimony.constLT
constEQ = _antimony.constEQ
constGEQ = _antimony.constGEQ
constLEQ = _antimony.constLEQ
constNEQ = _antimony.constNEQ

def loadFile(*args):
  """
    loadFile(char const * filename) -> long

    Load a file of any format libAntimony knows about (potentially
    Antimony, SBML, or CellML).  If all attempts fail, the errors from
    the attempt to read the file in the Antimony format are saved, so if
    the file is actually SBML or CellML, the error is likely to be 'but
    contains errors, the reported errors will be from the attempt to read
    it as Antimony, and a '-1' is returned.

    NOTE:  This function will not attempt to parse the file as SBML if
    libAntimony is compiled with the '-NSBML' flag, and will not attempt
    to parse the file as CellML if compiled with the '-NCELLML' flag.

    Returns a long integer indicating the index of the file read and
    stored.  On an error, returns -1 and no information is stored.

    Parameter 'filename' is The filename as a character string.  May be
    either absolute or relative to the directory the executable is being
    run from.

    See also getLastError().

    """
  return _antimony.loadFile(*args)

def loadString(*args):
  """
    loadString(char const * model) -> long

    Load a string of any format libAntimony knows about (potentially
    Antimony, SBML, or CellML).  The first attempts to read the string as
    SBML, and if this results in an error, then reads it as Antimony.  If
    this, too, results in an error, the second error is saved, and a '-1'
    is returned.

    NOTE:  This function will not attempt to parse the string as SBML if
    libAntimony is compiled with the '-NSBML' flag, and will not attempt
    to parse the string as CellML if compiled with the '-NCELLML' flag.

    Returns a long integer indicating the index of the string read and
    stored.  On an error, returns -1 and no information is stored.

    Parameter 'model' is The model, in (potentially) Antimony, SBML, or
    CellML format.

    See also getLastError().

    """
  return _antimony.loadString(*args)

def loadAntimonyFile(*args):
  """
    loadAntimonyFile(char const * filename) -> long

    Loads a file and parses it as an Antimony file.  On an error, the
    error is saved, -1 is returned, and no information is stored.

    Returns a long integer indicating the index of the file read and
    stored.  On an error, returns -1 and no information is stored.

    Parameter 'filename' is The filename as a character string.  May be
    either absolute or relative to the directory the executable is being
    run from.

    See also getLastError().

    """
  return _antimony.loadAntimonyFile(*args)

def loadAntimonyString(*args):
  """
    loadAntimonyString(char const * model) -> long

    Loads a string and parses it as an Antimony set of modules.  On an
    error, the error is saved, -1 is returned, and no information is
    stored.

    Returns a long integer indicating the index of the string read and
    stored.  On an error, returns -1 and no information is stored.

    Parameter 'model' is The model in Antimony format.

    See also getLastError().

    """
  return _antimony.loadAntimonyString(*args)

def loadSBMLFile(*args):
  """
    loadSBMLFile(char const * filename) -> long

    @brief Load a file known to be SBML.

    Loads a file and parses it (using libSBML) as an SBML file.  On an
    error, the error is saved, -1 is returned, and no information is
    stored.  Returns a long integer indicating the index of the file read
    and stored.  On an error, returns -1 and no information is stored.
    NOTE:  This function is unavailable when libAntimony is compiled with
    the '-NSBML' flag.

    Parameter 'filename' is The filename as a character string.  May be
    either absolute or relative to the directory the executable is being
    run from.

    See also getLastError().

    """
  return _antimony.loadSBMLFile(*args)

def loadSBMLString(*args):
  """
    loadSBMLString(char const * model) -> long

    @brief Load a string known to be SBML.

    Loads a string and parses it (using libSBML) as an SBML file.  On an
    error, the error is saved, -1 is returned, and no information is
    stored.  Returns a long integer indicating the index of the string
    read and stored.  On an error, returns -1 and no information is
    stored.  NOTE:  This function is unavailable when libAntimony is
    compiled with the '-NSBML' flag.

    Parameter 'model' is The model, in SBML format.

    See also getLastError().

    """
  return _antimony.loadSBMLString(*args)

def loadSBMLStringWithLocation(*args):
  """
    loadSBMLStringWithLocation(char const * model, char const * location) -> long

    @brief Load a string known to be SBML with its file location.

    Loads a string and parses it (using libSBML) as an SBML file.  On an
    error, the error is saved, -1 is returned, and no information is
    stored.  This function additionally allows you to set the location of
    the string, in case there are relative file references in the file
    (as there can be in some hierarchical models).  Returns a long
    integer indicating the index of the string read and stored.  On an
    error, returns -1 and no information is stored.  NOTE:  This function
    is unavailable when libAntimony is compiled with the '-NSBML' flag.

    Parameter 'model' is The model, in SBML format.  Parameter 'location'
    is The location of the file (i.e. 'file1.xml' or
    '/home/user/sbml/models/file.xml')

    See also getLastError().

    """
  return _antimony.loadSBMLStringWithLocation(*args)

def loadCellMLFile(*args):
  """
    loadCellMLFile(char const * filename) -> long

    @brief Load a file known to be CellML.

    Loads a file and parses it (using libCellML) as a CellML file.  On an
    error, the error is saved, -1 is returned, and no information is
    stored.  Returns a long integer indicating the index of the file read
    and stored.  On an error, returns -1 and no information is stored.
    NOTE:  This function is unavailable when libAntimony is compiled with
    the '-NCELLML' flag.

    Parameter 'filename' is The filename as a character string.  May be
    either absolute or relative to the directory the executable is being
    run from.

    See also getLastError().

    """
  return _antimony.loadCellMLFile(*args)

def loadCellMLString(*args):
  """
    loadCellMLString(char const * model) -> long

    @brief Load a string known to be CellML.

    Loads a string and parses it (using libCellML) as a CellML file.  On
    an error, the error is saved, -1 is returned, and no information is
    stored.  Returns a long integer indicating the index of the string
    read and stored.  On an error, returns -1 and no information is
    stored.  NOTE:  This function is unavailable when libAntimony is
    compiled with the '-NCELLML' flag.

    Parameter 'model' is The model, in CellML format.

    See also getLastError().

    """
  return _antimony.loadCellMLString(*args)

def getNumFiles():
  """
    getNumFiles() -> unsigned long

    @brief Returns the number of files loaded into memory so far.

    Every time 'load<file/string>' is called successfully, the module(s)
    in those files are saved.  This function will tell you how many sets
    of modules from successful reads are resident in memory.  Returns The
    number of files currently stored in memory.

    """
  return _antimony.getNumFiles()

def revertTo(*args):
  """
    revertTo(long index) -> bool

    Change the 'active' set of modules to the ones from the given index
    (as received from 'load<file/string>').  Attempting to revert to a
    negative or nonexistent index returns 'false' and the previous active
    set of modules is retained.  A successful change return 'true'.

    """
  return _antimony.revertTo(*args)

def clearPreviousLoads():
  """
    clearPreviousLoads()

    Clears memory of all files loaded.  The next successful call to
    'load<file/string>' will return 0 as the first valid index.

    """
  return _antimony.clearPreviousLoads()

def addDirectory(*args):
  """
    addDirectory(char const * directory)

    Add a directory in which imported files may be found, and in which to
    look for a '.antimony' file (which contains rules about where to look
    locally for imported antimony and sbml files).

    """
  return _antimony.addDirectory(*args)

def clearDirectories():
  """
    clearDirectories()

    Clears the list of directories added with the 'addDirectory'
    function.

    """
  return _antimony.clearDirectories()

def writeAntimonyFile(*args):
  """
    writeAntimonyFile(char const * filename, char const * moduleName, bool enableAnnotations=True) -> int
    writeAntimonyFile(char const * filename, char const * moduleName) -> int

    Writes out an antimony-formatted file containing the given module.
    If no module name is given, all modules in the current set are
    returned.  If the module depends on any sub-modules, those modules
    are written out as well, also in the antimony format.  Returns 0 on
    failure (and sets an error), 1 on success.

    """
  return _antimony.writeAntimonyFile(*args)

def getAntimonyString(*args):
  """
    getAntimonyString(char const * moduleName, bool enableAnnotations=True) -> char
    getAntimonyString(char const * moduleName) -> char *

    Returns the same output as writeAntimonyFile, but to a char array
    instead of to a file.  Returns None on failure, and sets an error.

    """
  return _antimony.getAntimonyString(*args)

def writeSBMLFile(*args):
  """
    writeSBMLFile(char const * filename, char const * moduleName) -> int

    Writes out a SBML-formatted XML file to the file indicated.  The
    output is 'flattened', that is, all components of sub-modules are re-
    named and placed in a single model.  Returns the output of libSBML's
    'writeSBML', which 'Returns non-zero on success and zero if the
    filename could not be opened for writing.'  An error indicating this
    is set on returning zero.  NOTE:  This function is unavailable when
    libAntimony is compiled with the '-NSBML' flag.

    ee also getSBMLString.

    """
  return _antimony.writeSBMLFile(*args)

def getSBMLString(*args):
  """
    getSBMLString(char const * moduleName) -> char *

    Returns the same output as writeSBMLFile, but to a char array instead
    of to a file.  The output is 'flattened', that is, all components of
    sub-modules are re-named and placed in a single model.  Returns the
    output of libSBML's 'writeSBMLToString', which 'Returns the string on
    success and None if one of the underlying parser components fail
    (rare).'  NOTE:  This function is unavailable when libAntimony is
    compiled with the '-NSBML' flag.

    ee also writeSBMLFile.

    """
  return _antimony.getSBMLString(*args)

def setWriteSBMLTimestamp(*args):
  """
    setWriteSBMLTimestamp(bool writeTimestamp)

    Sets whether, when writing an SBML file, the timestamp is included.

    ee also getSBMLString.

    """
  return _antimony.setWriteSBMLTimestamp(*args)

def writeCompSBMLFile(*args):
  """
    writeCompSBMLFile(char const * filename, char const * moduleName) -> int

    Writes out a SBML-formatted XML file to the file indicated, using the
    'Hierarchichal Model Composition' package.  This retains Antimony's
    modularity in the SBML format.  Returns the output of libSBML's
    'writeSBML', which 'Returns non-zero on success and zero if the
    filename could not be opened for writing.'  An error indicating this
    is set on returning zero.  NOTE:  This function is unavailable when
    libAntimony is compiled with the '-NSBML' flag, or if compiled
    without the USE_COMP flag.

    ee also getSBMLString.

    """
  return _antimony.writeCompSBMLFile(*args)

def getCompSBMLString(*args):
  """
    getCompSBMLString(char const * moduleName) -> char *

    Returns the same output as writeSBMLFile, but to a char array instead
    of to a file, using the 'Hierarchichal Model Composition' package.
    This retains Antimony's modularity in the SBML format.  Returns the
    output of libSBML's 'writeSBMLToString', which 'Returns the string on
    success and None if one of the underlying parser components fail
    (rare).'  NOTE:  This function is unavailable when libAntimony is
    compiled with the '-NSBML' flag, or if compiled without the USE_COMP
    flag.

    ee also writeSBMLFile.

    """
  return _antimony.getCompSBMLString(*args)

def writeCellMLFile(*args):
  """
    writeCellMLFile(char const * filename, char const * moduleName) -> int

    Writes out a CellML-formatted XML file to the file indicated,
    retaining the same Antimony hierarchy using the CellML 'component'
    hieararchy.  Returns one on success and zero on failure.  NOTE:  This
    function is unavailable when libAntimony is compiled with the
    '-NCELLML' flag.

    ee also getCellMLString.

    """
  return _antimony.writeCellMLFile(*args)

def getCellMLString(*args):
  """
    getCellMLString(char const * moduleName) -> char *

    Returns the same output as writeCellMLFile, but to a char array
    instead of to a file.  Returns the string on success (as translated
    to 'char' from CellML's native 'wchar') and None on failure.'  NOTE:
    This function is unavailable when libAntimony is compiled with the
    '-NCELLML' flag.

    ee also writeCellMLToString.

    """
  return _antimony.getCellMLString(*args)

def printAllDataFor(*args):
  """
    printAllDataFor(char const * moduleName) -> char *

    An example function that will print to stdout all the information in
    the given module.  This function probably isn't as useful to call as
    it is to examine and copy for your own purposes:  it only calls
    functions defined here in antimony_api.h.

    """
  return _antimony.printAllDataFor(*args)

def checkModule(*args):
  """
    checkModule(char const * moduleName) -> bool

    Returns 'true' if the submitted module name exists in the current
    active set, 'false' if not.

    """
  return _antimony.checkModule(*args)

def getLastError():
  """
    getLastError() -> char *

    When any function returns an error condition, a longer description of
    the problem is stored in memory, and is obtainable with this
    function.  In most cases, this means that a call that returns a
    pointer returned 'None' (or 0).

    """
  return _antimony.getLastError()

def getWarnings():
  """
    getWarnings() -> char *

    When translating some other format to Antimony, elements that are
    unable to be translated are saved as warnings, retrievable with this
    function (returns None if no warnings present).  Warnings may also be
    generated by problems discovered in '.antimony' files.

    """
  return _antimony.getWarnings()

def getSBMLInfoMessages(*args):
  """
    getSBMLInfoMessages(char const * moduleName) -> char *

    Returns the 'info' messages from libSBML. libAntimony always
    translates its modules into SBML to check for errors.  If SBML finds
    errors, libAntimony gives up, passes on the error message, and does
    not save the model.  However, libSBML may discover other things about
    your model it wants to tell you about, in 'info' and 'warning'
    messages.  Info messages are just things it found it thinks you might
    want to know; warning messages are things it found which it feels
    violates 'best practices' in biological modelling, but not to the
    extent that it feels you did something actually wrong.  Since
    Antimony is unitless, for example, you will always find warnings
    about how you didn't set any units.  This function returns the 'info'
    messages from libSBML.  If there are no info messages, returns an
    empty string.  NOTE:  This function is unavailable when libAntimony
    is compiled with the '-NSBML' flag.  See also getSBMLWarnings.

    """
  return _antimony.getSBMLInfoMessages(*args)

def getSBMLWarnings(*args):
  """
    getSBMLWarnings(char const * moduleName) -> char *

    Returns the 'warning' messages from libSBML.  If there are no warning
    messages (an unlikely occurrence), returns an empty string.  NOTE:
    This function is unavailable when libAntimony is compiled with the
    '-NSBML' flag.  See also getSBMLInfoMessages.

    """
  return _antimony.getSBMLWarnings(*args)

def getNumModules():
  """
    getNumModules() -> unsigned long

    Returns the number of modules in the current active set (the last
    file successfully loaded, or whichever file was returned to with
    'revertTo').

    """
  return _antimony.getNumModules()

def getNthModuleName(*args):
  """
    getNthModuleName(unsigned long n) -> char *

    Returns the nth module name.  Returns None and sets an error if there
    is no such module n.

    """
  return _antimony.getNthModuleName(*args)

def getMainModuleName():
  """
    getMainModuleName() -> char *

    Returns the 'main' module name.  In Antimony, this is either the
    module marked by an asterisk ('modelmainModel()')  or the last module
    defined in the file.  In translated SBML models, this is the model
    child of thelt;sbmlgt; object.  In translated CellML models, this is
    the 'containing' model that the translator creates to hold all the
    CellML components.  Returns None only if there are no modules at all.

    """
  return _antimony.getMainModuleName()

def getNumSymbolsInInterfaceOf(*args):
  """
    getNumSymbolsInInterfaceOf(char const * moduleName) -> unsigned long

    Returns the number of symbols defined to be in the interface of the
    given module.  In other words, if a module is defined 'module M(x, y,
    z)', this returns '3'.  (Modules with no interface symbols return
    '0'.)

    """
  return _antimony.getNumSymbolsInInterfaceOf(*args)

def getNthSymbolNameInInterfaceOf(*args):
  """
    getNthSymbolNameInInterfaceOf(char const * moduleName, unsigned long n) -> char *

    Returns the Nth symbol name defined to be in the interface of the
    given module.  If a module is defined 'module M(x, y, z)', calling
    this with n=0 returns 'x'.  If no such symbol is found, None is
    returned and an error is set.

    """
  return _antimony.getNthSymbolNameInInterfaceOf(*args)

def getNumReplacedSymbolNames(*args):
  """
    getNumReplacedSymbolNames(char const * moduleName) -> unsigned long

    Returns the Nth replacement symbol name of a symbol that has replaced
    a different symbol in the given module, through the use of an 'is'
    construct, or through the use of a module's interface.  See also
    getNthFormerSymbolName, getNthReplacementSymbolName.

    """
  return _antimony.getNumReplacedSymbolNames(*args)

def getNthFormerSymbolName(*args):
  """
    getNthFormerSymbolName(char const * moduleName, unsigned long n) -> char *

    Returns the Nth symbol name that has been replaced by a new symbol
    name in the given module, through the use of an 'is' construct, or
    through the use of a module's interface.  See also
    getNthReplacementSymbolName, GetNumReplacedSymbolNames.

    """
  return _antimony.getNthFormerSymbolName(*args)

def getNthReplacementSymbolName(*args):
  """
    getNthReplacementSymbolName(char const * moduleName, unsigned long n) -> char *

    Returns the Nth replacement symbol name of a symbol that has replaced
    a different symbol in the given module, through the use of an 'is'
    construct, or through the use of a module's interface.  See also
    getNthFormerSymbolName, GetNumReplacedSymbolNames.

    """
  return _antimony.getNthReplacementSymbolName(*args)

def getNumReplacedSymbolNamesBetween(*args):
  """
    getNumReplacedSymbolNamesBetween(char const * moduleName, char const * formerSubmodName, char const * replacementSubmodName) -> unsigned long

    Returns the Nth replacement symbol name of a symbol that has replaced
    a different symbol in the given module, through the use of an 'is'
    construct, or through the use of a module's interface, between the
    given submodules, with the variable in the first submodule being the
    former variable name, and the variable in the second being the
    replacement variable name.  If an empty string is used as one of the
    submodule names, those synchronized variables that are not part of
    any submodule are searched for.  See also getNthFormerSymbolName,
    getNthReplacementSymbolName.

    """
  return _antimony.getNumReplacedSymbolNamesBetween(*args)

def getNthFormerSymbolNameBetween(*args):
  """
    getNthFormerSymbolNameBetween(char const * moduleName, char const * formerSubmodName, char const * replacementSubmodName, 
        unsigned long n) -> char *

    Returns the Nth symbol name that has been replaced by a new symbol
    name in the given module, through the use of an 'is' construct, or
    through the use of a module's interface, between the given
    submodules, with the variable in the first submodule being the former
    variable name, and the variable in the second being the replacement
    variable name.  See also getNthReplacementSymbolName,
    GetNumReplacedSymbolNames.

    """
  return _antimony.getNthFormerSymbolNameBetween(*args)

def getNthReplacementSymbolNameBetween(*args):
  """
    getNthReplacementSymbolNameBetween(char const * moduleName, char const * formerSubmodName, char const * replacementSubmodName, 
        unsigned long n) -> char *

    Returns the Nth replacement symbol name of a symbol that has replaced
    a different symbol in the given module, through the use of an 'is'
    construct, or through the use of a module's interface, between the
    given submodules, with the variable in the first submodule being the
    former variable name, and the variable in the second being the
    replacement variable name.  See also getNthFormerSymbolName,
    GetNumReplacedSymbolNames.

    """
  return _antimony.getNthReplacementSymbolNameBetween(*args)

def getNumSymbolsOfType(*args):
  """
    getNumSymbolsOfType(char const * moduleName, return_type rtype) -> unsigned long

    Returns the number of symbols of the given return type.  Useful when
    looping over the arrays in the subsequent functions.  See also get().

    """
  return _antimony.getNumSymbolsOfType(*args)

def getNthSymbolNameOfType(*args):
  """
    getNthSymbolNameOfType(char const * moduleName, return_type rtype, unsigned long n) -> char *

    Returns the name of the Nth symbol of the given type.  If no such
    symbol exists, None is returned and an error is set.  (In SBML, this
    is the 'id' of the element.)

    """
  return _antimony.getNthSymbolNameOfType(*args)

def getNthSymbolDisplayNameOfType(*args):
  """
    getNthSymbolDisplayNameOfType(char const * moduleName, return_type rtype, unsigned long n) -> char *

    Returns the 'display name' of the Nth symbol of the given type.  If
    no such symbol exists, None is returned and an error is set.  (In
    SBML, this is the 'name' of the element.)

    """
  return _antimony.getNthSymbolDisplayNameOfType(*args)

def getNthSymbolEquationOfType(*args):
  """
    getNthSymbolEquationOfType(char const * moduleName, return_type rtype, unsigned long n) -> char *

    Returns the equation associated with the Nth symbol of the given
    type.  If no equation is set for the symbol in question, an empty
    string is returned.  If no symbol can be found, None is returned and
    an error is set.

    """
  return _antimony.getNthSymbolEquationOfType(*args)

def getNthSymbolInitialAssignmentOfType(*args):
  """
    getNthSymbolInitialAssignmentOfType(char const * moduleName, return_type rtype, unsigned long n) -> char *

    Returns the initial assignment associated with the Nth symbol of the
    given type.  If no initial assignment is set for the symbol in
    question, an empty string is returned.  If no symbol can be found,
    None is returned and an error is set.

    """
  return _antimony.getNthSymbolInitialAssignmentOfType(*args)

def getNthSymbolAssignmentRuleOfType(*args):
  """
    getNthSymbolAssignmentRuleOfType(char const * moduleName, return_type rtype, unsigned long n) -> char *

    Returns the assignment rule associated with the Nth symbol of the
    given type.  If no assignment rule is set for the symbol in question,
    an empty string is returned.  If no symbol can be found, None is
    returned and an error is set.

    """
  return _antimony.getNthSymbolAssignmentRuleOfType(*args)

def getNthSymbolRateRuleOfType(*args):
  """
    getNthSymbolRateRuleOfType(char const * moduleName, return_type rtype, unsigned long n) -> char *

    Returns the rate rule associated with the Nth symbol of the given
    type.  If no rate rule is set for the symbol in question, an empty
    string is returned.  If no symbol can be found, None is returned and
    an error is set.

    """
  return _antimony.getNthSymbolRateRuleOfType(*args)

def getNthSymbolCompartmentOfType(*args):
  """
    getNthSymbolCompartmentOfType(char const * moduleName, return_type rtype, unsigned long n) -> char *

    Returns the name of the compartment associated with the nth symbol of
    the given type.  If no compartment is explicitly set in the file, the
    string 'default_compartment' is returned.  If no symbol can be found,
    None is returned and an error is set.

    """
  return _antimony.getNthSymbolCompartmentOfType(*args)

def getTypeOfSymbol(*args):
  """
    getTypeOfSymbol(char const * moduleName, char const * symbolName) -> return_type

    Returns the most specific return type available for the given
    symbolName.  A symbol defined to be a gene, for example, will return
    'allGenes' and not 'allReactions', though the symbol does indeed
    qualify as a reaction.

    """
  return _antimony.getTypeOfSymbol(*args)

def getTypeOfEquationForSymbol(*args):
  """
    getTypeOfEquationForSymbol(char const * moduleName, char const * symbolName) -> formula_type

    Returns the type of the 'main' equation associated with the given
    symbolName.  All reactions will return 'formulaKINETIC', and all
    events will return 'formulaTRIGGER'.  All DNA elements that are not
    genes will return 'formulaASSIGNMENT', as DNA elements are defined by
    assignment rules and kinetic laws.  All other symbols will return
    'formulaINITIAL' by default (i.e. in the case where no equation at
    all is associated with the symbol in question), and otherwise will
    return formulaINITIAL for symbols defined by initial assignments
    only, formulaASSIGNMENT for symbols defined by assignment rules, and
    formulaRATE for symbols defined by both initial assignments and rate
    rules (or just rate rules; it is valid though not simulatable to have
    a symbol with a rate rule but no initial assignment).  In the case of
    rate rules, the initial assignment is found in the 'Equation'
    associated with the symbol, and the rate rule is found in the
    'RateRule' associated with the symbol.

    """
  return _antimony.getTypeOfEquationForSymbol(*args)

def getCompartmentForSymbol(*args):
  """
    getCompartmentForSymbol(char const * moduleName, char const * symbolName) -> char *

    Returns the name of the compartment the given symbol is a member of.
    In antimony, all symbols may have compartments, not just species.  If
    a symbol has no set compartment, and is not a member of a symbol with
    a set compartment, this will return 'default_compartment'

    """
  return _antimony.getCompartmentForSymbol(*args)

def getNumReactions(*args):
  """
    getNumReactions(char const * moduleName) -> unsigned long

    Returns the number of reactions (including genes) in the named
    module.  Useful when looping over all reactions in the arrays
    returned by subsequent functions.

    """
  return _antimony.getNumReactions(*args)

def getNumReactants(*args):
  """
    getNumReactants(char const * moduleName, unsigned long rxn) -> unsigned long

    Returns the number of reactants (species on the left side of the
    reaction) for the given reaction.  If no such reaction is present,
    '0' is returned and an error is set.  Sadly, if there are no
    reactants, '0' is also returned, though no error is set.  So you'll
    have to keep track of this one on your own, most likely.

    """
  return _antimony.getNumReactants(*args)

def getNumProducts(*args):
  """
    getNumProducts(char const * moduleName, unsigned long rxn) -> unsigned long

    Returns the number of products (species on the right side of the
    reaction) for the given reaction.  If no such reaction is present,
    '0' is returned and an error is set.  Sadly, if there are no
    products, '0' is also returned, though no error is set.  So you'll
    have to keep track of this one on your own, too.

    """
  return _antimony.getNumProducts(*args)

def getNthReactionMthReactantName(*args):
  """
    getNthReactionMthReactantName(char const * modulename, unsigned long rxn, unsigned long reactant) -> char *

    Returns the mth reactant name of the mth reaction.  If no such
    reaction is present, None is returned and an error is set.

    """
  return _antimony.getNthReactionMthReactantName(*args)

def getNthReactionMthProductName(*args):
  """
    getNthReactionMthProductName(char const * modulename, unsigned long rxn, unsigned long product) -> char *

    Returns the mth product name of the given reaction.  If no such
    reaction or product is present, None is returned and an error is set.

    """
  return _antimony.getNthReactionMthProductName(*args)

def getNthReactionReactantStoichiometries(*args):
  """
    getNthReactionReactantStoichiometries(char const * moduleName, unsigned long rxn) -> double *

    Returns an array of the stoichiometries for the reactants of the Nth
    reaction in the module.  If no such reaction exists, an error is set
    and None is returned.

    """
  return _antimony.getNthReactionReactantStoichiometries(*args)

def getNthReactionProductStoichiometries(*args):
  """
    getNthReactionProductStoichiometries(char const * moduleName, unsigned long rxn) -> double *

    Returns an array of the stoichiometries for the products of the Nth
    reaction in the module.  If no such reaction exists, an error is set
    and None is returned.

    """
  return _antimony.getNthReactionProductStoichiometries(*args)

def getNthReactionMthReactantStoichiometries(*args):
  """
    getNthReactionMthReactantStoichiometries(char const * moduleName, unsigned long rxn, unsigned long reactant) -> double

    Returns the stoichiometry for the Mth reactant of the Nth reaction in
    the module.  If no such reactant or reaction exists, an error is set
    and 0 is returned.

    """
  return _antimony.getNthReactionMthReactantStoichiometries(*args)

def getNthReactionMthProductStoichiometries(*args):
  """
    getNthReactionMthProductStoichiometries(char const * moduleName, unsigned long rxn, unsigned long product) -> double

    Returns the stoichiometries for the Mth product of the Nth reaction
    in the module.  If no such product or reaction exists, an error is
    set and 0 is returned.

    """
  return _antimony.getNthReactionMthProductStoichiometries(*args)

def getNumInteractions(*args):
  """
    getNumInteractions(char const * moduleName) -> unsigned long

    Returns the number of interactions in the named module.  Useful when
    looping over all interactions in the arrays returned by subsequent
    functions.

    """
  return _antimony.getNumInteractions(*args)

def getNumInteractors(*args):
  """
    getNumInteractors(char const * moduleName, unsigned long rxn) -> unsigned long

    Returns the number of interactors (species on the left side of the
    interaction) for the given interaction.  If no such interaction is
    present, '0' is returned and an error is set.  Sadly, if there are no
    interactors, '0' is also returned, though no error is set.  So you'll
    have to keep track of this one on your own, most likely.

    """
  return _antimony.getNumInteractors(*args)

def getNumInteractees(*args):
  """
    getNumInteractees(char const * moduleName, unsigned long rxn) -> unsigned long

    Returns the number of interactees (reactions on the right side of the
    interaction) for the given interaction.  If no such interaction is
    present, '0' is returned and an error is set.  Sadly, if there are no
    interactees, '0' is also returned, though no error is set.  So you'll
    have to keep track of this one on your own, too.

    """
  return _antimony.getNumInteractees(*args)

def getNthInteractionMthInteractorName(*args):
  """
    getNthInteractionMthInteractorName(char const * modulename, unsigned long interaction, unsigned long interactor) -> char *

    Returns the Mth interactor names for the given interaction.  If no
    such interactor or interaction is present, None is returned and an
    error is set.

    """
  return _antimony.getNthInteractionMthInteractorName(*args)

def getNthInteractionMthInteracteeName(*args):
  """
    getNthInteractionMthInteracteeName(char const * modulename, unsigned long interaction, unsigned long interactee) -> char *

    Returns the Mth interactee name for the given interaction.  If no
    such interactee or interaction is present, None is returned and an
    error is set.

    """
  return _antimony.getNthInteractionMthInteracteeName(*args)

def getNthInteractionDivider(*args):
  """
    getNthInteractionDivider(char const * moduleName, unsigned long n) -> rd_type

    Returns the Nth interaction divider in the module.  If no such
    interaction is present, 0 is returned, which is 'rdBecomes, which is
    an invalid Interaction divider (since it's used for reactions
    instead).

    """
  return _antimony.getNthInteractionDivider(*args)

def getStoichiometryMatrixNumRows(*args):
  """
    getStoichiometryMatrixNumRows(char const * moduleName) -> unsigned long

    The number of rows in the stoichiometry matrix (or, the number of
    'varSpecies').

    """
  return _antimony.getStoichiometryMatrixNumRows(*args)

def getStoichiometryMatrixNumColumns(*args):
  """
    getStoichiometryMatrixNumColumns(char const * moduleName) -> unsigned long

    The number of columns in the stoichiometry matrix (or, the number of
    'allReactions').

    """
  return _antimony.getStoichiometryMatrixNumColumns(*args)

def getNumReactionRates(*args):
  """
    getNumReactionRates(char const * moduleName) -> unsigned long

    Returns the number of reactions (and hence reaction rates) in the
    module.  Useful for looping over all reaction rates in the following
    function.

    """
  return _antimony.getNumReactionRates(*args)

def getNthReactionRate(*args):
  """
    getNthReactionRate(char const * moduleName, unsigned long rxn) -> char *

    Returns the reaction rate for the Nth reaction in the module.  If the
    reaction exists, but its reaction rate has not been set, returns an
    empty string.  If the reaction does not exist, an error is set, and
    None is returned.

    """
  return _antimony.getNthReactionRate(*args)

def getNumEvents(*args):
  """
    getNumEvents(char const * moduleName) -> unsigned long

    Returns the number of events in the given module.  Useful for
    subsequent functions that return arrays of information for all
    events.

    """
  return _antimony.getNumEvents(*args)

def getNthEventName(*args):
  """
    getNthEventName(char const * moduleName, unsigned long event) -> char *

    Returns the name of the nth event in the module.

    """
  return _antimony.getNthEventName(*args)

def getNumAssignmentsForEvent(*args):
  """
    getNumAssignmentsForEvent(char const * moduleName, unsigned long event) -> unsigned long

    Returns the number of assignments stored in the given event.  Useful
    when looping through those assignements in functions below.

    """
  return _antimony.getNumAssignmentsForEvent(*args)

def getTriggerForEvent(*args):
  """
    getTriggerForEvent(char const * moduleName, unsigned long event) -> char *

    Returns the trigger for the given event, as an equation that can be
    interpreted in a boolean context.

    """
  return _antimony.getTriggerForEvent(*args)

def getDelayForEvent(*args):
  """
    getDelayForEvent(char const * moduleName, unsigned long event) -> char *

    Returns the delay for the given event, as an equation (if present; if
    the event has no delay, '' is returned.  If no such module or event
    is present, None is returned and an error is set.).

    """
  return _antimony.getDelayForEvent(*args)

def getEventHasDelay(*args):
  """
    getEventHasDelay(char const * moduleName, unsigned long event) -> bool

    Returns 'true' if the given event has a delay; 'false' otherwise.

    """
  return _antimony.getEventHasDelay(*args)

def getPriorityForEvent(*args):
  """
    getPriorityForEvent(char const * moduleName, unsigned long event) -> char *

    Returns the priority for the given event, as an equation (if present;
    if the event has no priority, '' is returned.  If no such module or
    event is present, None is returned and an error is set.).

    """
  return _antimony.getPriorityForEvent(*args)

def getEventHasPriority(*args):
  """
    getEventHasPriority(char const * moduleName, unsigned long event) -> bool

    Returns 'true' if the given event has a priority; 'false' otherwise.

    """
  return _antimony.getEventHasPriority(*args)

def getPersistenceForEvent(*args):
  """
    getPersistenceForEvent(char const * moduleName, unsigned long event) -> bool

    Returns the value of the persistence flag for the given event
    (default is 'false').  Unable to return an error if there is no such
    event or module, so will simply return 'false' in those situations,
    as well.

    """
  return _antimony.getPersistenceForEvent(*args)

def getT0ForEvent(*args):
  """
    getT0ForEvent(char const * moduleName, unsigned long event) -> bool

    Returns the value at time 0 for the given event trigger (default is
    'true').  Unable to return an error if there is no such event or
    module, so will simply return 'true' in those situations, as well.

    """
  return _antimony.getT0ForEvent(*args)

def getFromTriggerForEvent(*args):
  """
    getFromTriggerForEvent(char const * moduleName, unsigned long event) -> bool

    Returns the value of the 'fromTrigger' flag for the given event
    trigger (default is 'true').  Unable to return an error if there is
    no such event or module, so will simply return 'true' in those
    situations, as well.

    """
  return _antimony.getFromTriggerForEvent(*args)

def getNthAssignmentVariableForEvent(*args):
  """
    getNthAssignmentVariableForEvent(char const * moduleName, unsigned long event, unsigned long n) -> char *

    Each assignment for an event assigns a formula to a variable.  This
    function returns the variable in question for the given event and
    assignment.

    """
  return _antimony.getNthAssignmentVariableForEvent(*args)

def getNthAssignmentEquationForEvent(*args):
  """
    getNthAssignmentEquationForEvent(char const * moduleName, unsigned long event, unsigned long n) -> char *

    Each assignment for an event assigns a formula to a variable.  This
    function returns the in question in question for the given event and
    assignment.

    """
  return _antimony.getNthAssignmentEquationForEvent(*args)

def getNumDNAStrands(*args):
  """
    getNumDNAStrands(char const * moduleName) -> unsigned long

    Returns the number of unique DNA strands in the module, as defined in
    the Antimony documentation (or, the number of physical cassettes of
    DNA present in the module).  Useful in looping over the arrays
    returned by functions below.

    """
  return _antimony.getNumDNAStrands(*args)

def getSizeOfNthDNAStrand(*args):
  """
    getSizeOfNthDNAStrand(char const * moduleName, unsigned long n) -> unsigned long

    Returns just the size (in number of components) of the nth DNA strand
    in the given module.  If no such strand exists, sets an error and
    returns 0.  This is actually useful here, since all DNA strands
    otherwise have a size of at least 1.

    """
  return _antimony.getSizeOfNthDNAStrand(*args)

def getIsNthDNAStrandOpen(*args):
  """
    getIsNthDNAStrandOpen(char const * moduleName, unsigned long n, bool upstream) -> bool

    Returns whether the given DNA strand was defined to be 'open' (that
    is, have an attachable end) at the upstream end (if 'upstream' is
    true) or at the downstream end (if 'upstream' is false).  This allows
    reproduction of a strand defined by '--X--Y--' vs. 'X--Y', etc.

    """
  return _antimony.getIsNthDNAStrandOpen(*args)

def getNumModularDNAStrands(*args):
  """
    getNumModularDNAStrands(char const * moduleName) -> unsigned long

    Returns the sizes (in number of components) of all modular
    (separately-defined) DNA strands.  Modular strands may contain genes,
    operators, and other DNA strands.  Useful for looping over the
    strands in the array returned by getModularDNAStrands.

    """
  return _antimony.getNumModularDNAStrands(*args)

def getIsNthModularDNAStrandOpen(*args):
  """
    getIsNthModularDNAStrandOpen(char const * moduleName, unsigned long n, bool upstream) -> bool

    Returns whether the given modular DNA strand was defined to be 'open'
    (that is, have an attachable end) at the upstream end (if 'upstream'
    is true) or at the downstream end (if 'upstream' is false).  This
    allows reproduction of a strand defined by '--X--Y--' vs. 'X--Y',
    etc.

    """
  return _antimony.getIsNthModularDNAStrandOpen(*args)

def addDefaultInitialValues(*args):
  """
    addDefaultInitialValues(char const * moduleName) -> bool

    Adds default initial values to the named module.  By default, you
    must provide initial values to all the values in your model.  If you
    call this function, all parameters and compartments will be given a
    default value of '1', and all your species and reaction rates will be
    given a default value of '0'.

    Returns 'true' if no such moduleName exists, 'false' otherwise.

    """
  return _antimony.addDefaultInitialValues(*args)

def setBareNumbersAreDimensionless(*args):
  """
    setBareNumbersAreDimensionless(bool dimensionless)

    Sets whether bare numbers are dimensionless or undefined.  By
    default, all numbers in mathematical equations do not have units
    unless they are explicitly declared ('1 second' vs. '1').  If this
    function is called with a value of 'true', all numbers without
    declared units will be assumed to have the units 'dimensionless'.  If
    called with a value of 'false', the numbers will not have declared
    units (the default).  This only affects MathML formulas in SBML; it
    does not set the 'units' attribute of any parameter or other SBML
    element.

    """
  return _antimony.setBareNumbersAreDimensionless(*args)

def getModuleNames():
  """
    getModuleNames() -> StringVector

    Returns an array of all the current module names.

    """
  return _antimony.getModuleNames()

def getSymbolNamesInInterfaceOf(*args):
  """
    getSymbolNamesInInterfaceOf(char const * moduleName) -> StringVector

    Returns the names of the symbols defined to be in the interface of
    the given module.  In other words, if a module is defined 'module
    M(x, y, z)', this returns the list 'x, y, z'.  A module with no
    symbols defined in its interface would return a pointer to an empty
    string.

    """
  return _antimony.getSymbolNamesInInterfaceOf(*args)

def getAllReplacementSymbolPairs(*args):
  """
    getAllReplacementSymbolPairs(char const * moduleName) -> StringVectorVector

    Returns a list of pairs of symbol names that have been synchronized
    with each other--the first the symbol that was replaced, and the
    second the symbol used as the replacement.  These replacements are
    created when 'is' is used, and when a module's 'interface' (the
    symbols listed in parentheses) is used.  See also
    getNthFormerSymbolName, getNthReplacementSymbolName,
    getNthReplacementSymbolPair.

    """
  return _antimony.getAllReplacementSymbolPairs(*args)

def getNthReplacementSymbolPair(*args):
  """
    getNthReplacementSymbolPair(char const * moduleName, unsigned long n) -> StringVector

    Returns the Nth pair of symbol names that have been synchronized with
    each other--the first the symbol that was replaced, and the second
    the symbol used as the replacement.  These replacements are created
    when 'is' is used, and when a module's 'interface' (the symbols
    listed in parentheses) is used.  See also getNthFormerSymbolName,
    getNthReplacementSymbolName.

    """
  return _antimony.getNthReplacementSymbolPair(*args)

def getAllReplacementSymbolPairsBetween(*args):
  """
    getAllReplacementSymbolPairsBetween(char const * moduleName, char const * formerSubmodName, char const * replacementSubmodName, 
        unsigned long n) -> StringVectorVector

    Returns a list of pairs of symbol names that have been synchronized
    with each other--the first the symbol that was replaced, and the
    second the symbol used as the replacement, between the given
    submodules, with the variable in the first submodule being the former
    variable name, and the variable in the second being the replacement
    variable name.  These replacements are created when 'is' is used, and
    when a module's 'interface' (the symbols listed in parentheses) is
    used.  See also getNthFormerSymbolName, getNthReplacementSymbolName,
    getNthReplacementSymbolPair.

    """
  return _antimony.getAllReplacementSymbolPairsBetween(*args)

def getNthReplacementSymbolPairBetween(*args):
  """
    getNthReplacementSymbolPairBetween(char const * moduleName, char const * formerSubmodName, char const * replacementSubmodName, 
        unsigned long n) -> StringVector

    Returns the Nth pair of symbol names that have been synchronized with
    each other--the first the symbol that was replaced, and the second
    the symbol used as the replacement, between the given submodules,
    with the variable in the first submodule being the former variable
    name, and the variable in the second being the replacement variable
    name.  These replacements are created when 'is' is used, and when a
    module's 'interface' (the symbols listed in parentheses) is used.
    See also getNthFormerSymbolName, getNthReplacementSymbolName.

    """
  return _antimony.getNthReplacementSymbolPairBetween(*args)

def getSymbolNamesOfType(*args):
  """
    getSymbolNamesOfType(char const * moduleName, return_type rtype) -> StringVector

    Returns the names of the symbols of the given return type.  (In SBML,
    these are the 'id's.)

    """
  return _antimony.getSymbolNamesOfType(*args)

def getSymbolDisplayNamesOfType(*args):
  """
    getSymbolDisplayNamesOfType(char const * moduleName, return_type rtype) -> StringVector

    Returns the 'display names' of the symbols of the given return type.
    (In SBML, these are the 'name's.)

    """
  return _antimony.getSymbolDisplayNamesOfType(*args)

def getSymbolEquationsOfType(*args):
  """
    getSymbolEquationsOfType(char const * moduleName, return_type rtype) -> StringVector

    Returns the equations associated with the symbols of the given return
    type.  - Species:                 The initial assignment or
    assignment rule for the species in question  - Formulas and
    operators:  The initial assignment or assignment rule for the formula
    in question  - Compartments:            The initial assignment or
    assignment rule for the compartment in question  - DNA elements:
    The assignment rule or reaction rate of the element in question (no
    DNA element is defined by an initial assignment or by a rate rule
    with an initial assignment)  - DNA Strands:             The
    assignment rule or reaction rate for the last element of the strand
    - Reactions and genes:     The reaction rate  - Events:
    The trigger condition  - Interactions:            Nothing  - Modules:
    Nothing

    For elements that could have either initial assignments or assignment
    rules, use getTypeOfEquationForSymbol, or just use
    getSymbolInitialAssignmentsOfType and getSymbolAssignmentRulesOfType
    explicitly.

    """
  return _antimony.getSymbolEquationsOfType(*args)

def getSymbolInitialAssignmentsOfType(*args):
  """
    getSymbolInitialAssignmentsOfType(char const * moduleName, return_type rtype) -> StringVector

    Returns the equations associated with the initial assignment for
    symbols of the given return type.  - Species:                 The
    initial assignment for the species in question  - Formulas and
    operators:  The initial assignment of the formula in question  -
    Compartments:            The initial assignment for the compartment

    - DNA Strands:             Nothing  - Reactions and genes:
    Nothing  - Events:                  Nothing  - Interactions:
    Nothing  - Modules:                 Nothing

    """
  return _antimony.getSymbolInitialAssignmentsOfType(*args)

def getSymbolAssignmentRulesOfType(*args):
  """
    getSymbolAssignmentRulesOfType(char const * moduleName, return_type rtype) -> StringVector

    Returns the equations associated with the assignment rule for symbols
    of the given return type.  - Species:                 The assignment
    rule for the species in question  - Formulas and operators:  The
    assignment rule of the formula in question  - Compartments:
    The assignment rule for the compartment  - DNA Strands:
    The assignment rule or reaction rate at the end of the strand.  -
    Reactions and genes:     The reaction rate (for consistency with DNA
    strands)

    - Events:                  Nothing  - Interactions:
    Nothing  - Modules:                 Nothing

    """
  return _antimony.getSymbolAssignmentRulesOfType(*args)

def getSymbolRateRulesOfType(*args):
  """
    getSymbolRateRulesOfType(char const * moduleName, return_type rtype) -> StringVector

    Returns the equations associated with the rate rule for symbols of
    the given return type.  - Species:                 The rate rule for
    the species in question  - Formulas and operators:  The rate rule of
    the formula in question  - Compartments:            The rate rule for
    the compartment  - DNA Strands:             The rate rule or reaction
    rate at the end of the strand.  - Reactions and genes:     Nothing  -
    Events:                  Nothing  - Interactions:            Nothing
    - Modules:                 Nothing

    """
  return _antimony.getSymbolRateRulesOfType(*args)

def getSymbolCompartmentsOfType(*args):
  """
    getSymbolCompartmentsOfType(char const * moduleName, return_type rtype) -> StringVector

    Returns the compartments associated with the symbols of the given
    return type.  Note that unlike in SBML, any symbol of any type may
    have an associated compartment, including compartments themselves.
    Rules about compartments in Antimony can be found in the Tutorial.pdf
    document included with this documentation.

    """
  return _antimony.getSymbolCompartmentsOfType(*args)

def getReactantNames(*args):
  """
    getReactantNames(char const * moduleName) -> StringVectorVector

    Returns all the reactant names for all reactions in the given module.
    The dimensions of the included arrays can be found with
    'getNumReactions' and 'getNumReactants' (the array is not 'square'--
    each sub array may have a different length).

    """
  return _antimony.getReactantNames(*args)

def getNthReactionReactantNames(*args):
  """
    getNthReactionReactantNames(char const * modulename, unsigned long rxn) -> StringVector

    Returns an array of all the reactant names for the given reaction.
    The length of the array can be obtained with 'getNumReactants'.  If
    no such reaction is present, None is returned and an error is set.

    """
  return _antimony.getNthReactionReactantNames(*args)

def getProductNames(*args):
  """
    getProductNames(char const * moduleName) -> StringVectorVector

    Returns all the product names for all reactions in the given module.
    The dimensions of the included arrays can be found with
    'getNumReactions' and 'getNumProducts' (the array is not 'square'--
    each sub array may have a different length).

    """
  return _antimony.getProductNames(*args)

def getNthReactionProductNames(*args):
  """
    getNthReactionProductNames(char const * modulename, unsigned long rxn) -> StringVector

    Returns an array of all the product names for the given reaction.
    The length of the array can be obtained with 'getNumProducts'.  If no
    such reaction is present, None is returned and an error is set.

    """
  return _antimony.getNthReactionProductNames(*args)

def getReactantStoichiometries(*args):
  """
    getReactantStoichiometries(char const * moduleName) -> DoubleVectorVector

    Returns a two-dimensional array of the stoichiometries for all
    reactants in all reactions in the given module.

    """
  return _antimony.getReactantStoichiometries(*args)

def getProductStoichiometries(*args):
  """
    getProductStoichiometries(char const * moduleName) -> DoubleVectorVector

    Returns a two-dimensional array of the stoichiometries for all
    products in all reactions in the given module.

    """
  return _antimony.getProductStoichiometries(*args)

def getInteractorNames(*args):
  """
    getInteractorNames(char const * moduleName) -> StringVectorVector

    Returns all the interactor names for all interactions in the given
    module.  The dimensions of the included arrays can be found with
    'getNumInteractions' and 'getNumInteractors' (the array is not
    'square'--each sub array may have a different length).

    """
  return _antimony.getInteractorNames(*args)

def getNthInteractionInteractorNames(*args):
  """
    getNthInteractionInteractorNames(char const * modulename, unsigned long rxn) -> StringVector

    Returns an array of all the interactor names for the given
    interaction.  The length of the array can be obtained with
    'getNumInteractors'.  If no such interaction is present, None is
    returned and an error is set.

    """
  return _antimony.getNthInteractionInteractorNames(*args)

def getInteracteeNames(*args):
  """
    getInteracteeNames(char const * moduleName) -> StringVectorVector

    Returns all the interactee names for all interactions in the given
    module.  The dimensions of the included arrays can be found with
    'getNumInteractions' and 'getNumInteractees' (the array is not
    'square'--each sub array may have a different length).

    """
  return _antimony.getInteracteeNames(*args)

def getNthInteractionInteracteeNames(*args):
  """
    getNthInteractionInteracteeNames(char const * modulename, unsigned long rxn) -> StringVector

    Returns an array of all the interactee names for the given
    interaction.  The length of the array can be obtained with
    'getNumInteractees'.  If no such interaction is present, None is
    returned and an error is set.

    """
  return _antimony.getNthInteractionInteracteeNames(*args)

def getStoichiometryMatrix(*args):
  """
    getStoichiometryMatrix(char const * moduleName) -> DoubleVectorVector

    Returns an N x M stoichiometry matrix where N is the number of
    reactions in the model, and M is the number of variable species (or
    'floating species').

    """
  return _antimony.getStoichiometryMatrix(*args)

def getStoichiometryMatrixRowLabels(*args):
  """
    getStoichiometryMatrixRowLabels(char const * moduleName) -> StringVector

    The row labels for the stoichiometry matrix.  Is exactly the same as
    calling 'getSymbolNamesOfType(moduleName, varSpecies)', but provided
    here so you don't have to think about it.

    """
  return _antimony.getStoichiometryMatrixRowLabels(*args)

def getStoichiometryMatrixColumnLabels(*args):
  """
    getStoichiometryMatrixColumnLabels(char const * moduleName) -> StringVector

    The column labels for the stoichiometry matrix.  Is exactly the same
    as calling 'getSymbolNamesOfType(moduleName, allReactions)' but
    provided here so you don't have to think about it.

    """
  return _antimony.getStoichiometryMatrixColumnLabels(*args)

def getReactionRates(*args):
  """
    getReactionRates(char const * moduleName) -> StringVector

    Returns an array of the reaction rates for the given module.  Is the
    same as 'getSymbolEquationsOfType(moduleName, allReactions)', but is
    provided for convenience.

    """
  return _antimony.getReactionRates(*args)

def getEventNames(*args):
  """
    getEventNames(char const * moduleName) -> StringVector

    Returns the names of the events in the module.  Is the same as
    'getSymbolNamesOfType(moduleName, allEvents)', but is provided for
    convenience.

    """
  return _antimony.getEventNames(*args)

def getDNAStrandSizes(*args):
  """
    getDNAStrandSizes(char const * moduleName) -> UnsignedLongVector

    Returns an array of DNA strand sizes for all strands in the module.
    Useful for looping over the arrays returned by 'getDNAStrands'

    """
  return _antimony.getDNAStrandSizes(*args)

def getDNAStrands(*args):
  """
    getDNAStrands(char const * moduleName) -> StringVectorVector

    Returns an array of all DNA strands in the given module as lists of
    their components.  All components are either Operator objects or Gene
    objects, depending on whether they have an associated reaction.

    """
  return _antimony.getDNAStrands(*args)

def getNthDNAStrand(*args):
  """
    getNthDNAStrand(char const * moduleName, unsigned long n) -> StringVector

    Returns an array of names of the components in the nth DNA strand in
    the given module.  If no such strand exists, sets an error and
    returns None.

    """
  return _antimony.getNthDNAStrand(*args)

def getModularDNAStrandSizes(*args):
  """
    getModularDNAStrandSizes(char const * moduleName) -> UnsignedLongVector

    Returns an array of Modular DNA strand sizes for the given module.
    Useful for looping over the components in the sub-arrays returned by
    getModularDNAStrands.

    """
  return _antimony.getModularDNAStrandSizes(*args)

def getModularDNAStrands(*args):
  """
    getModularDNAStrands(char const * moduleName) -> StringVectorVector

    Returns an array of strands, each of which has an array of the names
    of the components of that strand.  The components may be operators,
    genes, and other modular DNA strands.

    """
  return _antimony.getModularDNAStrands(*args)

def getNthModularDNAStrand(*args):
  """
    getNthModularDNAStrand(char const * moduleName, unsigned long n) -> StringVector

    Returns an array of names of the components in the nth modular DNA
    strand in the given module.  If no such strand exists, an error is
    set, and None is returned.

    """
  return _antimony.getNthModularDNAStrand(*args)
# This file is compatible with both classic and new-style classes.


