###############################################################################
# Copyright Daniel Davies (2018)                                              #
#                                                                             #
# This file is part of SMACT: oxidationstates.py is free software: you can    #
# redistribute it and/or modify it under the terms of the GNU General Public  #
# License as published by the Free Software Foundation, either version 3 of   #
# the License, or (at your option) any later version.  This program is        #
# distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;   #
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A       #
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.   #
# You should have received a copy of the GNU General Public License along     #
# with this program.  If not, see <http://www.gnu.org/licenses/>.             #
#                                                                             #
###############################################################################

###############################################################################
# Collection of functions for the statistical analysis of oxidation states.   #
# It is possible to use the values obtained in the publication "Materials     #
# Discovery by Chemical Analogy: Role of Oxidation States in Structure        #
# Prediction" - DOI: 10.1039/C8FD00032H                                       #
# or to create a new probabilistic model using your own database of materials #
# and the functions in this module.                                           #
# NB:                                                                         #
# This module currently depends on Pymatgen, although this is not currently a #
# dependency of SMACT. See http://pymatgen.org/.                              #
###############################################################################

###  Imports
# General
from tqdm import tqdm
import os
import csv

# Maths and plotting
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

# pymatgen
from pymatgen import Structure, Specie
from smact import Element, data_directory
from smact.informatics import species_totals, get_unique_species

def generate_scores(structures=[], anions=[],
                    spec_list=[], anion_count_dict={}, spec_totals={},
                    scoring='spec_fraction'):
    """ Produces various scores based on info about a set of oxidation state-decorated
    structures. Can either be provided:
    1. A list of Species of interest,
    a dictionary of the occurrence of each species with each anion as the most electronegative,
    a dictionary of the total occurence of species in the same dataset.
    2. A list of dicts containing Pymatgen Structure objects,
    a list of anions of interest.
    Option 1. is faster and allows more flexibility. All necessary dicts can be produced
        using smact.informatics. Option 2. is easier but slower.
    Args:
        structures (list): Dicts containing pymatgen Structures.
        anions (list): Pymatgen.Species anions of interestself.
        spec_list (list): Pymatgen species we are interested in
            e.g. [Specie Li+, Specie Na+, Specie Mg2+...].
        anion_count_dict (dict): Occurrence of each species with each anion as the most
        electronegiative element present (as generated by species_totals_for_anion)
            e.g. {Specie:F-: {Specie Rb+: 164, Specie K+...}...}.
        spec_totals (dict): Total number of compounds containing each Species (as
        generated by species_totals).
            e.g. {Specie Cs+: 1026, Specie Ag+: 521...}.
        scoring (str): Can take values:
            spec_fraction (default) - Totals in dictionary / total compounds containing
            that species.
            an_norm - As in spec_frac but also divided by total compounds
            containing that anion.
            spec_prob - Calculate the probability of the compound based on
            available oxidation states.

    Returns:
        list_vals (dict): lists of scores for each species, dict is keyed by anion.
        WARNING: Each lists in the dict is ordered by the supplied spec_list.
     """

    # If a structures list is provided, need to go away and use species_totals to generate info
    # Check that none of the other dicts have been provided and anions are specified
    if structures:
        assert (bool(anion_count_dict), bool(spec_totals)) \
        == (False, False), '''Cannot provide structures list AND data dicts.
                                     Please choose one or the other.'''
        assert bool(anions) == True, ''' No anions specified. Please provide a list of
                                        Pymatgen.Species as anions.'''

    # If structures are not provided, check that all other dicts have been
    if not structures:
        assert (bool(anion_count_dict), bool(spec_totals)) \
        == (True, True), '''Missing information: Please provide either a structures lists
                              or data dicts produced by informatics.species_totals.'''

    if structures: # populate dicts using structures dataset
        print("Using structures dict to get the necessary species statistics...")
        print("Getting total count for each species...")
        spec_totals = species_totals(structures)
        print("Getting species count by anion...")
        anion_count_dict = species_totals(structures, anions=anions)
    else:
        print("Using dicts supplied to function for statistics.")

    if not spec_list:
        print("No species list provided, using all metal cations in the structure dataset...")
        spec_list = get_unique_species(structures)

    if scoring == 'spec_fraction':
        list_vals = {}
        for an, subdict in anion_count_dict.items():
            an_vals = []
            for i in spec_list:
                if i in anion_count_dict[an]:
                    an_vals.append(anion_count_dict[an][i]/spec_totals[i])
                else:
                    an_vals.append(0.)
            list_vals[an] = an_vals

    elif scoring == 'an_norm':
        list_vals = {}
        for an, subdict in anion_count_dict.items():
            an_vals = []
            for i in spec_list:
                if i in anion_count_dict[an]:
                    an_vals.append(anion_count_dict[an][i]/(spec_totals[i]*\
                    spec_totals[an])*1000)
                else:
                    an_vals.append(0.)
            list_vals[an] = an_vals

    elif scoring == 'spec_prob':
        list_vals = {}
        for an, subdict in anion_count_dict.items():
            an_vals = []
            for i in spec_list:
                if i in anion_count_dict[an]:
                    element_an_counts = [count for sp,count in subdict.items() if i.symbol==sp.symbol]
                    element_an_tot = sum(element_an_counts)
                    an_vals.append(anion_count_dict[an][i]/(element_an_tot))
                else:
                    an_vals.append(0.)
            list_vals[an] = an_vals

    return(spec_list,list_vals)


def plot_all_scores(list_scores, spec_list, break_points, figure_filename, raw_totals=None):
    """ Plots correlation plots for all the species considered.
    Args:
        list_scores (dict): Lists of scores for the species in spec_list
        keyed by anion (as generated by generate_scores).
        spec_list (list): Pymatgen species in same order as corresponding
        scores in each list within the dict list_scores (as used by generate_scores).
        break_points (list): ints, positions in lists to start each new plot.
        figure_filename (str): Name of .png file to save plot.
        raw_totals (list) of dicts: Two dicts: First dict is element totals, second
        dict is species totals. If included, will display these values on the plot.
    Returns:
        Saves and shows plots. Data should be chunked into 14 subplots (3 x 4 + 2) and this
        is not currently flexible.
         """
    arr = np.array([list_scores[key] for key in list_scores])
    arr = arr.transpose()

    # y-axis
    y_labels = []
    for i in spec_list:
        if raw_totals:
            spec_tot = raw_totals[1][i]
            el_tot = raw_totals[0][i.symbol]
            y_lab = r"$_{{{0}/{1}}}$ {2}$^{{+{3}}}$".format(spec_tot,el_tot,i.symbol,int(i.oxi_state))
        else:
            y_lab = r"{0}$^{{+{1}}}$".format(i.symbol,int(i.oxi_state))
        y_labels.append(y_lab)
    # x-axis clean up
    x_labels = [key.symbol for key, val in list_scores.items()]

    # Chunk up data
    chunks = {}
    spec_labels = {}
    for i in range(0, len(break_points)-1):
        chunk = arr[break_points[i]: break_points[i+1]]
        label_chunk = y_labels[break_points[i]: break_points[i+1]]
        chunks['{}'.format(i)] = chunk
        spec_labels['{}'.format(i)] = label_chunk

    # Plotting
    f, axarr = plt.subplots(5, 3)
    plot = plt.setp(axarr, xticks=np.arange(0,8), xticklabels=x_labels)

    axarrs = [axarr[0,0],axarr[0,1], axarr[0,2],
          axarr[1,0], axarr[1,1],axarr[1,2],
          axarr[2,0],axarr[2,1], axarr[2,2],
          axarr[3,0],axarr[3,1], axarr[3,2],
          axarr[4,0],axarr[4,1]   ]

    '''axarrs = [ axarr[0,0], axarr[0,1],
            axarr[1,0], axarr[1,1],
            axarr[2,0], axarr[2,1],
            axarr[3,0], axarr[3,1],
            axarr[4,0], axarr[4,1],
            axarr[5,0], axarr[5,1],
            axarr[6,0], axarr[6,1]
            ]
'''
    for ax, i in zip(axarrs, list(chunks.keys())):
        ax1 =ax.imshow(chunks[i], interpolation='None',
        cmap = mpl.cm.get_cmap('inferno_r'), vmin = 0, vmax =1)
        plt.sca(ax)
        plt.yticks([i for i,n in enumerate(chunks[i])], spec_labels[i])

    # Tidy up
    plt.tight_layout()
    f.subplots_adjust(right = 0.85)
    cbar_ax = f.add_axes([0.9,0.05,0.04,0.3])
    f.colorbar(ax1, cax=cbar_ax)
    plt.savefig(figure_filename, dpi = 300)
    plt.show()


def plot_metal(metal, list_scores, spec_list, show_legend = False):
    """ Plot distribution of species for individual metals.
    Args:
        metal (str): metal element of interest to plot.
        list_scores (dict): Lists of scores for the species in spec_list
        keyed by anion (as generated by genrate_scores).
        spec_list (list): Pymatgen species in same order as corresponding
        scores in each list within the dict list_scores.
        show_legend (bool): display legend on plot.
    Returns:
        Shows and saves plot.
     """
    # Set initial very daft x and y range values to be adjusted below
    min_x, max_x = 20, -20
    max_y = 0

    overall_list = []
    for anion in list_scores.keys():
        an_dict = {}
        for spec,score in zip(spec_list,list_scores[anion]):
            if spec.symbol == metal:
                an_dict[spec.oxi_state] = score
        sorted_list = sorted(an_dict.items())
        if an_dict:
            x,y = zip(*sorted_list)
            x = list(x)
            y = list(y)
            overall_list.append([x,y,anion])
            if min(x) < min_x:
                min_x = min(x)
            if max(x) > max_x:
                max_x = max(x)
            if max(y) > max_y:
                max_y = max(y)
        else:
            overall_list.append([[1],[0],anion])

    # Plotting
    labels = ["$F^-$","$O^{2-}$","$Cl^-$","$Br^-$","$I^-$","$S^{2-}$","$Se^{2-}$","$Te^{2-}$"]

    # Aesthetics and bar positions
    width = 1./10.
    pos = 0
    colours = ['#E51200', '#DF5400', '#DA9300', '#D4CE00',
               '#97CF00', '#57C900', '#1BC400', '#00BF1D']

    for col,anion in enumerate(overall_list):
        pos += width
        plt.bar(np.array(anion[0]) + pos, anion[1], width, label=labels[col], color = colours[col])

    if show_legend:
        plt.legend(prop={'size':24})

    plt.xticks(np.arange(min_x, max_x+1)+0.5, np.arange(min_x,max_x+1, dtype=np.int_))
    if min_x < 0:
        min_x = 0
    plt.xlim(min_x, max_x+1)
    plt.ylim(0, 1.19)
    plt.xlabel('Oxidation state')
    plt.ylabel('Species fraction')

    at_no = int(Element(metal).number)
    mass = Element(metal).mass
    plt.text(np.mean([max_x,min_x]) + 0.5, 1.0, "$^{{{0}}}$\n  {1}\n$_{{{2:.2f}}}$".format(at_no,metal, mass),
            bbox={'facecolor':'gray', 'alpha':0.3, 'pad':20}, size=28)
    plt.tight_layout()
    plt.savefig('OxidationState_score_{0}'.format(metal, dpi=300))
    plt.show()

def assign_prob(structures, scoring = 'overall_score', verbose=False,
        edit_struc_dict = True, list_scores=None, species_list=None):
    """ Assigns probability values to structures based on the list of score values.
    Args:
        structures (list): Pymatgen Structures, keyed under 'structure'.
        list_scores (dict): Lists of scores for the species in spec_list keyed by anion
        (as produced by generate_scores). Default values used from Faraday Discussions paper
        (DOI: 10.1039/C8FD00032H) if none supplied.
        species_list (list): Pymatgen species in same order as corresponding lists in list_scores.
        Default values used from Faraday Discussions paper (DOI: 10.1039/C8FD00032H) if none supplied.
        scoring (str): Can be either:
                        overall_score - Mean species-anion score for each species of interest
                        in the composition.
                        limiting_score - As above but minimum species-anion score.
                        probability - Product of scores.
                        probability_simple - Product of scores for different species only (set(comp))
        verbose (bool): Explicitly print any compounds that were skipped over due to the elements
        they contain.
        edit_struc_dict (bool): Add the probability to the dicts in the structures list.
    Returns:
        probabilities_list (list): Score for each structure in structures.
    """
    if not list_scores:
        # Import default list_scores from data directory
        with open(os.path.join(data_directory,
            'oxidation_states/oxidationstates_prob_table.csv'), 'r') as f:
            reader = csv.reader(f)
            list_scores = {eval(rows[0]): eval(rows[1]) for rows in reader}
            print('INFO: Using default list_scores.')

    if not species_list:
        # Import species_list from data directory
        with open(os.path.join(data_directory,'oxidation_states/species_list.txt'), 'r') as f:
            species_list = eval(f.readline())
            print('INFO: Using default species_list.')
    scores_dict = {}
    for key in list_scores.keys():
        an = {}
        for spec, val in zip(species_list, list_scores[key]):
            an[spec] = val
        scores_dict[key] = an

    probabilities_list = []
    for struc in structures:
        scores = []
        comp = set(list(struc['structure'].species))
        comp = [(sp.symbol, sp.oxi_state) for sp in comp]

        an_symbols = [an[0] for an in list_scores.keys()]
        if 'most_eneg_anion' not in struc.keys():
            # Get most eneg element in struc
            els = [Element(e[0]) for e in comp]
            els.sort(key=lambda x: x.pauling_eneg, reverse=True)
            most_eneg = els[0].symbol
            if most_eneg in an_symbols:
                for poss in list_scores.keys():
                    if poss[0] == most_eneg:
                        struc['most_eneg_anion'] = poss
            else:
                print('No data available for most electronegative anion in structure.')
        try:
            scores = [scores_dict[struc['most_eneg_anion']][sp] for sp in comp \
            if sp in species_list]
            if scoring == 'overall_score':
                overall_score = np.mean(scores)
            elif scoring == 'limiting_score':
                overall_score = min(scores)
            elif scoring == 'probability':
                overall_score = np.prod(scores)
            elif scoring == 'probability_simple':
                scores = [scores_dict[struc['most_eneg_anion']][sp] for sp in list(set(comp)) \
                if sp in species_list]
                overall_score = np.prod(scores)
        except:
            if verbose:
                print('Could not get score for: {}'.format(comp))
            overall_score = 0
        if edit_struc_dict:
            struc['probability'] = overall_score
        probabilities_list.append(overall_score)

    return probabilities_list

def assign_prob_new(compositions, list_scores, species_list, scoring, verbose=False):
    """ Assign probabilities to novel compositions based on a list of score values.
    Note: This works very similarly to the assign_prob function and the two should be combined
    in the future.
    Args:
        compositions (list): list of lists of Pymatgen Species (e.g. as generated by smact).
        These can be one item in the list for each species in the structure.
        The last species in the list should be the anion of interest.
        list_scores (dict): Lists of scores for the species in spec_list.
        spec_list (list): Pymatgen species in same order as corresponding list_scores.
        verbose (bool): Explicitly print any compounds that were skipped over.
        scoring (str): Can be either:
                        overall_score: mean species-anion score for each species of interest
                        in the composition
                        limiting_score: as above but minimum species-anion score
                        probability: product of scores
                        probability_simple: product of scores for different species only (set(comp))
    Returns:
        probabilities_list (list): List containing the score for each list of compositions.
        """
    scores_dict = {}
    for key in list_scores.keys():
        an = {}
        for spec, val in zip(species_list, list_scores[key]):
            an[spec] = val
        scores_dict[key] = an

    probabilities_list = []
    for comp in tqdm(compositions):
        scores = []
        # Assumes the last species is the most electronegative
        most_eneg = comp[-1]
        try:
            scores = [scores_dict[most_eneg][sp] for sp in comp \
            if sp in species_list]
            if scoring == 'overall_score':
                overall_score = np.mean(scores)
            elif scoring == 'limiting_score':
                overall_score = min(scores)
            elif scoring == 'probability':
                overall_score = np.prod(scores)
            elif scoring == 'probability_simple':
                scores = [scores_dict[most_eneg][sp] for sp in list(set(comp)) \
                if sp in species_list]
                overall_score = np.prod(scores)
        except:
            if verbose:
                print('Could not get score for: {}'.format(comp))
            overall_score = 0
        probabilities_list.append(overall_score)
    return probabilities_list

def plot_hist(values, bins = 100, plot_title='plot', xlim = None, ylim = None):
    """ Plot histogram of a list of values.
    Args:
        values (list): values to plot.
        bins (int): number of bins.
        plot_title (str): title of plot.
        xlim (list): min and max for x-axis.
        ylim (list): as xlim.
    Returns:
        Saves and plots histogram with the title as filename.
    """
    print('Number of individual values: {}'.format(len(scores)))
    print('Number of zero values: {}'.format(scores.count(0.0)))
    print('Maximum score: {}'.format(max(scores)))

    plt.hist(scores, bins, color='orange', alpha=0.5)
    if xlim:
        plt.xlim(xlim[0],xlim[1])
    plt.title(plot_title)
    plt.xlabel('Score')
    if ylim:
        plt.ylim(ylim[0],ylim[1])
    plt.tight_layout()
    plt.savefig('{}.png'.format(plot_title), dpi=300)
    plt.show()
