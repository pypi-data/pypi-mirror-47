
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Structural modeling &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="RTL modeling" href="rtl.html" />
    <link rel="prev" title="Hardware-oriented types" href="hwtypes.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The MyHDL manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="preface.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="background.html">Background information</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction to MyHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="hwtypes.html">Hardware-oriented types</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Structural modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="rtl.html">RTL modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="highlevel.html">High level modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="unittest.html">Unit testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="cosimulation.html">Co-simulation with Verilog</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion.html">Conversion to Verilog and VHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion_examples.html">Conversion examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.6.html">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.5.html">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.4.html">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.3.html">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">The MyHDL manual</a><ul>
      <li>Previous: <a href="hwtypes.html" title="previous chapter">Hardware-oriented types</a></li>
      <li>Next: <a href="rtl.html" title="next chapter">RTL modeling</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="structural-modeling">
<span id="model-structure"></span><h1>Structural modeling<a class="headerlink" href="#structural-modeling" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="index-0"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Hardware descriptions need to support the concepts of module instantiation and
hierarchy.  In MyHDL, an instance is recursively defined as being either a
sequence of instances, or a generator. Hierarchy is modeled by defining
instances in a higher-level function, and returning them.  The following is a
schematic example of the basic case.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">instance_1</span> <span class="o">=</span> <span class="n">module_1</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">instance_2</span> <span class="o">=</span> <span class="n">module_2</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">instance_n</span> <span class="o">=</span> <span class="n">module_n</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">instance_1</span><span class="p">,</span> <span class="n">instance_2</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="n">instance_n</span>
</pre></div>
</div>
<p>Note that MyHDL uses conventional procedural techniques for modeling structure.
This makes it straightforward to model more complex cases.</p>
</div>
<div class="section" id="conditional-instantiation">
<span id="model-conf"></span><h2>Conditional instantiation<a class="headerlink" href="#conditional-instantiation" title="Permalink to this headline">¶</a></h2>
<p id="index-1">To model conditional instantiation, we can select the returned instance under
parameter control. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span>

<span class="n">SLOW</span><span class="p">,</span> <span class="n">MEDIUM</span><span class="p">,</span> <span class="n">FAST</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">speed</span><span class="o">=</span><span class="n">SLOW</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">slowAndSmall</span><span class="p">():</span>
       <span class="o">...</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">fastAndLarge</span><span class="p">():</span>
       <span class="o">...</span>
    <span class="k">if</span> <span class="n">speed</span> <span class="o">==</span> <span class="n">SLOW</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">slowAndSmall</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">speed</span> <span class="o">==</span> <span class="n">FAST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fastAndLarge</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
</div>
<div class="section" id="lists-of-instances-and-signals">
<span id="model-instarray"></span><h3>Lists of instances and signals<a class="headerlink" href="#lists-of-instances-and-signals" title="Permalink to this headline">¶</a></h3>
<p id="index-2">Python lists are easy to create. We can use them to model lists of instances.</p>
<p>Suppose we have a top module that instantiates a single <code class="docutils literal notranslate"><span class="pre">channel</span></code> submodule,
as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">Signal</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>

    <span class="n">din</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dout</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">clk</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">reset</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">channel_inst</span> <span class="o">=</span> <span class="n">channel</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">din</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">channel_inst</span>
</pre></div>
</div>
<p>If we wanted to support an arbitrary number of channels, we can use lists of
signals and a list of instances, as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">Signal</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>

    <span class="n">din</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">dout</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">clk</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">reset</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">channel_inst</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">channel_inst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">(</span><span class="n">dout</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">din</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">channel_inst</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="converting-between-lists-of-signals-and-bit-vectors">
<span id="model-shadow-signals"></span><h2>Converting between lists of signals and bit vectors<a class="headerlink" href="#converting-between-lists-of-signals-and-bit-vectors" title="Permalink to this headline">¶</a></h2>
<p>Compared to HDLs such as VHDL and Verilog, MyHDL signals are less
flexible for structural modeling. For example, slicing a signal
returns a slice of the current value. For behavioral code, this is
just fine. However, it implies that you cannot use such as slice in
structural descriptions. In other words, a signal slice cannot be used
as a signal.</p>
<p>In MyHDL, you can address such cases by a concept called
shadow signals. A shadow signal is constructed out of
other signals and follows their value changes automatically.
For example, a <a class="reference internal" href="reference.html#myhdl._SliceSignal" title="myhdl._SliceSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SliceSignal</span></code></a> follows the value of
an index or a slice from another signal.  Likewise,
A <a class="reference internal" href="reference.html#myhdl.ConcatSignal" title="myhdl.ConcatSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcatSignal</span></code></a> follows the
values of a number of signals as a concatenation.</p>
<p>As an example, suppose we have a system with N requesters that
need arbitration. Each requester has a <code class="docutils literal notranslate"><span class="pre">request</span></code> output
and a <code class="docutils literal notranslate"><span class="pre">grant</span></code> input. To connect them in the system, we can
use list of signals. For example, a list of request signals
can be constructed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">request_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>
</pre></div>
</div>
<p>Suppose that an arbiter module is available that is
instantiated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arb</span> <span class="o">=</span> <span class="n">arbiter</span><span class="p">(</span><span class="n">grant_vector</span><span class="p">,</span> <span class="n">request_vector</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">request_vector</span></code> input is a bit vector that can have
any of its bits asserted. The <code class="docutils literal notranslate"><span class="pre">grant_vector</span></code> is an output
bit vector with just a single bit asserted, or none.
Such a module is typically based on bit vectors because
they are easy to process in RTL code. In MyHDL, a bit vector
is modeled using the <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> type.</p>
<p>We need a way to “connect” the list of signals to the
bit vector and vice versa. Of course, we can do this with explicit
code, but shadow signals can do this automatically. For
example, we can construct a <code class="docutils literal notranslate"><span class="pre">request_vector</span></code> as a
<a class="reference internal" href="reference.html#myhdl.ConcatSignal" title="myhdl.ConcatSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcatSignal</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">request_vector</span> <span class="o">=</span> <span class="n">ConcatSignal</span><span class="p">(</span><span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">request_list</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we reverse the list first. This is done because the index range
of lists is the inverse of the range of <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> bit vectors.
By reversing, the indices correspond to the same bit.</p>
<p>The inverse problem exist for the <code class="docutils literal notranslate"><span class="pre">grant_vector</span></code>. It would be defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grant_vector</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">M</span><span class="p">:])</span>
</pre></div>
</div>
<p>To construct a list of signals that are connected automatically to the
bit vector, we can use the <a class="reference internal" href="reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> call interface to construct
<a class="reference internal" href="reference.html#myhdl._SliceSignal" title="myhdl._SliceSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SliceSignal</span></code></a> objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grant_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">grant_vector</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>
</pre></div>
</div>
<p>Note the round brackets used for this type of slicing. Also, it may not be
necessary to construct this list explicitly. You can simply use
<code class="docutils literal notranslate"><span class="pre">grant_vector(i)</span></code> in an instantiation.</p>
<p>To decide when to use normal or shadow signals, consider the data
flow. Use normal signals to connect to <em>outputs</em>. Use shadow signals to
transform these signals so that they can be used as <em>inputs</em>.</p>
</div>
<div class="section" id="inferring-the-list-of-instances">
<span id="model-infer-instlist"></span><h2>Inferring the list of instances<a class="headerlink" href="#inferring-the-list-of-instances" title="Permalink to this headline">¶</a></h2>
<p>In MyHDL, instances have to be returned explicitly by a top level function. It
may be convenient to assemble  the list of instances automatically. For this
purpose, MyHDL  provides the function <a class="reference internal" href="reference.html#myhdl.instances" title="myhdl.instances"><code class="xref py py-func docutils literal notranslate"><span class="pre">instances</span></code></a>. Using the first example
in this section, it is used as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">instances</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">instance_1</span> <span class="o">=</span> <span class="n">module_1</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">instance_2</span> <span class="o">=</span> <span class="n">module_2</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">instance_n</span> <span class="o">=</span> <span class="n">module_n</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
<p>Function <a class="reference internal" href="reference.html#myhdl.instances" title="myhdl.instances"><code class="xref py py-func docutils literal notranslate"><span class="pre">instances</span></code></a> uses introspection to inspect the type of the local
variables defined by the calling function. All variables that comply with the
definition of an instance are assembled in a list, and that list is returned.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/manual/structure.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>