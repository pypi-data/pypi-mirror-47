
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Conversion to Verilog and VHDL &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Conversion examples" href="conversion_examples.html" />
    <link rel="prev" title="Co-simulation with Verilog" href="cosimulation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The MyHDL manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="preface.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="background.html">Background information</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction to MyHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="hwtypes.html">Hardware-oriented types</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure.html">Structural modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="rtl.html">RTL modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="highlevel.html">High level modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="unittest.html">Unit testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="cosimulation.html">Co-simulation with Verilog</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Conversion to Verilog and VHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion_examples.html">Conversion examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.6.html">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.5.html">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.4.html">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.3.html">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">The MyHDL manual</a><ul>
      <li>Previous: <a href="cosimulation.html" title="previous chapter">Co-simulation with Verilog</a></li>
      <li>Next: <a href="conversion_examples.html" title="next chapter">Conversion examples</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="conversion-to-verilog-and-vhdl">
<span id="conv"></span><h1>Conversion to Verilog and VHDL<a class="headerlink" href="#conversion-to-verilog-and-vhdl" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="conv-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Subject to some limitations,
MyHDL supports the automatic conversion of MyHDL code to
Verilog or VHDL code. This feature provides a path from MyHDL into a
standard Verilog or VHDL based design environment.</p>
<p>This chapter describes the concepts of conversion. Concrete
examples can be found in the companion chapter <a class="reference internal" href="conversion_examples.html#conv-usage"><span class="std std-ref">Conversion examples</span></a>.</p>
</div>
<div class="section" id="solution-description">
<span id="conv-solution"></span><h2>Solution description<a class="headerlink" href="#solution-description" title="Permalink to this headline">¶</a></h2>
<p>To be convertible, the hardware description should satisfy certain restrictions,
defined as the <em class="dfn">convertible subset</em>. This is described
in detail in <a class="reference internal" href="#conv-subset"><span class="std std-ref">The convertible subset</span></a>.</p>
<p>A convertible design can be converted to an equivalent model in Verilog
or VHDL, using the function <a class="reference internal" href="reference.html#myhdl.toVerilog" title="myhdl.toVerilog"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVerilog</span></code></a> or <a class="reference internal" href="reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVHDL</span></code></a>  from the MyHDL
library.</p>
<p>When the design is intended for implementation
a third-party <em class="dfn">synthesis tool</em> is used to compile the Verilog or VHDL
model into an implementation for an ASIC or FPGA. With this step, there is
an automated path from a hardware description in Python to an FPGA or ASIC implementation.</p>
<p>The conversion does not start from source files, but from an instantiated design
that has been <em>elaborated</em> by the Python interpreter. The converter uses the
Python profiler to track the interpreter’s operation and to infer the design
structure and name spaces. It then selectively compiles pieces of source code
for additional analysis and for conversion.</p>
</div>
<div class="section" id="features">
<span id="conv-features"></span><h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Conversion after elaboration</dt>
<dd><em>Elaboration</em> refers to the initial processing of a hardware description to
achieve a representation of a design instance that is ready for simulation or
synthesis. In particular, structural parameters and constructs are processed in
this step. In MyHDL, the Python interpreter itself is used for elaboration.  A
<a class="reference internal" href="reference.html#myhdl.Simulation" title="myhdl.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code></a> object is constructed with elaborated design instances as
arguments.  Likewise, conversion works on an elaborated design
instance. The Python interpreter is thus used as much as possible.</dd>
<dt>Arbitrarily complex structure</dt>
<dd>As the conversion works on an elaborated design instance, any modeling
constraints only apply to the leaf elements of the design structure, that is,
the co-operating generators. In other words, there are no restrictions on the
description of the design structure: Python’s full power can be used for that
purpose. Also, the design hierarchy can be arbitrarily deep.</dd>
<dt>Generator are mapped to Verilog or VHDL constructs</dt>
<dd>The converter analyzes the code of each generator and maps it to equivalent
constructs in the target HDL. For Verilog, it will map generators to
<code class="docutils literal notranslate"><span class="pre">always</span></code> blocks, continuous assignments or <code class="docutils literal notranslate"><span class="pre">initial</span></code> blocks. For VHDL,
it will map them to <code class="docutils literal notranslate"><span class="pre">process</span></code> statements or concurrent signal assignments.</dd>
<dt>The module ports are inferred from signal usage</dt>
<dd>In MyHDL, the input or output direction of ports is not explicitly
declared. The converter investigates signal usage in the design hierarchy to
infer whether a signal is used as input, output, or as an internal signal.</dd>
<dt>Interfaces are convertible</dt>
<dd>An <em>interface</em>: an object that has a number of <a class="reference internal" href="reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> objects as its
attributes. The converter supports this by name expansion and mangling.</dd>
<dt>Function calls are mapped to Verilog or VHDL subprograms</dt>
<dd>The converter analyzes function calls and function code. Each function is
mapped to an appropriate subprogram in the target HDL:  a function or task in  Verilog,
and a function  or procedure in VHDL.
In order to support the full power of Python functions,
a unique subprogram is generated per Python function call.</dd>
<dt>If-then-else structures may be mapped to case statements</dt>
<dd>Python does not provide a case statement. However,  the converter recognizes if-then-else
structures in which a variable is sequentially compared to items of an
enumeration type, and maps such a structure to a Verilog or VHDL case statement with the
appropriate synthesis attributes.</dd>
<dt>Choice of encoding schemes for enumeration types</dt>
<dd>The <a class="reference internal" href="reference.html#myhdl.enum" title="myhdl.enum"><code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code></a> function in MyHDL returns an enumeration type. This function
takes an additional parameter <em>encoding</em> that specifies the desired encoding in
the implementation: binary, one hot, or one cold. The converter
generates the appropriate code for the specified encoding.</dd>
<dt>RAM memory</dt>
<dd>Certain synthesis tools can map Verilog memories or VHDL arrays to RAM structures. To support
this interesting feature, the converter maps lists of signals to Verilog
memories or VHDL arrays.</dd>
<dt>ROM memory</dt>
<dd>Some synthesis tools can infer a ROM from a case statement. The
converter does the expansion into a case statement automatically, based on a
higher level description. The ROM access is described in a single line, by
indexing into a tuple of integers.</dd>
<dt>Signed arithmetic</dt>
<dd><p class="first">In MyHDL, working with negative numbers is trivial: one just uses an
<code class="docutils literal notranslate"><span class="pre">intbv</span></code> object with an appropriate constraint on its values.  In
contrast, both Verilog and VHDL make a difference between an
unsigned and a signed representation. To work with negative values,
the user has to declare a signed variable explicitly. But when
signed and unsigned operands are mixed in an expression, things may
become tricky.</p>
<p>In Verilog, when signed and unsigned operands are mixed, all
operands are interpreted as <em>unsigned</em>. Obviously, this leads to
unexpected results. The designer will have to add sign extensions
and type casts to solve this.</p>
<p>In VHDL, mixing signed and unsigned will generally not work. The
designer will have to match the operands manually by adding
resizings and type casts.</p>
<p class="last">In MyHDL, these issues don’t exist because <code class="docutils literal notranslate"><span class="pre">intbv</span></code> objects simply
work as (constrained) integers. Moreover, the converter automates
the cumbersome tasks that are required in Verilog and
VHDL. It uses signed or unsigned types based on the value
constraints of the intbv objects, and automatically performs the
required sign extensions, resizings, and type casts.</p>
</dd>
<dt>User-defined code</dt>
<dd>If desired, the user can bypass the conversion process and describe
user-defined code to be inserted instead.</dd>
</dl>
</div>
<div class="section" id="the-convertible-subset">
<span id="conv-subset"></span><h2>The convertible subset<a class="headerlink" href="#the-convertible-subset" title="Permalink to this headline">¶</a></h2>
<div class="section" id="conv-subset-intro">
<span id="id1"></span><h3>Introduction<a class="headerlink" href="#conv-subset-intro" title="Permalink to this headline">¶</a></h3>
<p>Unsurprisingly, not all MyHDL code can be converted.  Although the
restrictions are significant, the convertible subset is much broader
than the RTL synthesis subset which is an industry standard.  In other
words, MyHDL code written according to the RTL synthesis rules, should
always be convertible. However, it is also possible to write
convertible code for non-synthesizable models or test benches.</p>
<p>The converter attempts to issue clear error messages when it
encounters a construct that cannot be converted.</p>
<p>Recall that any restrictions only apply to the design after
elaboration.  In practice, this means that they apply only to the code
of the generators, that are the leaf functional blocks in a MyHDL
design.</p>
</div>
<div class="section" id="coding-style">
<span id="conv-subset-style"></span><h3>Coding style<a class="headerlink" href="#coding-style" title="Permalink to this headline">¶</a></h3>
<p>A natural restriction on convertible code is that it should be written
in MyHDL style: cooperating generators, communicating through signals,
and with sensitivity specify resume conditions.</p>
<p>For pure modeling, it doesn’t matter how generators are created.
However, in convertible code they should be created using one of the
MyHDL decorators: <a class="reference internal" href="reference.html#myhdl.instance" title="myhdl.instance"><code class="xref py py-func docutils literal notranslate"><span class="pre">instance</span></code></a>, <a class="reference internal" href="reference.html#myhdl.always" title="myhdl.always"><code class="xref py py-func docutils literal notranslate"><span class="pre">always</span></code></a>,
<a class="reference internal" href="reference.html#myhdl.always_seq" title="myhdl.always_seq"><code class="xref py py-func docutils literal notranslate"><span class="pre">always_seq</span></code></a>, or <a class="reference internal" href="reference.html#myhdl.always_comb" title="myhdl.always_comb"><code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code></a>.</p>
</div>
<div class="section" id="supported-types">
<span id="conv-subset-types"></span><h3>Supported types<a class="headerlink" href="#supported-types" title="Permalink to this headline">¶</a></h3>
<p>The most important restriction regards object types.  Only a limited
amount of types can be converted. Python <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code> objects are mapped to Verilog or VHDL integers. All
other supported types need to have a defined bit width. The
supported types are the Python <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> type, the MyHDL
<a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> type, and MyHDL enumeration types returned by function
<a class="reference internal" href="reference.html#myhdl.enum" title="myhdl.enum"><code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code></a>.</p>
<p id="index-0"><a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects must be constructed so that a bit width can be
inferred.  This can be done by specifying minimum and maximum values,
e.g. as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">MIN</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">MAX</span><span class="p">)</span>
</pre></div>
</div>
<p>The Verilog converter supports <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects that can take
negative values.</p>
<p>Alternatively, a slice can be taken from an <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">N</span><span class="p">:]</span>
</pre></div>
</div>
<p>Such as slice returns a new <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object, with minimum value
<code class="docutils literal notranslate"><span class="pre">0</span></code> , and maximum value <code class="docutils literal notranslate"><span class="pre">2**N</span></code>.</p>
<p>In addition to the scalar types described above, the converter also
supports a number of tuple and list based types. The mapping from
MyHDL types is summarized in the following table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="24%" />
<col width="9%" />
<col width="24%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">MyHDL type</th>
<th class="head">VHDL type</th>
<th class="head">Notes</th>
<th class="head">Verilog type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">integer</span></code></td>
<td>&#160;</td>
<td><code class="docutils literal notranslate"><span class="pre">integer</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">std_logic</span></code></td>
<td>(1)</td>
<td><code class="docutils literal notranslate"><span class="pre">reg</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">intbv</span></code> with <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">unsigned</span></code></td>
<td>(2)</td>
<td><code class="docutils literal notranslate"><span class="pre">reg</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">intbv</span></code> with  <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">signed</span></code></td>
<td>(2)</td>
<td><code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">signed</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">enum</span></code></td>
<td>dedicated enumeration type</td>
<td>&#160;</td>
<td><code class="docutils literal notranslate"><span class="pre">reg</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code></td>
<td>mapped to case statement</td>
<td>(3)</td>
<td>mapped to case statement</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">std_logic</span></code></td>
<td>&#160;</td>
<td><code class="docutils literal notranslate"><span class="pre">reg</span></code></td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">intbv</span></code> with <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">unsigned</span></code></td>
<td>(4)</td>
<td><code class="docutils literal notranslate"><span class="pre">reg</span></code></td>
<td>(4)(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">intbv</span></code> with <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">signed</span></code></td>
<td>(4)</td>
<td><code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">signed</span></code></td>
<td>(4)(5)</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>The VHDL <code class="docutils literal notranslate"><span class="pre">std_logic</span></code> type is defined in the standard VHDL package
<code class="docutils literal notranslate"><span class="pre">IEEE.std_logic_1164</span></code>.</li>
<li>The VHDL <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> and <code class="docutils literal notranslate"><span class="pre">signed</span></code> types used are those from the
standard VHDL packages <code class="docutils literal notranslate"><span class="pre">IEEE.numeric_std</span></code>.</li>
<li>A MyHDL <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code> is used for ROM inference, and can only be
used in a very specific way: an indexing operation into the tuple
should be the rhs of an assignment.</li>
<li>All list members should have identical value constraints.</li>
<li>Lists are mapped to Verilog memories.</li>
</ol>
<p>The table as presented applies to MyHDL variables. The converter also
supports MyHDL signals that use <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">intbv</span></code> or <code class="docutils literal notranslate"><span class="pre">enum</span></code>
objects as their underlying type. For VHDL, these are mapped to VHDL signals
with an underlying type as specified in the table above. Verilog doesn’t have
the signal concept. For Verilog, a MyHDL signal is mapped to a Verilog
<code class="docutils literal notranslate"><span class="pre">reg</span></code> as in the table above, or to a Verilog <code class="docutils literal notranslate"><span class="pre">wire</span></code>, depending
on the signal usage.</p>
<p>The converter supports MyHDL list of signals provided the underlying
signal type is either <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">intbv</span></code>. They may be mapped to a
VHDL signal with a VHDL type as specified in the table, or to a
Verilog memory.  However, list of signals are not always mapped to a
corresponding VHDL or Verilog object.  See <a class="reference internal" href="#conv-listofsigs"><span class="std std-ref">Conversion of lists of signals</span></a> for
more info.</p>
</div>
<div class="section" id="supported-statements">
<span id="conv-subset-statements"></span><h3>Supported statements<a class="headerlink" href="#supported-statements" title="Permalink to this headline">¶</a></h3>
<p>The following is a list of the statements that are supported by the Verilog
converter, possibly qualified with restrictions or usage notes.</p>
<dl class="docutils">
<dt><a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a></dt>
<dd><p class="first">An <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> statement in Python looks as follow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">test_expression</span>
</pre></div>
</div>
<p class="last">It can be converted provided <code class="docutils literal notranslate"><span class="pre">test_expression</span></code> is convertible.</p>
</dd>
</dl>
<p><a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#break" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a></p>
<p><a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#continue" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a></p>
<p><a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#def" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a></p>
<dl class="docutils">
<dt><a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#for" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a></dt>
<dd>The only supported iteration scheme is iterating through sequences of integers
returned by built-in function <code class="xref py py-func docutils literal notranslate"><span class="pre">range</span></code> or MyHDL function
<a class="reference internal" href="reference.html#myhdl.downrange" title="myhdl.downrange"><code class="xref py py-func docutils literal notranslate"><span class="pre">downrange</span></code></a>.  The optional <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#else" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> clause is not supported.</dd>
<dt><a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#if" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a></dt>
<dd><a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#if" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#elif" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">elif</span></code></a>, and <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#else" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> clauses are fully supported.</dd>
</dl>
<p><a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#pass" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a></p>
<p><code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code></p>
<blockquote>
<div><p>A <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> statement with multiple arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>is supported. However, there are restrictions on the arguments.
First, they should be of one of the following forms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arg</span>
<span class="n">formatstring</span> <span class="o">%</span> <span class="n">arg</span>
<span class="n">formatstring</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">arg</span></code> is a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">intbv</span></code>, <code class="docutils literal notranslate"><span class="pre">enum</span></code>, or a
<code class="docutils literal notranslate"><span class="pre">Signal</span></code> of these types.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">formatstring</span></code> contains ordinary characters and conversion
specifiers as in Python. However, the only supported conversion specifiers
are <code class="docutils literal notranslate"><span class="pre">%s</span></code> and <code class="docutils literal notranslate"><span class="pre">%d</span></code>.
Justification and width specification are thus not supported.</p>
<p>Printing without a newline:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">arg1</span> <span class="p">,</span>
</pre></div>
</div>
<p>is not supported.</p>
</div></blockquote>
<dl class="docutils">
<dt><a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#raise" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a></dt>
<dd>This statement is mapped to statements that end the simulation with an
error message.</dd>
</dl>
<p><a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#return" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a></p>
<dl class="docutils">
<dt><a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#yield" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a></dt>
<dd>A <cite>yield</cite> expression is used to specify a sensitivity list.
The yielded expression can be a <a class="reference internal" href="reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a>, a signal edge as specified by MyHDL
functions <a class="reference internal" href="reference.html#myhdl.Signal.posedge" title="myhdl.Signal.posedge"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Signal.posedge</span></code></a> or <a class="reference internal" href="reference.html#myhdl.Signal.negedge" title="myhdl.Signal.negedge"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Signal.negedge</span></code></a>, or a tuple of signals and edge
specifications. It can also be a <a class="reference internal" href="reference.html#myhdl.delay" title="myhdl.delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">delay</span></code></a> object.</dd>
<dt><a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#while" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a></dt>
<dd>The optional <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#else" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> clause is not supported.</dd>
</dl>
</div>
<div class="section" id="supported-built-in-functions">
<span id="conv-subset-builtin"></span><h3>Supported built-in functions<a class="headerlink" href="#supported-built-in-functions" title="Permalink to this headline">¶</a></h3>
<p>The following is a list of the built-in functions that are supported by the
converter.</p>
<dl class="docutils">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">bool</span></code></dt>
<dd>This function can be used to typecast an object explicitly to its boolean
interpretation.</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/functions.html#len" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">len</span></code></a></dt>
<dd>For <a class="reference internal" href="reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> and <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects, function <a class="reference external" href="https://docs.python.org/3/library/functions.html#len" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">len</span></code></a> returns the
bit width.</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">int</span></code></dt>
<dd>This function can be used to typecast an object explicitly to its integer
interpretation.</dd>
</dl>
</div>
<div class="section" id="docstrings">
<h3>Docstrings<a class="headerlink" href="#docstrings" title="Permalink to this headline">¶</a></h3>
<p>The converter propagates comments under the form of Python
docstrings.</p>
<p>Docstrings are typically used in Python to document certain objects in
a standard way. Such “official” docstrings are put into the converted
output at appropriate locations.  The converter supports official
docstrings for the top level module and for generators.</p>
<p>Within generators, “nonofficial” docstrings are propagated also. These
are strings (triple quoted by convention) that can occur anywhere
between statements.</p>
<p>Regular Python comments are ignored by the Python parser, and they are
not present in the parse tree. Therefore, these are not
propagated. With docstrings, you have an elegant way to specify which
comments should be propagated and which not.</p>
</div>
</div>
<div class="section" id="conversion-of-lists-of-signals">
<span id="conv-listofsigs"></span><h2>Conversion of lists of signals<a class="headerlink" href="#conversion-of-lists-of-signals" title="Permalink to this headline">¶</a></h2>
<p>Lists of signals are useful for many purposes. For example, they make
it easy to create a repetitive structure. Another application is the
description of memory behavior.</p>
<p>The converter output is non-hierarchical. That implies that all
signals are declared at the top-level in VHDL or Verilog (as VHDL
signals, or Verilog regs and wires.)  However, some signals that are a
list member at some level in the MyHDL design hierarchy may be used as
a plain signal at a lower level. For such signals, a choice has to be
made whether to declare a Verilog memory or VHDL array, or a number of
plain signal names.</p>
<p>If possible, plain signal declarations are preferred, because Verilog
memories and arrays have some restrictions in usage and tool support.
This is possible if the list syntax is strictly used outside generator
code, for example when lists of signals are used to describe
structure.</p>
<p>Conversely, when list syntax is used in some generator, then a Verilog
memory or VHDL array will be declared. The typical example is the
description of RAM memories.</p>
</div>
<div class="section" id="conversion-of-interfaces">
<span id="conv-interfaces"></span><h2>Conversion of Interfaces<a class="headerlink" href="#conversion-of-interfaces" title="Permalink to this headline">¶</a></h2>
<p>Complex designs often have many signals that are passed to different levels of
hierarchy.  Typically, many signals logically belong together. This can be
modelled by an <em>interface</em>: an object that has a number of <a class="reference internal" href="reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a>
objects as its attributes.  Grouping signals into an interface simplifies the
code, improves efficiency, and reduces errors.</p>
<p>The converter supports interface using hierarchical name expansion and name
mangling.</p>
</div>
<div class="section" id="assignment-issues">
<span id="conv-meth-assign"></span><h2>Assignment issues<a class="headerlink" href="#assignment-issues" title="Permalink to this headline">¶</a></h2>
<div class="section" id="name-assignment-in-python">
<span id="conv-meth-assign-python"></span><h3>Name assignment in Python<a class="headerlink" href="#name-assignment-in-python" title="Permalink to this headline">¶</a></h3>
<p>Name assignment in Python is a different concept than in many other languages.
This point is very important for effective modeling in Python, and even more so
for synthesizable MyHDL code. Therefore, the issues are discussed here
explicitly.</p>
<p>Consider the following name assignments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>a = 4
a = ``a string&#39;&#39;
a = False
</pre></div>
</div>
<p>In many languages, the meaning would be that an existing variable <em>a</em> gets a
number of different values. In Python, such a concept of a variable doesn’t
exist. Instead, assignment merely creates a new binding of a name to a certain
object, that replaces any previous binding. So in the example, the name <em>a</em> is
bound a  number of different objects in sequence.</p>
<p>The converter has to investigate name assignment and usage in MyHDL
code, and to map names to Verilog or VHDL objects. To achieve that, it tries to infer
the type and possibly the bit width of each expression that is assigned to a
name.</p>
<p>Multiple assignments to the same name can be supported if it can be determined
that a consistent type and bit width is being used in the assignments. This can
be done for boolean expressions, numeric expressions, and enumeration type
literals.</p>
<p>In other cases, a single assignment should be used when an object is created.
Subsequent value changes are then achieved by modification of an existing
object.  This technique should be used for <a class="reference internal" href="reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> and <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a>
objects.</p>
</div>
<div class="section" id="signal-assignment">
<span id="conv-meth-assign-signal"></span><h3>Signal assignment<a class="headerlink" href="#signal-assignment" title="Permalink to this headline">¶</a></h3>
<p>Signal assignment in MyHDL is implemented using attribute assignment to
attribute <code class="docutils literal notranslate"><span class="pre">next</span></code>.  Value changes are thus modeled by modification of the
existing object. The converter investigates the <a class="reference internal" href="reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object to infer
the type and bit width of the corresponding Verilog or VHDL object.</p>
</div>
<div class="section" id="intbv-objects">
<span id="conv-meth-assign-intbv"></span><h3><a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects<a class="headerlink" href="#intbv-objects" title="Permalink to this headline">¶</a></h3>
<p id="index-1">Type <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> is likely to be the workhorse for synthesizable
modeling in MyHDL. An <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> instance behaves like a (mutable)
integer whose individual bits can be accessed and modified. Also, it
is possible to constrain its set of values. In addition to error
checking, this makes it possible to infer a bit width, which is
required for implementation.</p>
<p>As noted before, it is not possible to modify value of an
<a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object using name assignment. In the following, we will
show how it can be done instead.  Consider:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:]</span>
</pre></div>
</div>
<p>This is an <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object with initial value <code class="docutils literal notranslate"><span class="pre">0</span></code> and bit
width 8. To change its value to <code class="docutils literal notranslate"><span class="pre">5</span></code>, we can use slice assignment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>The same can be achieved by leaving the bit width unspecified, which
has the meaning to change “all” bits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Often the new value will depend on the old one. For example, to
increment an <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> with the technique above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Python also provides <em>augmented</em> assignment operators, which can be
used to implement in-place operations. These are supported on
<a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects and by the converter, so that the increment can
also be done as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="excluding-code-from-conversion">
<span id="conv-subset-exclude"></span><h2>Excluding code from conversion<a class="headerlink" href="#excluding-code-from-conversion" title="Permalink to this headline">¶</a></h2>
<p>For some tasks, such as debugging, it may be useful to insert arbitrary Python
code that should not be converted.</p>
<p>The converter supports this by ignoring all code that is embedded in a
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__debug__</span></code> test. The value of the <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> variable is not taken into
account.</p>
</div>
<div class="section" id="user-defined-code">
<span id="conv-custom"></span><span id="index-2"></span><h2>User-defined code<a class="headerlink" href="#user-defined-code" title="Permalink to this headline">¶</a></h2>
<p>MyHDL provides a way to include user-defined code during the
conversion process. There are special function attributes that are understood by the
converter but ignored by the simulator. The attributes are <code class="xref py py-attr docutils literal notranslate"><span class="pre">verilog_code</span></code>
for Verilog and <code class="xref py py-attr docutils literal notranslate"><span class="pre">vhdl_code</span></code> for VHDL.  They operate like a special
return value. When defined in a MyHDL function, the converter will use
their value instead of the regular return value. Effectively, it will
stop converting at that point.</p>
<p>The value of <code class="xref py py-attr docutils literal notranslate"><span class="pre">verilog_code</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">vhdl_code</span></code> should be a Python
template string. A template string supports <code class="docutils literal notranslate"><span class="pre">$</span></code>-based substitutions.
The <code class="docutils literal notranslate"><span class="pre">$name</span></code> notation can be used to refer to the
variable names in the context of the string. The converter will
substitute the appropriate values in the string and then insert it
instead of the regular converted output.</p>
<p>There is one more issue with user-defined code.
Normally, the converter infers inputs, internal signals,
and outputs. It also detects undriven and multiple driven signals. To
do this, it assumes that signals are not driven by default. It then
processes the code to find out which signals are driven from
where.</p>
<p>Proper signal usage inference cannot be done with user-defined code. Without
user help, this will result in warnings or errors during the
inference process, or in compilation errors from invalid
code. The user can solve this by setting the <code class="xref py py-attr docutils literal notranslate"><span class="pre">driven</span></code> or
<code class="xref py py-attr docutils literal notranslate"><span class="pre">read</span></code> attribute
for signals that are driven or read from the user-defined code.
These attributes are <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.
The allowed “true” values of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">driven</span></code> attribute are
<code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">'wire'</span></code> and <code class="docutils literal notranslate"><span class="pre">'reg'</span></code>. The
latter two values specifies how the user-defined Verilog code drives the signal in
Verilog. To decide which value to use, consider how the signal should
be declared in Verilog after the user-defined code is inserted.</p>
<p>For an example of user-defined code, see <a class="reference internal" href="conversion_examples.html#conv-usage-custom"><span class="std std-ref">User-defined code</span></a>.</p>
</div>
<div class="section" id="template-transformation">
<h2>Template transformation<a class="headerlink" href="#template-transformation" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section is only relevant for VHDL.</p>
</div>
<p>There is a difference between VHDL and Verilog in the way in which
sensitivity to signal edges is specified. In Verilog, edge specifiers
can be used directly in the sensitivity list. In VHDL, this is not
possible: only signals can be used in the sensitivity list. To check
for an edge, one uses the <code class="docutils literal notranslate"><span class="pre">rising_edge()</span></code> or <code class="docutils literal notranslate"><span class="pre">falling_edge()</span></code>
functions in the code.</p>
<p>MyHDL follows the Verilog scheme to specify edges in the sensitivity
list. Consequently, when mapping such code to VHDL, it needs to be
transformed to equivalent VHDL. This is an important issue because it
affects all synthesizable templates that infer sequential logic.</p>
<p>We will illustrate this feature with some examples. This is the MyHDL
code for a D flip-flop:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
    <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>It is converted to VHDL as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DFF_LOGIC</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">DFF_LOGIC</span><span class="p">;</span>
</pre></div>
</div>
<p>The converter can handle the more general case. For example, this is
MyHDL code for a D flip-flop with asynchronous set, asynchronous
reset, and preference of set over reset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">,</span> <span class="nb">set</span><span class="o">.</span><span class="n">negedge</span><span class="p">,</span> <span class="n">rst</span><span class="o">.</span><span class="n">negedge</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">set</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">rst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>This is converted to VHDL as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DFFSR_LOGIC</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="n">rst</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">set</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="s1">&#39;1&#39;</span><span class="p">;</span>
    <span class="n">elsif</span> <span class="p">(</span><span class="n">rst</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="s1">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">elsif</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">DFFSR_LOGIC</span><span class="p">;</span>
</pre></div>
</div>
<p>All cases with practical utility can be handled in this way. However,
there are other cases that cannot be transformed to equivalent
VHDL. The converter will detect those cases and give an error.</p>
</div>
<div class="section" id="conversion-output-verification-by-co-simulation">
<span id="conv-meth-conv"></span><h2>Conversion output verification by co-simulation<a class="headerlink" href="#conversion-output-verification-by-co-simulation" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section is only relevant for Verilog.</p>
</div>
<p>To verify the converted Verilog output, co-simulation can be used. To
make this task easier, the converter also generates a test bench that
makes it possible to simulate the Verilog design using the Verilog
co-simulation interface. This permits one to verify the Verilog code with
the same test bench used for the MyHDL code.</p>
</div>
<div class="section" id="conversion-of-test-benches">
<span id="conv-testbench"></span><h2>Conversion of test benches<a class="headerlink" href="#conversion-of-test-benches" title="Permalink to this headline">¶</a></h2>
<p>After conversion, we obviously want to verify that the VHDL or Verilog
code works correctly. For Verilog, we can use co-simulation as
discussed earlier. However, for VHDL, co-simulation is currently
not supported.</p>
<p>An alternative is to convert the test bench itself, so that
both test bench and design can be run in the HDL simulator. Of course,
this is not a fully general solution, as there are important
constraints on the kind of code that can be converted.
Thus, the question is whether the conversion restrictions permit one to develop
sufficiently complex test benches. In this section, we present some
insights about this.</p>
<p>The most important restrictions regard the types that can be used, as
discussed earlier in this chapter. However, the “convertible subset” is
wider than the “synthesis subset”. We will present a number of
non-synthesizable feature that are of interest for test benches.</p>
<dl class="docutils">
<dt>the <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#while" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> loop</dt>
<dd><a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#while" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> loops can be used for high-level control structures.</dd>
<dt>the <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#raise" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> statement</dt>
<dd>A <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#raise" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> statement can stop the simulation on an error condition.</dd>
<dt><a class="reference internal" href="reference.html#myhdl.delay" title="myhdl.delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">delay</span></code></a> objects</dt>
<dd>Delay modeling is essential for test benches.</dd>
<dt>the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> statement</dt>
<dd><code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> statements can be used for simple debugging.</dd>
<dt>the <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> statement.</dt>
<dd>Originally, <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> statements were only intended to insert debugging
assertions in code. Recently, there is a tendency to use them to write
self-checking unit tests, controlled by unit test frameworks such as
<code class="docutils literal notranslate"><span class="pre">py.test</span></code>. In particular, they are a powerful way to write
self-checking test benches for MyHDL designs. As <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a>
statements are convertible, a whole unit test suite in MyHDL can be
converted to an equivalent test suite in Verilog and VHDL.</dd>
</dl>
<p>Additionally, the same techniques as for synthesizable code can be used
to master complexity. In particular, any code outside generators
is executed during elaboration, and therefore not considered in
the conversion process. This feature can for example be used for
complex calculations that set up constants or expected results.
Furthermore, a tuple of ints can be used to hold a table of
values that will be mapped to a case statement in Verilog and VHDL.</p>
</div>
<div class="section" id="methodology-notes">
<span id="conv-meth"></span><h2>Methodology notes<a class="headerlink" href="#methodology-notes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="simulate-first">
<span id="conv-meth-sim"></span><h3>Simulate first<a class="headerlink" href="#simulate-first" title="Permalink to this headline">¶</a></h3>
<p>In the Python philosophy, the run-time rules. The Python compiler doesn’t
attempt to detect a lot of errors beyond syntax errors, which given Python’s
ultra-dynamic nature would be an almost impossible task anyway. To verify a
Python program, one should run it, preferably using unit testing to verify each
feature.</p>
<p>The same philosophy should be used when converting a MyHDL description to
Verilog: make sure the simulation runs fine first. Although the converter checks
many things and attempts to issue clear error messages, there is no guarantee
that it does a meaningful job unless the simulation runs fine.</p>
</div>
<div class="section" id="handling-hierarchy">
<span id="conv-meth-hier"></span><h3>Handling hierarchy<a class="headerlink" href="#handling-hierarchy" title="Permalink to this headline">¶</a></h3>
<p>Recall that conversion occurs after elaboration. A consequence is that
the converted output is non-hierarchical. In many cases, this is not an
issue. The purpose of conversion is to provide a path into a traditional
design flow by using Verilog and VHDL as a “back-end” format. Hierarchy
is quite relevant to humans, but much less so to tools.</p>
<p>However, in some cases hierarchy is desirable. For example, if you convert
a test bench you may prefer to keep its code separate from the design
under test. In other words, conversion should stop at the design under test
instance, and insert an instantiation instead.</p>
<p>There is a workaround to accomplish this with a small amount of additional
work. The workaround is to define user-defined code consisting of an
instantiation of the design under test. As discussed in <a class="reference internal" href="#conv-custom"><span class="std std-ref">User-defined code</span></a>,
when the converter sees the hook it will stop converting and insert the
instantiation instead. Of course, you will want to convert the design
under test itself also. Therefore, you should use a flag that controls
whether the hook is defined or not and set it according to the
desired conversion.</p>
</div>
</div>
<div class="section" id="known-issues">
<span id="conv-issues"></span><h2>Known issues<a class="headerlink" href="#known-issues" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Verilog and VHDL integers are 32 bit wide</dt>
<dd>Usually, Verilog and VHDL integers are 32 bit wide. In contrast,
Python is moving toward integers with undefined width. Python
<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> and <code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code> variables are mapped to Verilog
integers; so for values wider than 32 bit this mapping is
incorrect.</dd>
<dt>Synthesis pragmas are specified as Verilog comments.</dt>
<dd>The recommended way to specify synthesis pragmas in Verilog is
through attribute lists. However, the Icarus simulator doesn’t
support them for <code class="docutils literal notranslate"><span class="pre">case</span></code> statements (to specify <code class="docutils literal notranslate"><span class="pre">parallel_case</span></code>
and <code class="docutils literal notranslate"><span class="pre">full_case</span></code> pragmas). Therefore, the old but deprecated
method of synthesis pragmas in Verilog comments is still used.</dd>
<dt>Inconsistent place of the sensitivity list inferred from <code class="docutils literal notranslate"><span class="pre">always_comb</span></code>.</dt>
<dd>The semantics of <code class="docutils literal notranslate"><span class="pre">always_comb</span></code>, both in Verilog and MyHDL, is to
have an implicit sensitivity list at the end of the code. However,
this may not be synthesizable. Therefore, the inferred sensitivity
list is put at the top of the corresponding <code class="docutils literal notranslate"><span class="pre">always</span></code> block or
<code class="docutils literal notranslate"><span class="pre">process</span></code>. This may cause inconsistent behavior at the start of
the simulation. The workaround is to create events at time 0.</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/manual/conversion.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>