
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Conversion examples &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reference" href="reference.html" />
    <link rel="prev" title="Conversion to Verilog and VHDL" href="conversion.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The MyHDL manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="preface.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="background.html">Background information</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction to MyHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="hwtypes.html">Hardware-oriented types</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure.html">Structural modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="rtl.html">RTL modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="highlevel.html">High level modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="unittest.html">Unit testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="cosimulation.html">Co-simulation with Verilog</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion.html">Conversion to Verilog and VHDL</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Conversion examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.6.html">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.5.html">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.4.html">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.3.html">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">The MyHDL manual</a><ul>
      <li>Previous: <a href="conversion.html" title="previous chapter">Conversion to Verilog and VHDL</a></li>
      <li>Next: <a href="reference.html" title="next chapter">Reference</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="conversion-examples">
<span id="conv-usage"></span><h1>Conversion examples<a class="headerlink" href="#conversion-examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="conv-usage-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this chapter, we will demonstrate the conversion process with a
number of examples. For the concepts of MyHDL conversion,
read the companion chapter <a class="reference internal" href="conversion.html#conv"><span class="std std-ref">Conversion to Verilog and VHDL</span></a>.</p>
</div>
<div class="section" id="a-small-sequential-design">
<span id="conv-usage-seq"></span><h2>A small sequential design<a class="headerlink" href="#a-small-sequential-design" title="Permalink to this headline">¶</a></h2>
<p>Consider the following MyHDL code for an incrementer block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">always_seq</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Incrementer with enable.</span>

<span class="sd">    count -- output</span>
<span class="sd">    enable -- control input, increment when 1</span>
<span class="sd">    clock -- clock input</span>
<span class="sd">    reset -- asynchronous reset input</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="nd">@always_seq</span><span class="p">(</span><span class="n">clock</span><span class="o">.</span><span class="n">posedge</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="n">reset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">seq</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">enable</span><span class="p">:</span>
            <span class="n">count</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">seq</span>
</pre></div>
</div>
<p>This design can be converted to Verilog and VHDL. The first step is to elaborate
it, just as we do for simulation. Then we can use the <code class="xref py py-func docutils literal notranslate"><span class="pre">convert</span></code> method on
the elaborated instance.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">ResetSignal</span><span class="p">,</span> <span class="n">modbv</span>

<span class="kn">from</span> <span class="nn">inc</span> <span class="k">import</span> <span class="n">inc</span>

<span class="k">def</span> <span class="nf">convert_inc</span><span class="p">(</span><span class="n">hdl</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert inc block to Verilog or VHDL.&quot;&quot;&quot;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="mi">8</span>

    <span class="n">count</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">modbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">m</span><span class="p">:])</span>
    <span class="n">enable</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">clock</span>  <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">reset</span> <span class="o">=</span> <span class="n">ResetSignal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">isasync</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">inc_1</span> <span class="o">=</span> <span class="n">inc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>

    <span class="n">inc_1</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="n">hdl</span><span class="p">)</span>


<span class="n">convert_inc</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="s1">&#39;Verilog&#39;</span><span class="p">)</span>
<span class="n">convert_inc</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="s1">&#39;VHDL&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For flexibility, we wrap the conversion in a <code class="xref py py-func docutils literal notranslate"><span class="pre">convert_inc</span></code> function.
<code class="docutils literal notranslate"><span class="pre">inc_1</span></code> is an elaborated design instance that provides the conversion
method.</p>
<p>The conversion to Verilog generates an equivalent Verilog module in file
<code class="file docutils literal notranslate"><span class="pre">inc.v</span></code>. The Verilog code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// File: inc.v
// Generated by MyHDL 1.0dev
// Date: Sun May 22 18:46:37 2016


`timescale 1ns/10ps

module inc (
    count,
    enable,
    clock,
    reset
);
// Incrementer with enable.
// 
// count -- output
// enable -- control input, increment when 1
// clock -- clock input
// reset -- asynchronous reset input

output [7:0] count;
reg [7:0] count;
input enable;
input clock;
input reset;



always @(posedge clock, negedge reset) begin: INC_SEQ
    if (reset == 0) begin
        count &lt;= 0;
    end
    else begin
        if (enable) begin
            count &lt;= (count + 1);
        end
    end
end

endmodule
</pre></div>
</div>
<p>The converter infers a proper Verilog module interface and maps the MyHDL
generator to a Verilog always block.</p>
<p>Similarly, the conversion to VHDL generates a file <code class="file docutils literal notranslate"><span class="pre">inc.vhd</span></code> with  the
following content:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span> <span class="n">File</span><span class="p">:</span> <span class="n">inc</span><span class="o">.</span><span class="n">vhd</span>
<span class="o">--</span> <span class="n">Generated</span> <span class="n">by</span> <span class="n">MyHDL</span> <span class="mf">1.0</span><span class="n">dev</span>
<span class="o">--</span> <span class="n">Date</span><span class="p">:</span> <span class="n">Sun</span> <span class="n">May</span> <span class="mi">22</span> <span class="mi">18</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">37</span> <span class="mi">2016</span>


<span class="n">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">std</span><span class="o">.</span><span class="n">textio</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_myhdl_10</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">entity</span> <span class="n">inc</span> <span class="ow">is</span>
    <span class="n">port</span> <span class="p">(</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">inout</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">enable</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">clock</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">reset</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span>
    <span class="p">);</span>
<span class="n">end</span> <span class="n">entity</span> <span class="n">inc</span><span class="p">;</span>
<span class="o">--</span> <span class="n">Incrementer</span> <span class="k">with</span> <span class="n">enable</span><span class="o">.</span>
<span class="o">--</span> 
<span class="o">--</span> <span class="n">count</span> <span class="o">--</span> <span class="n">output</span>
<span class="o">--</span> <span class="n">enable</span> <span class="o">--</span> <span class="n">control</span> <span class="nb">input</span><span class="p">,</span> <span class="n">increment</span> <span class="n">when</span> <span class="mi">1</span>
<span class="o">--</span> <span class="n">clock</span> <span class="o">--</span> <span class="n">clock</span> <span class="nb">input</span>
<span class="o">--</span> <span class="n">reset</span> <span class="o">--</span> <span class="n">asynchronous</span> <span class="n">reset</span> <span class="nb">input</span>

<span class="n">architecture</span> <span class="n">MyHDL</span> <span class="n">of</span> <span class="n">inc</span> <span class="ow">is</span>



<span class="n">begin</span>




<span class="n">INC_SEQ</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">to_unsigned</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">elsif</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span> <span class="n">then</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="n">then</span>
            <span class="n">count</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">INC_SEQ</span><span class="p">;</span>

<span class="n">end</span> <span class="n">architecture</span> <span class="n">MyHDL</span><span class="p">;</span>
</pre></div>
</div>
<p>The MyHDL generator is mapped to a VHDL process in this case.</p>
<p>Note that the VHDL file refers to a VHDL package called
<code class="docutils literal notranslate"><span class="pre">pck_myhdl_&lt;version&gt;</span></code>.  This package contains a number of convenience
functions that make the conversion easier.</p>
<p>Note also the use of an <code class="docutils literal notranslate"><span class="pre">inout</span></code> in the interface.  This is not
recommended VHDL design practice, but it is required here to have a
valid VHDL design that matches the behavior of the MyHDL design. As
this is only an issue for ports and as the converter output is
non-hierarchical, the issue is not very common and has an easy
workaround.</p>
</div>
<div class="section" id="a-small-combinatorial-design">
<span id="conv-usage-comb"></span><h2>A small combinatorial design<a class="headerlink" href="#a-small-combinatorial-design" title="Permalink to this headline">¶</a></h2>
<p>The second example is a small combinatorial design, more specifically the binary
to Gray code converter from previous chapters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">always_comb</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">bin2gray</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Gray encoder.</span>

<span class="sd">    B -- binary input </span>
<span class="sd">    G -- Gray encoded output</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">B</span>

    <span class="k">return</span> <span class="n">logic</span>

</pre></div>
</div>
<p>As before, you can create an instance and convert to Verilog and VHDL as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">intbv</span>

<span class="kn">from</span> <span class="nn">bin2gray</span> <span class="k">import</span> <span class="n">bin2gray</span>

<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">hdl</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="p">:])</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="p">:])</span>

    <span class="n">inst</span> <span class="o">=</span> <span class="n">bin2gray</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
    <span class="n">inst</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="n">hdl</span><span class="p">)</span>


<span class="n">convert</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="s1">&#39;Verilog&#39;</span><span class="p">)</span>
<span class="n">convert</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="s1">&#39;VHDL&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The generated Verilog code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// File: bin2gray.v
// Generated by MyHDL 1.0dev
// Date: Mon May 23 16:09:27 2016


`timescale 1ns/10ps

module bin2gray (
    B,
    G
);
// Gray encoder.
// 
// B -- binary input 
// G -- Gray encoded output

input [7:0] B;
output [7:0] G;
wire [7:0] G;




assign G = ((B &gt;&gt;&gt; 1) ^ B);

endmodule
</pre></div>
</div>
<p>The generated VHDL code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span> <span class="n">File</span><span class="p">:</span> <span class="n">bin2gray</span><span class="o">.</span><span class="n">vhd</span>
<span class="o">--</span> <span class="n">Generated</span> <span class="n">by</span> <span class="n">MyHDL</span> <span class="mf">1.0</span><span class="n">dev</span>
<span class="o">--</span> <span class="n">Date</span><span class="p">:</span> <span class="n">Mon</span> <span class="n">May</span> <span class="mi">23</span> <span class="mi">16</span><span class="p">:</span><span class="mi">09</span><span class="p">:</span><span class="mi">27</span> <span class="mi">2016</span>


<span class="n">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">std</span><span class="o">.</span><span class="n">textio</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_myhdl_10</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">entity</span> <span class="n">bin2gray</span> <span class="ow">is</span>
    <span class="n">port</span> <span class="p">(</span>
        <span class="n">B</span><span class="p">:</span> <span class="ow">in</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">G</span><span class="p">:</span> <span class="n">out</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">);</span>
<span class="n">end</span> <span class="n">entity</span> <span class="n">bin2gray</span><span class="p">;</span>
<span class="o">--</span> <span class="n">Gray</span> <span class="n">encoder</span><span class="o">.</span>
<span class="o">--</span> 
<span class="o">--</span> <span class="n">B</span> <span class="o">--</span> <span class="n">binary</span> <span class="nb">input</span> 
<span class="o">--</span> <span class="n">G</span> <span class="o">--</span> <span class="n">Gray</span> <span class="n">encoded</span> <span class="n">output</span>

<span class="n">architecture</span> <span class="n">MyHDL</span> <span class="n">of</span> <span class="n">bin2gray</span> <span class="ow">is</span>



<span class="n">begin</span>





<span class="n">G</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">shift_right</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="n">xor</span> <span class="n">B</span><span class="p">);</span>

<span class="n">end</span> <span class="n">architecture</span> <span class="n">MyHDL</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="a-hierarchical-design">
<span id="conv-usage-hier"></span><h2>A hierarchical design<a class="headerlink" href="#a-hierarchical-design" title="Permalink to this headline">¶</a></h2>
<p>The converter can handle designs with an arbitrarily deep hierarchy.</p>
<p>For example, suppose we want to design an incrementer with Gray code output.
Using the designs from previous sections, we can proceed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">modbv</span> 

<span class="kn">from</span> <span class="nn">bin2gray</span> <span class="k">import</span> <span class="n">bin2gray</span>
<span class="kn">from</span> <span class="nn">inc</span> <span class="k">import</span> <span class="n">inc</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">gray_inc</span><span class="p">(</span><span class="n">graycnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    
    <span class="n">bincnt</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">modbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="p">:])</span>
    
    <span class="n">inc_0</span> <span class="o">=</span> <span class="n">inc</span><span class="p">(</span><span class="n">bincnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>
    <span class="n">bin2gray_0</span> <span class="o">=</span> <span class="n">bin2gray</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="n">bincnt</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">graycnt</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">inc_0</span><span class="p">,</span> <span class="n">bin2gray_0</span>

</pre></div>
</div>
<p>According to Gray code properties, only a single bit will change in consecutive
values. However, as the <code class="docutils literal notranslate"><span class="pre">bin2gray</span></code> module is combinatorial, the output bits
may have transient glitches, which may not be desirable. To solve this, let’s
create an additional level of hierarchy and add an output register to the
design. (This will create an additional latency of a clock cycle, which may not
be acceptable, but we will ignore that here.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">always_seq</span><span class="p">,</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">modbv</span> 

<span class="kn">from</span> <span class="nn">gray_inc</span> <span class="k">import</span> <span class="n">gray_inc</span>

<span class="nd">@block</span>
<span class="k">def</span> <span class="nf">gray_inc_reg</span><span class="p">(</span><span class="n">graycnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    
    <span class="n">graycnt_comb</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">modbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="p">:])</span>
    
    <span class="n">gray_inc_0</span> <span class="o">=</span> <span class="n">gray_inc</span><span class="p">(</span><span class="n">graycnt_comb</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

    <span class="nd">@always_seq</span><span class="p">(</span><span class="n">clock</span><span class="o">.</span><span class="n">posedge</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="n">reset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reg_0</span><span class="p">():</span>
        <span class="n">graycnt</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">graycnt_comb</span>
    
    <span class="k">return</span> <span class="n">gray_inc_0</span><span class="p">,</span> <span class="n">reg_0</span>

</pre></div>
</div>
<p>We can convert this hierarchical design as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">ResetSignal</span><span class="p">,</span> <span class="n">modbv</span>

<span class="kn">from</span> <span class="nn">gray_inc_reg</span> <span class="k">import</span> <span class="n">gray_inc_reg</span>

<span class="k">def</span> <span class="nf">convert_gray_inc_reg</span><span class="p">(</span><span class="n">hdl</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">graycnt</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">modbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="p">:])</span>
    <span class="n">enable</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">())</span>
    <span class="n">clock</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">())</span>
    <span class="n">reset</span> <span class="o">=</span> <span class="n">ResetSignal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">isasync</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">inst</span> <span class="o">=</span> <span class="n">gray_inc_reg</span><span class="p">(</span><span class="n">graycnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
    <span class="n">inst</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">hdl</span><span class="p">)</span>

<span class="n">convert_gray_inc_reg</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="s1">&#39;Verilog&#39;</span><span class="p">)</span>
<span class="n">convert_gray_inc_reg</span><span class="p">(</span><span class="n">hdl</span><span class="o">=</span><span class="s1">&#39;VHDL&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The Verilog output code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// File: gray_inc_reg.v
// Generated by MyHDL 1.0dev
// Date: Thu Jun 23 19:06:43 2016


`timescale 1ns/10ps

module gray_inc_reg (
    graycnt,
    enable,
    clock,
    reset
);


output [7:0] graycnt;
reg [7:0] graycnt;
input enable;
input clock;
input reset;

wire [7:0] graycnt_comb;
reg [7:0] gray_inc_1_bincnt;



always @(posedge clock, negedge reset) begin: GRAY_INC_REG_GRAY_INC_1_INC_1_SEQ
    if (reset == 0) begin
        gray_inc_1_bincnt &lt;= 0;
    end
    else begin
        if (enable) begin
            gray_inc_1_bincnt &lt;= (gray_inc_1_bincnt + 1);
        end
    end
end



assign graycnt_comb = ((gray_inc_1_bincnt &gt;&gt;&gt; 1) ^ gray_inc_1_bincnt);


always @(posedge clock, negedge reset) begin: GRAY_INC_REG_REG_0
    if (reset == 0) begin
        graycnt &lt;= 0;
    end
    else begin
        graycnt &lt;= graycnt_comb;
    end
end

endmodule
</pre></div>
</div>
<p>The VHDL output code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span> <span class="n">File</span><span class="p">:</span> <span class="n">gray_inc_reg</span><span class="o">.</span><span class="n">vhd</span>
<span class="o">--</span> <span class="n">Generated</span> <span class="n">by</span> <span class="n">MyHDL</span> <span class="mf">1.0</span><span class="n">dev</span>
<span class="o">--</span> <span class="n">Date</span><span class="p">:</span> <span class="n">Thu</span> <span class="n">Jun</span> <span class="mi">23</span> <span class="mi">19</span><span class="p">:</span><span class="mi">06</span><span class="p">:</span><span class="mi">43</span> <span class="mi">2016</span>


<span class="n">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">std</span><span class="o">.</span><span class="n">textio</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_myhdl_10</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">entity</span> <span class="n">gray_inc_reg</span> <span class="ow">is</span>
    <span class="n">port</span> <span class="p">(</span>
        <span class="n">graycnt</span><span class="p">:</span> <span class="n">out</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">enable</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">clock</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">reset</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span>
    <span class="p">);</span>
<span class="n">end</span> <span class="n">entity</span> <span class="n">gray_inc_reg</span><span class="p">;</span>


<span class="n">architecture</span> <span class="n">MyHDL</span> <span class="n">of</span> <span class="n">gray_inc_reg</span> <span class="ow">is</span>


<span class="n">signal</span> <span class="n">graycnt_comb</span><span class="p">:</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">signal</span> <span class="n">gray_inc_1_bincnt</span><span class="p">:</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">begin</span>




<span class="n">GRAY_INC_REG_GRAY_INC_1_INC_1_SEQ</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">gray_inc_1_bincnt</span> <span class="o">&lt;=</span> <span class="n">to_unsigned</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">elsif</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span> <span class="n">then</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="n">then</span>
            <span class="n">gray_inc_1_bincnt</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">gray_inc_1_bincnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">GRAY_INC_REG_GRAY_INC_1_INC_1_SEQ</span><span class="p">;</span>


<span class="n">graycnt_comb</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">shift_right</span><span class="p">(</span><span class="n">gray_inc_1_bincnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="n">xor</span> <span class="n">gray_inc_1_bincnt</span><span class="p">);</span>

<span class="n">GRAY_INC_REG_REG_0</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">graycnt</span> <span class="o">&lt;=</span> <span class="n">to_unsigned</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">elsif</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">graycnt</span> <span class="o">&lt;=</span> <span class="n">graycnt_comb</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">GRAY_INC_REG_REG_0</span><span class="p">;</span>

<span class="n">end</span> <span class="n">architecture</span> <span class="n">MyHDL</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the output is a flat “net list of blocks”, and that hierarchical
signal names are generated as necessary.</p>
</div>
<div class="section" id="optimizations-for-finite-state-machines">
<span id="conv-usage-fsm"></span><h2>Optimizations for finite state machines<a class="headerlink" href="#optimizations-for-finite-state-machines" title="Permalink to this headline">¶</a></h2>
<p>As often in hardware design, finite state machines deserve special attention.</p>
<p>In Verilog and VHDL, finite state machines are typically described using case
statements.  Python doesn’t have a case statement, but the converter recognizes
particular if-then-else structures and maps them to case statements. This
optimization occurs when a variable whose type is an enumerated type is
sequentially tested against enumeration items in an if-then-else structure.
Also, the appropriate synthesis pragmas for efficient synthesis are generated in
the Verilog code.</p>
<p>As a further optimization, function <a class="reference internal" href="reference.html#myhdl.enum" title="myhdl.enum"><code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code></a> was enhanced to support
alternative encoding schemes elegantly, using an additional parameter
<em>encoding</em>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t_State</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="s1">&#39;SEARCH&#39;</span><span class="p">,</span> <span class="s1">&#39;CONFIRM&#39;</span><span class="p">,</span> <span class="s1">&#39;SYNC&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;one_hot&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The default encoding is <code class="docutils literal notranslate"><span class="pre">'binary'</span></code>; the other possibilities are <code class="docutils literal notranslate"><span class="pre">'one_hot'</span></code>
and <code class="docutils literal notranslate"><span class="pre">'one_cold'</span></code>. This parameter only affects the conversion output, not the
behavior of the type.  The generated Verilog code for case statements is
optimized for an efficient implementation according to the encoding. Note that
in contrast, a Verilog designer has to make nontrivial code changes to implement
a different encoding scheme.</p>
<p>As an example, consider the following finite state machine, whose state variable
uses the enumeration type defined above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ACTIVE_LOW</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">FRAME_SIZE</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">t_State</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="s1">&#39;SEARCH&#39;</span><span class="p">,</span> <span class="s1">&#39;CONFIRM&#39;</span><span class="p">,</span> <span class="s1">&#39;SYNC&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;one_hot&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">FramerCtrl</span><span class="p">(</span><span class="n">SOF</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">syncFlag</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset_n</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Framing control FSM.</span>

<span class="sd">    SOF -- start-of-frame output bit</span>
<span class="sd">    state -- FramerState output</span>
<span class="sd">    syncFlag -- sync pattern found indication input</span>
<span class="sd">    clk -- clock input</span>
<span class="sd">    reset_n -- active low reset</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:])</span> <span class="c1"># position in frame</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">,</span> <span class="n">reset_n</span><span class="o">.</span><span class="n">negedge</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">FSM</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">reset_n</span> <span class="o">==</span> <span class="n">ACTIVE_LOW</span><span class="p">:</span>
            <span class="n">SOF</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">index</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">FRAME_SIZE</span>
            <span class="n">SOF</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">syncFlag</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">CONFIRM</span>
            <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="n">t_State</span><span class="o">.</span><span class="n">CONFIRM</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">syncFlag</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SYNC</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span>
            <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SYNC</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">syncFlag</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span>
                <span class="n">SOF</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">FRAME_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Undefined state&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">FSM</span>
</pre></div>
</div>
<p>The conversion is done as before:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SOF</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">syncFlag</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">clk</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">reset_n</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span><span class="p">)</span>
<span class="n">toVerilog</span><span class="p">(</span><span class="n">FramerCtrl</span><span class="p">,</span> <span class="n">SOF</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">syncFlag</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset_n</span><span class="p">)</span>
<span class="n">toVHDL</span><span class="p">(</span><span class="n">FramerCtrl</span><span class="p">,</span> <span class="n">SOF</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">syncFlag</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset_n</span><span class="p">)</span>
</pre></div>
</div>
<p>The Verilog output looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>module FramerCtrl (
    SOF,
    state,
    syncFlag,
    clk,
    reset_n
);

output SOF;
reg SOF;
output [2:0] state;
reg [2:0] state;
input syncFlag;
input clk;
input reset_n;

reg [7:0] index;



always @(posedge clk, negedge reset_n) begin: FRAMERCTRL_FSM
    if ((reset_n == 0)) begin
        SOF &lt;= 0;
        index &lt;= 0;
        state &lt;= 3&#39;b001;
    end
    else begin
        index &lt;= ((index + 1) % 8);
        SOF &lt;= 0;
        // synthesis parallel_case full_case
        casez (state)
            3&#39;b??1: begin
                index &lt;= 1;
                if (syncFlag) begin
                    state &lt;= 3&#39;b010;
                end
            end
            3&#39;b?1?: begin
                if ((index == 0)) begin
                    if (syncFlag) begin
                        state &lt;= 3&#39;b100;
                    end
                    else begin
                        state &lt;= 3&#39;b001;
                    end
                end
            end
            3&#39;b1??: begin
                if ((index == 0)) begin
                    if ((!syncFlag)) begin
                        state &lt;= 3&#39;b001;
                    end
                end
                SOF &lt;= (index == (8 - 1));
            end
            default: begin
                $finish;
            end
        endcase
    end
end

endmodule
</pre></div>
</div>
<p>The VHDL output looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">pck_FramerCtrl</span> <span class="ow">is</span>

    <span class="nb">type</span> <span class="n">t_enum_t_State_1</span> <span class="ow">is</span> <span class="p">(</span>
    <span class="n">SEARCH</span><span class="p">,</span>
    <span class="n">CONFIRM</span><span class="p">,</span>
    <span class="n">SYNC</span>
<span class="p">);</span>
<span class="n">attribute</span> <span class="n">enum_encoding</span> <span class="n">of</span> <span class="n">t_enum_t_State_1</span><span class="p">:</span> <span class="nb">type</span> <span class="ow">is</span> <span class="s2">&quot;001 010 100&quot;</span><span class="p">;</span>

<span class="n">end</span> <span class="n">package</span> <span class="n">pck_FramerCtrl</span><span class="p">;</span>

<span class="n">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">std</span><span class="o">.</span><span class="n">textio</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_myhdl_06</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_FramerCtrl</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">entity</span> <span class="n">FramerCtrl</span> <span class="ow">is</span>
    <span class="n">port</span> <span class="p">(</span>
        <span class="n">SOF</span><span class="p">:</span> <span class="n">out</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">inout</span> <span class="n">t_enum_t_State_1</span><span class="p">;</span>
        <span class="n">syncFlag</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">clk</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">reset_n</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span>
    <span class="p">);</span>
<span class="n">end</span> <span class="n">entity</span> <span class="n">FramerCtrl</span><span class="p">;</span>

<span class="n">architecture</span> <span class="n">MyHDL</span> <span class="n">of</span> <span class="n">FramerCtrl</span> <span class="ow">is</span>

<span class="n">signal</span> <span class="n">index</span><span class="p">:</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">begin</span>


<span class="n">FRAMERCTRL_FSM</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">reset_n</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset_n</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">SOF</span> <span class="o">&lt;=</span> <span class="s1">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">index</span> <span class="o">&lt;=</span> <span class="s2">&quot;00000000&quot;</span><span class="p">;</span>
        <span class="n">state</span> <span class="o">&lt;=</span> <span class="n">SEARCH</span><span class="p">;</span>
    <span class="n">elsif</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">index</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="mi">8</span><span class="p">);</span>
        <span class="n">SOF</span> <span class="o">&lt;=</span> <span class="s1">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">case</span> <span class="n">state</span> <span class="ow">is</span>
            <span class="n">when</span> <span class="n">SEARCH</span> <span class="o">=&gt;</span>
                <span class="n">index</span> <span class="o">&lt;=</span> <span class="s2">&quot;00000001&quot;</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">to_boolean</span><span class="p">(</span><span class="n">syncFlag</span><span class="p">)</span> <span class="n">then</span>
                    <span class="n">state</span> <span class="o">&lt;=</span> <span class="n">CONFIRM</span><span class="p">;</span>
                <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
            <span class="n">when</span> <span class="n">CONFIRM</span> <span class="o">=&gt;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">then</span>
                    <span class="k">if</span> <span class="n">to_boolean</span><span class="p">(</span><span class="n">syncFlag</span><span class="p">)</span> <span class="n">then</span>
                        <span class="n">state</span> <span class="o">&lt;=</span> <span class="n">SYNC</span><span class="p">;</span>
                    <span class="k">else</span>
                        <span class="n">state</span> <span class="o">&lt;=</span> <span class="n">SEARCH</span><span class="p">;</span>
                    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
                <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
            <span class="n">when</span> <span class="n">SYNC</span> <span class="o">=&gt;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">then</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">to_boolean</span><span class="p">(</span><span class="n">syncFlag</span><span class="p">))</span> <span class="n">then</span>
                        <span class="n">state</span> <span class="o">&lt;=</span> <span class="n">SEARCH</span><span class="p">;</span>
                    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
                <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
                <span class="n">SOF</span> <span class="o">&lt;=</span> <span class="n">to_std_logic</span><span class="p">(</span><span class="n">signed</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">when</span> <span class="n">others</span> <span class="o">=&gt;</span>
                <span class="k">assert</span> <span class="kc">False</span> <span class="n">report</span> <span class="s2">&quot;End of Simulation&quot;</span> <span class="n">severity</span> <span class="n">Failure</span><span class="p">;</span>
        <span class="n">end</span> <span class="n">case</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">FRAMERCTRL_FSM</span><span class="p">;</span>

<span class="n">end</span> <span class="n">architecture</span> <span class="n">MyHDL</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="ram-inference">
<span id="conv-usage-ram"></span><h2>RAM inference<a class="headerlink" href="#ram-inference" title="Permalink to this headline">¶</a></h2>
<p>Certain synthesis tools can infer RAM structures. To support
this feature, the converter maps lists of signals in MyHDL
to Verilog memories and VHDL arrays.</p>
<p>The following MyHDL example is a ram model that uses a list of signals to model
the internal memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RAM</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">din</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">we</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  Ram model &quot;&quot;&quot;</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">)]</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">we</span><span class="p">:</span>
            <span class="n">mem</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">din</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
        <span class="n">dout</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">write</span><span class="p">,</span> <span class="n">read</span>
</pre></div>
</div>
<p>With the appropriate signal definitions for the interface ports, it is converted
to the following Verilog code. Note how the list of signals <code class="docutils literal notranslate"><span class="pre">mem</span></code> is mapped to
a Verilog memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">ram</span> <span class="p">(</span>
    <span class="n">dout</span><span class="p">,</span>
    <span class="n">din</span><span class="p">,</span>
    <span class="n">addr</span><span class="p">,</span>
    <span class="n">we</span><span class="p">,</span>
    <span class="n">clk</span>
<span class="p">);</span>

<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="n">wire</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="nb">input</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">din</span><span class="p">;</span>
<span class="nb">input</span> <span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">we</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">clk</span><span class="p">;</span>


<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">mem</span> <span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">128</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>


<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">RAM_1_WRITE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">we</span><span class="p">)</span> <span class="n">begin</span>
        <span class="n">mem</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">din</span><span class="p">;</span>
    <span class="n">end</span>
<span class="n">end</span>


<span class="n">assign</span> <span class="n">dout</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>

<span class="n">endmodule</span>
</pre></div>
</div>
<p>In VHDL, the list of MyHDL signals is modeled as a VHDL array signal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_myhdl_06</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">entity</span> <span class="n">ram</span> <span class="ow">is</span>
    <span class="n">port</span> <span class="p">(</span>
        <span class="n">dout</span><span class="p">:</span> <span class="n">out</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">din</span><span class="p">:</span> <span class="ow">in</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">addr</span><span class="p">:</span> <span class="ow">in</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">6</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">we</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
        <span class="n">clk</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span>
    <span class="p">);</span>
<span class="n">end</span> <span class="n">entity</span> <span class="n">ram</span><span class="p">;</span>

<span class="n">architecture</span> <span class="n">MyHDL</span> <span class="n">of</span> <span class="n">ram</span> <span class="ow">is</span>

<span class="nb">type</span> <span class="n">t_array_mem</span> <span class="ow">is</span> <span class="n">array</span><span class="p">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">128</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">of</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">signal</span> <span class="n">mem</span><span class="p">:</span> <span class="n">t_array_mem</span><span class="p">;</span>

<span class="n">begin</span>

<span class="n">RAM_WRITE</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="n">then</span>
        <span class="k">if</span> <span class="n">to_boolean</span><span class="p">(</span><span class="n">we</span><span class="p">)</span> <span class="n">then</span>
            <span class="n">mem</span><span class="p">(</span><span class="n">to_integer</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">din</span><span class="p">;</span>
        <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">RAM_WRITE</span><span class="p">;</span>


<span class="n">dout</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">(</span><span class="n">to_integer</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

<span class="n">end</span> <span class="n">architecture</span> <span class="n">MyHDL</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rom-inference">
<span id="conv-usage-rom"></span><h2>ROM inference<a class="headerlink" href="#rom-inference" title="Permalink to this headline">¶</a></h2>
<p>Some synthesis tools can infer a ROM memory from a case statement. The Verilog
converter can perform the expansion into a case statement automatically, based
on a higher level description. The ROM access is described in a single line, by
indexing into a tuple of integers. The tuple can be described manually, but also
by programmatical means. Note that a tuple is used instead of a list to stress
the read-only character of the memory.</p>
<p>The following example illustrates this functionality. ROM access is described as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rom</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">CONTENT</span><span class="p">):</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
        <span class="n">dout</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">CONTENT</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">read</span>
</pre></div>
</div>
<p>The ROM content is described as a tuple of integers. When the ROM content is
defined, the conversion can be performed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CONTENT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">134</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">dout</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:])</span>
<span class="n">addr</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">4</span><span class="p">:])</span>

<span class="n">toVerilog</span><span class="p">(</span><span class="n">rom</span><span class="p">,</span> <span class="n">dout</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">CONTENT</span><span class="p">)</span>
<span class="n">toVHDL</span><span class="p">(</span><span class="n">rom</span><span class="p">,</span> <span class="n">dout</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">CONTENT</span><span class="p">)</span>
</pre></div>
</div>
<p>The Verilog output code is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">rom</span> <span class="p">(</span>
    <span class="n">dout</span><span class="p">,</span>
    <span class="n">addr</span>
<span class="p">);</span>

<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="nb">input</span> <span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">;</span>

<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">ROM_READ</span>
    <span class="o">//</span> <span class="n">synthesis</span> <span class="n">parallel_case</span> <span class="n">full_case</span>
    <span class="n">case</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="mi">0</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">17</span><span class="p">;</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">134</span><span class="p">;</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">52</span><span class="p">;</span>
        <span class="n">default</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">endcase</span>
<span class="n">end</span>

<span class="n">endmodule</span>
</pre></div>
</div>
<p>The VHDL output code is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">std</span><span class="o">.</span><span class="n">textio</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_myhdl_06</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">entity</span> <span class="n">rom</span> <span class="ow">is</span>
    <span class="n">port</span> <span class="p">(</span>
        <span class="n">dout</span><span class="p">:</span> <span class="n">out</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">addr</span><span class="p">:</span> <span class="ow">in</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">3</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">);</span>
<span class="n">end</span> <span class="n">entity</span> <span class="n">rom</span><span class="p">;</span>

<span class="n">architecture</span> <span class="n">MyHDL</span> <span class="n">of</span> <span class="n">rom</span> <span class="ow">is</span>


<span class="n">begin</span>

<span class="n">ROM_READ</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="n">case</span> <span class="n">to_integer</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="ow">is</span>
        <span class="n">when</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="s2">&quot;00010001&quot;</span><span class="p">;</span>
        <span class="n">when</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="s2">&quot;10000110&quot;</span><span class="p">;</span>
        <span class="n">when</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="s2">&quot;00110100&quot;</span><span class="p">;</span>
        <span class="n">when</span> <span class="n">others</span> <span class="o">=&gt;</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="s2">&quot;00001001&quot;</span><span class="p">;</span>
    <span class="n">end</span> <span class="n">case</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">ROM_READ</span><span class="p">;</span>

<span class="n">end</span> <span class="n">architecture</span> <span class="n">MyHDL</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="user-defined-code">
<span id="conv-usage-custom"></span><span id="index-0"></span><h2>User-defined code<a class="headerlink" href="#user-defined-code" title="Permalink to this headline">¶</a></h2>
<p>MyHDL provides a way to include user-defined code during the
conversion process, using the special function attributes
<code class="xref py py-attr docutils literal notranslate"><span class="pre">vhdl_code</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">verilog_code</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">inc_comb</span><span class="p">(</span><span class="n">nextCount</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="c1"># do nothing here</span>
        <span class="k">pass</span>

    <span class="n">nextCount</span><span class="o">.</span><span class="n">driven</span> <span class="o">=</span> <span class="s2">&quot;wire&quot;</span>

    <span class="k">return</span> <span class="n">logic</span>

<span class="n">inc_comb</span><span class="o">.</span><span class="n">verilog_code</span> <span class="o">=</span>\
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">assign $nextCount = ($count + 1) % $n;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">inc_comb</span><span class="o">.</span><span class="n">vhdl_code</span> <span class="o">=</span>\
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">$nextCount &lt;= ($count + 1) mod $n;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>The converted code looks as follows in Verilog:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">inc_comb</span> <span class="p">(</span>
    <span class="n">nextCount</span><span class="p">,</span>
    <span class="n">count</span>
<span class="p">);</span>

<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">nextCount</span><span class="p">;</span>
<span class="n">wire</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">nextCount</span><span class="p">;</span>
<span class="nb">input</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">count</span><span class="p">;</span>

<span class="n">assign</span> <span class="n">nextCount</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>

<span class="n">endmodule</span>
</pre></div>
</div>
<p>and as follows in VHDL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">library</span> <span class="n">IEEE</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">numeric_std</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">use</span> <span class="n">work</span><span class="o">.</span><span class="n">pck_myhdl_06</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>

<span class="n">entity</span> <span class="n">inc_comb</span> <span class="ow">is</span>
    <span class="n">port</span> <span class="p">(</span>
        <span class="n">nextCount</span><span class="p">:</span> <span class="n">out</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">count</span><span class="p">:</span> <span class="ow">in</span> <span class="n">unsigned</span><span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">);</span>
<span class="n">end</span> <span class="n">entity</span> <span class="n">inc_comb</span><span class="p">;</span>

<span class="n">architecture</span> <span class="n">MyHDL</span> <span class="n">of</span> <span class="n">inc_comb</span> <span class="ow">is</span>

<span class="n">begin</span>

<span class="n">nextCount</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="mi">256</span><span class="p">;</span>

<span class="n">end</span> <span class="n">architecture</span> <span class="n">MyHDL</span><span class="p">;</span>
</pre></div>
</div>
<p>In this example, conversion of the <code class="xref py py-func docutils literal notranslate"><span class="pre">inc_comb</span></code> function is
bypassed and the user-defined code is inserted instead. The
user-defined code is a Python template string that
can refer to signals and parameters in the MyHDL
context through <code class="docutils literal notranslate"><span class="pre">$</span></code>-based substitutions.
During conversion, the appropriate
hierarchical names and parameter values will be substituted.</p>
<p>The MyHDL code contains the following assignment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nextCount</span><span class="o">.</span><span class="n">driven</span> <span class="o">=</span> <span class="s2">&quot;wire&quot;</span>
</pre></div>
</div>
<p>This specifies that the nextCount signal is driven as a Verilog wire from this
module.</p>
<p>For more info about user-defined code, see <a class="reference internal" href="conversion.html#conv-custom"><span class="std std-ref">User-defined code</span></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/manual/conversion_examples.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>