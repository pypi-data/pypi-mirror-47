
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Hardware-oriented types &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Structural modeling" href="structure.html" />
    <link rel="prev" title="Introduction to MyHDL" href="intro.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The MyHDL manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="preface.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="background.html">Background information</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction to MyHDL</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Hardware-oriented types</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure.html">Structural modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="rtl.html">RTL modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="highlevel.html">High level modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="unittest.html">Unit testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="cosimulation.html">Co-simulation with Verilog</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion.html">Conversion to Verilog and VHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion_examples.html">Conversion examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.6.html">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.5.html">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.4.html">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/0.3.html">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">The MyHDL manual</a><ul>
      <li>Previous: <a href="intro.html" title="previous chapter">Introduction to MyHDL</a></li>
      <li>Next: <a href="structure.html" title="next chapter">Structural modeling</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="hardware-oriented-types">
<span id="hwtypes"></span><h1>Hardware-oriented types<a class="headerlink" href="#hardware-oriented-types" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-intbv-class">
<span id="hwtypes-intbv"></span><h2>The <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> class<a class="headerlink" href="#the-intbv-class" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Hardware design involves dealing with bits and bit-oriented operations. The
standard Python type <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> has most of the desired features, but lacks
support for indexing and slicing. For this reason, MyHDL provides the
<a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> class. The name was chosen to suggest an integer with bit vector
flavor.</p>
<p><a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> works transparently with other integer-like types. Like
class <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, it provides access to the underlying two’s complement
representation for bitwise operations. However, unlike <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, it is
a mutable type. This means that its value can be changed after object
creation, through methods and operators such as slice assignment.</p>
<p><a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> supports the same operators as <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> for arithmetic. In
addition, it provides a number of features to make it suitable for hardware
design. First, the range of allowed values can be constrained. This makes it
possible to check the value at run time during simulation. Moreover, back end
tools can determine the smallest possible bit width for representing the object.
Secondly, it supports bit level operations by providing an indexing and slicing
interface.</p>
<p><a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects are constructed in general as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">intbv</span><span class="p">([</span><span class="n">val</span><span class="o">=</span><span class="kc">None</span><span class="p">]</span> <span class="p">[,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">]</span>  <span class="p">[,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">])</span>
</pre></div>
</div>
<p><em>val</em> is the initial value. <em>min</em> and <em>max</em> can be used to constrain
the value. Following the Python conventions, <em>min</em> is inclusive, and
<em>max</em> is exclusive. Therefore, the allowed value range is <em>min</em> .. <em>max</em>-1.</p>
<p>Let’s look at some examples. An unconstrained <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object is created
as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-1">After object creation, <em>min</em> and <em>max</em> are available as attributes for
inspection. Also, the standard Python function <a class="reference external" href="https://docs.python.org/3/library/functions.html#len" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">len</span></code></a> can be used
to determine the bit width. If we inspect the previously created
object, we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">intbv(24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>As the instantiation was unconstrained, the <em>min</em> and <em>max</em> attributes
are undefined. Likewise, the bit width is undefined, which is indicated
by a return value <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>A constrained <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object is created as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>Inspecting the object now gives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">intbv(24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">min</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">max</span>
<span class="go">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>We see that the allowed value range is 0 .. 24,  and that 5 bits are
required to represent the object.</p>
<p>The <em>min</em> and <em>max</em> bound attributes enable fine-grained control and error
checking of the value range. In particular, the bound values do not have to be
symmetric or powers of 2. In all cases, the bit width is set appropriately to
represent the values in the range. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="mi">13</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</div>
<div class="section" id="bit-indexing">
<span id="hwtypes-indexing"></span><h2>Bit indexing<a class="headerlink" href="#bit-indexing" title="Permalink to this headline">¶</a></h2>
<p id="index-2">A common requirement in hardware design is access to the individual bits. The
<a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> class implements an indexing interface that provides access to
the bits of the underlying two’s complement representation. The following
illustrates bit index read access:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="nb">bin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;11000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&#39;101001&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<p>We use the <a class="reference internal" href="reference.html#myhdl.bin" title="myhdl.bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin</span></code></a> function provide by MyHDL because it shows the two’s
complement representation for negative values, unlike Python’s builtin with the
same name. Note that lower indices correspond to less significant bits. The
following code illustrates bit index assignment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;11000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;10000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">intbv(16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">intbv(-23)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&#39;101001&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&#39;100001&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">intbv(-31)</span>
</pre></div>
</div>
</div>
<div class="section" id="bit-slicing">
<span id="hwtypes-slicing"></span><h2>Bit slicing<a class="headerlink" href="#bit-slicing" title="Permalink to this headline">¶</a></h2>
<p id="index-3">The <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> type also supports bit slicing, for both read access
assignment. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;11000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">intbv(4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
<span class="go">&#39;100&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mb">0b001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;10010&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">intbv(18)</span>
</pre></div>
</div>
<p>In accordance with the most common hardware convention, and unlike standard
Python, slicing ranges are downward.  As in standard Python, the slicing range
is half-open: the highest index bit is not included. Unlike standard Python
however, this index corresponds to the <em>leftmost</em> item.</p>
<p>Both indices can be omitted from the slice.  If the rightmost index is omitted,
it is <code class="docutils literal notranslate"><span class="pre">0</span></code> by default. If the leftmost index is omitted, the meaning is to
access “all” higher order bits. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;11000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>
<span class="go">&#39;1000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="s1">&#39;0001&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;10001&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="mb">0b10101</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;10101&#39;</span>
</pre></div>
</div>
<p>The half-openness of a slice may seem awkward at first, but it helps to avoid
one-off count issues in practice. For example, the slice <code class="docutils literal notranslate"><span class="pre">a[8:]</span></code> has exactly
<code class="docutils literal notranslate"><span class="pre">8</span></code> bits. Likewise, the slice <code class="docutils literal notranslate"><span class="pre">a[7:2]</span></code> has <code class="docutils literal notranslate"><span class="pre">7-2=5</span></code> bits. You can think
about it as follows: for a slice <code class="docutils literal notranslate"><span class="pre">[i:j]</span></code>, only bits below index <code class="docutils literal notranslate"><span class="pre">i</span></code> are
included, and the bit with index <code class="docutils literal notranslate"><span class="pre">j</span></code> is the last bit included.</p>
<p>When an <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object is sliced, a new <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object is returned.
This new <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object is always positive, and the value bounds are
set up in accordance with the bit width specified by the slice. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">intbv(6L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">min</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">max</span>
<span class="go">16</span>
</pre></div>
</div>
<p>In the example, the original object is sliced with a slice equal to its bit width.
The returned object has the same value and bit width, but its value
range consists of all positive values that can be represented by
the bit width.</p>
<p>The object returned by a slice is positive, even when the original object is
negative:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;11101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">intbv(29L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&#39;11101&#39;</span>
</pre></div>
</div>
<p>In this example, the bit pattern of the two objects is identical within the bit
width, but their values have opposite sign.</p>
<p>Sometimes hardware engineers prefer to constrain an object by defining its bit
width directly, instead of the range of allowed values. Using the slicing
properties of the <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> class one can do that as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">24</span><span class="p">)[</span><span class="mi">5</span><span class="p">:]</span>
</pre></div>
</div>
<p>What actually happens here is that first an unconstrained <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a>
is created, which is then sliced. Slicing an <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> returns a new
<a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> with the constraints set up appropriately.
Inspecting the object now shows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">min</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">max</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Note that the <em>max</em> attribute is 32, as with 5 bits it is possible to represent
the range 0 .. 31.  Creating an <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> in this way is convenient but has
the disadvantage that only positive value ranges between 0 and a power of 2 can
be specified.</p>
</div>
<div class="section" id="the-modbv-class">
<span id="hwtypes-modbv"></span><h2>The <a class="reference internal" href="reference.html#myhdl.modbv" title="myhdl.modbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">modbv</span></code></a> class<a class="headerlink" href="#the-modbv-class" title="Permalink to this headline">¶</a></h2>
<p>In hardware modeling, there is often a need for the elegant modeling of
wrap-around behavior. <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> instances do not support this
automatically, as they assert that any assigned value is within the bound
constraints. However, wrap-around modeling can be straightforward.  For
example, the wrap-around condition for a counter is often decoded explicitly,
as it is needed for other purposes. Also, the modulo operator provides an
elegant one-liner in many scenarios:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span>
</pre></div>
</div>
<p>However, some interesting cases are not supported by the <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> type.
For example, we would like to describe a free running counter using a variable
and augmented assignment as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">count_var</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This is not possible with the <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> type, as we cannot add the modulo
behavior to this description. A similar problem exist for an augmented left
shift as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shifter</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>To support these operations directly, MyHDL provides the <a class="reference internal" href="reference.html#myhdl.modbv" title="myhdl.modbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">modbv</span></code></a>
type. <a class="reference internal" href="reference.html#myhdl.modbv" title="myhdl.modbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">modbv</span></code></a> is implemented as a subclass of  <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a>.
The two classes have an identical interface and work together
in a straightforward way for arithmetic operations.
The only difference is how the bounds are handled: out-of-bound values
result in an error with <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a>, and in wrap-around with
<a class="reference internal" href="reference.html#myhdl.modbv" title="myhdl.modbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">modbv</span></code></a>. For example, the modulo counter above can be
modeled as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">modbv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">8</span><span class="p">))</span>
<span class="o">...</span>
<span class="n">count</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The wrap-around behavior is defined in general as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span>
</pre></div>
</div>
<p>In a typical case when <code class="docutils literal notranslate"><span class="pre">min==0</span></code>, this reduces to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="nb">max</span>
</pre></div>
</div>
</div>
<div class="section" id="unsigned-and-signed-representation">
<span id="hwtypes-signed"></span><h2>Unsigned and signed representation<a class="headerlink" href="#unsigned-and-signed-representation" title="Permalink to this headline">¶</a></h2>
<p id="index-4"><a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> is designed to be as high level as possible. The underlying
value of an <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object is a Python <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, which is
represented as a two’s complement number with “indefinite” bit
width. The range bounds are only used for error checking, and to
calculate the minimum required bit width for representation. As a
result, arithmetic can be performed like with normal integers.</p>
<p>In contrast, HDLs such as Verilog and VHDL typically require designers
to deal with representational issues, especially for synthesizable code.
They provide low-level types like <code class="docutils literal notranslate"><span class="pre">signed</span></code> and <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> for
arithmetic. The rules for arithmetic with such types are much more
complicated than with plain integers.</p>
<p>In some cases it can be useful to interpret <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects
in terms of “signed” and “unsigned”. Basically, it depends on attribute <em>min</em>.
if <em>min</em> &lt; 0, then the object is “signed”, otherwise it is “unsigned”.
In particular, the bit width of a “signed” object will account for
a sign bit, but that of an “unsigned” will not, because that would
be redundant. From earlier sections, we have learned that the
return value from a slicing operation is always “unsigned”.</p>
<p>In some applications, it is desirable to convert an “unsigned”
<a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> to  a “signed”, in other words, to interpret the msb bit
as a sign bit.  The msb bit is the highest order bit within the object’s
bit width.  For this purpose, <a class="reference internal" href="reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> provides the
<a class="reference internal" href="reference.html#myhdl.intbv.signed" title="myhdl.intbv.signed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intbv.signed</span></code></a> method. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1100&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">signed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">-4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;1100&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference.html#myhdl.intbv.signed" title="myhdl.intbv.signed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intbv.signed</span></code></a> extends the msb bit into the higher-order bits of the
underlying object value, and returns the result as an integer.
Naturally, for a “signed” the return value will always be identical
to the original value, as it has the sign bit already.</p>
<p>As an example let’s take a 8 bit wide data bus that would be modeled as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_bus</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:]</span>
</pre></div>
</div>
<p>Now consider that a complex number is transferred over this data
bus. The upper 4 bits of the data bus are used for the real value and
the lower 4 bits for the imaginary value. As real and imaginary values
have a positive and negative value range, we can slice them off from
the data bus and convert them as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">data_bus</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">signed</span><span class="p">()</span>
<span class="n">imag</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">data_bus</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">signed</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/manual/hwtypes.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>