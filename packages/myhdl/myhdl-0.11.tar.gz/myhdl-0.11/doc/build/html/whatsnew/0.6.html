
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What’s new in MyHDL 0.6 &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="What’s new in MyHDL 0.5" href="0.5.html" />
    <link rel="prev" title="What’s new in MyHDL 0.7" href="0.7.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">The MyHDL manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.5.html">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.4.html">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.3.html">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="0.7.html" title="previous chapter">What’s new in MyHDL 0.7</a></li>
      <li>Next: <a href="0.5.html" title="next chapter">What’s new in MyHDL 0.5</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-myhdl-0-6">
<span id="new06"></span><h1>What’s new in MyHDL 0.6<a class="headerlink" href="#what-s-new-in-myhdl-0-6" title="Permalink to this headline">¶</a></h1>
<div class="section" id="conversion-to-vhdl">
<h2>Conversion to VHDL<a class="headerlink" href="#conversion-to-vhdl" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rationale">
<h3>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h3>
<p>Since the MyHDL to Verilog conversion has been developed, a path to
implementation from MyHDL is available. Given the widespread support
for Verilog, it could thus be argued that there was no real need for a
converter to VHDL.</p>
<p>However, it turns out that VHDL is still very much alive and will
remain so for the foreseeable future. This is especially true for the
FPGA market, which is especially interesting for MyHDL. It seems much
more dynamic than the ASIC market. Moreover, because of the nature of
FPGA’s, FPGA designers may be more willing to try out new ideas.</p>
<p>To convince designers to use a new tool, it should integrate with
their current design flow. That is why the MyHDL to VHDL converter is
needed. It should lower the threshold for VHDL designers to start
using MyHDL.</p>
</div>
<div class="section" id="advantages">
<h3>Advantages<a class="headerlink" href="#advantages" title="Permalink to this headline">¶</a></h3>
<p>MyHDL to VHDL conversion offers the following advantages:</p>
<dl class="docutils">
<dt>MyHDL integration in a VHDL-based design flow</dt>
<dd>Designers can start using MyHDL and benefit from its power and
flexibility, within the context of their proven design flow.</dd>
<dt>The converter automates a number of hard tasks</dt>
<dd>The converter automates a number of tasks that are hard to do in
VHDL directly. For example, when mixing <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> and <code class="docutils literal notranslate"><span class="pre">signed</span></code>
types it can be difficult to describe the desired behavior
correctly.  In contrast, a MyHDL designer can use the high-level
<code class="docutils literal notranslate"><span class="pre">intbv</span></code> type, and let the converter deal with type
conversions and resizings.</dd>
<dt>MyHDL as an IP development platform</dt>
<dd>The possibility to convert the same MyHDL source to equivalent
Verilog and VHDL creates a novel application: using MyHDL as an IP
development platform. IP developers can serve customers for both
target languages from a single MyHDL code base. Moreover, MyHDL’s
flexibility and parametrizability make it ideally suited to this
application.</dd>
</dl>
</div>
<div class="section" id="solution-description">
<h3>Solution description<a class="headerlink" href="#solution-description" title="Permalink to this headline">¶</a></h3>
<div class="section" id="approach">
<h4>Approach<a class="headerlink" href="#approach" title="Permalink to this headline">¶</a></h4>
<p>The approach followed to convert MyHDL code to VHDL is identical to
the one followed for conversion to Verilog in previous MyHDL releases.</p>
<p>In particular, the MyHDL code analyzer in the converter is identical
for both target languages. The goal is that all MyHDL code that can be
converted to Verilog can be converted to VHDL also, and
vice versa. This has been achieved except for a few minor issues due
to limitations of the target languages.</p>
</div>
<div class="section" id="user-interface">
<h4>User interface<a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h4>
<p>Conversion to VHDL is implemented by the following function in the <code class="docutils literal notranslate"><span class="pre">myhdl</span></code> package:</p>
<dl class="function">
<dt>
<code class="descname">toVHDL</code><span class="sig-paren">(</span><em>func[, *args][, **kwargs]</em><span class="sig-paren">)</span></dt>
<dd><p>Converts a MyHDL design instance to equivalent VHDL
code. <em>func</em> is a function that returns an instance. <a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVHDL</span></code></a>
calls <em>func</em> under its control and passes <em>*args</em> and
<em>**kwargs</em> to the call.</p>
<p>The return value is the same as the one returned by the call
<code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code>. It can be assigned to an instance name.
The top-level instance name and the basename of the Verilog
output filename is <code class="docutils literal notranslate"><span class="pre">func.func_name</span></code> by default.</p>
</dd></dl>

<p><a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVHDL</span></code></a> has the following attributes:</p>
<dl class="attribute">
<dt id="myhdl.toVHDL.name">
<code class="descclassname">toVHDL.</code><code class="descname">name</code><a class="headerlink" href="#myhdl.toVHDL.name" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute is used to overwrite the default top-level
instance name and the basename of the VHDL output.</p>
</dd></dl>

<dl class="attribute">
<dt id="myhdl.toVHDL.component_declarations">
<code class="descclassname">toVHDL.</code><code class="descname">component_declarations</code><a class="headerlink" href="#myhdl.toVHDL.component_declarations" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute can be used to add component declarations to the
VHDL output. When a string is assigned to it, it will be copied
to the appropriate place in the output file.</p>
</dd></dl>

</div>
<div class="section" id="type-mapping">
<h4>Type mapping<a class="headerlink" href="#type-mapping" title="Permalink to this headline">¶</a></h4>
<p>In contrast to Verilog, VHDL is a strongly typed language. The
converter has to carefully perform type inferencing, and handle type
conversions and resizings appropriately. To do this right, a
well-chosen mapping from MyHDL types to VHDL types is crucial.</p>
<p>MyHDL types are mapped to VHDL types according to the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="39%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">MyHDL type</th>
<th class="head">VHDL type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">integer</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">std_logic</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">intbv</span></code> with <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">unsigned</span></code></td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">intbv</span></code> with  <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">signed</span></code></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">enum</span></code></td>
<td>dedicated enumeration type</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code></td>
<td>mapped to case statement</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">std_logic</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">intbv</span></code> with <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">unsigned</span></code></td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">intbv</span></code> with <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">0</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">signed</span></code></td>
<td>(4)</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>The VHDL <code class="docutils literal notranslate"><span class="pre">std_logic</span></code> type is defined in the standard VHDL package
<code class="docutils literal notranslate"><span class="pre">IEEE.std_logic_1164</span></code>.</li>
<li>The VHDL <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> and <code class="docutils literal notranslate"><span class="pre">signed</span></code> types used are those from the
standard VHDL packages <code class="docutils literal notranslate"><span class="pre">IEEE.numeric_std</span></code>.</li>
<li>A MyHDL <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code> is used for ROM inference, and can only be
used in a very specific way: an indexing operation into the tuple
should be the rhs of an assignment.</li>
<li>All list members should have identical value constraints.</li>
</ol>
<p>The table as presented applies to MyHDL variables. They are mapped to
VHDL variables (except for the case of a <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code>).</p>
<p>The converter also supports MyHDL signals that use <code class="docutils literal notranslate"><span class="pre">bool</span></code>,
<code class="docutils literal notranslate"><span class="pre">intbv</span></code> or <code class="docutils literal notranslate"><span class="pre">enum</span></code> objects as their underlying type. These are mapped to
VHDL signals with a type as specified in the table above.</p>
<p>The converter supports MyHDL list of signals provided the underlying
signal type is either <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">intbv</span></code>. They may be mapped to a VHDL
signal with a VHDL type as specified in the table.
However, list of signals are not always mapped to a corresponding VHDL
signal. See <a class="reference internal" href="#new06-listofsigs"><span class="std std-ref">Conversion of lists of signals</span></a> for more info.</p>
</div>
<div class="section" id="template-transformation">
<h4>Template transformation<a class="headerlink" href="#template-transformation" title="Permalink to this headline">¶</a></h4>
<p>There is a difference between VHDL and Verilog in the way in which
sensitivity to signal edges is specified. In Verilog, edge specifiers
can be used directly in the sensitivity list. In VHDL, this is not
possible: only signals can be used in the sensitivity list. To check
for an edge, one uses the <code class="docutils literal notranslate"><span class="pre">rising_edge()</span></code> or <code class="docutils literal notranslate"><span class="pre">falling_edge()</span></code>
functions in the code.</p>
<p>MyHDL follows the Verilog scheme to specify edges in the sensitivity
list. Consequently, when mapping such code to VHDL, it needs to be
transformed to equivalent VHDL. This is an important issue because it
affects all synthesizable templates that infer sequential logic.</p>
<p>We will illustrate this feature with some examples. This is the MyHDL
code for a D flip-flop:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
    <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>It is converted to VHDL as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DFF_LOGIC</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">DFF_LOGIC</span><span class="p">;</span>
</pre></div>
</div>
<p>The converter can handle the more general case. For example, this is
MyHDL code for a D flip-flop with asynchronous set, asynchronous
reset, and preference of set over reset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">,</span> <span class="nb">set</span><span class="o">.</span><span class="n">negedge</span><span class="p">,</span> <span class="n">rst</span><span class="o">.</span><span class="n">negedge</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">set</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">rst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>This is converted to VHDL as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DFFSR_LOGIC</span><span class="p">:</span> <span class="n">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="n">rst</span><span class="p">)</span> <span class="ow">is</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">set</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="s1">&#39;1&#39;</span><span class="p">;</span>
    <span class="n">elsif</span> <span class="p">(</span><span class="n">rst</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="s1">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">elsif</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="n">then</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
<span class="n">end</span> <span class="n">process</span> <span class="n">DFFSR_LOGIC</span><span class="p">;</span>
</pre></div>
</div>
<p>All cases with practical utility can be handled in this way. However,
there are other cases that cannot be transformed to equivalent
VHDL. The converter will detect those cases and give an error.</p>
</div>
</div>
</div>
<div class="section" id="conversion-of-lists-of-signals">
<span id="new06-listofsigs"></span><h2>Conversion of lists of signals<a class="headerlink" href="#conversion-of-lists-of-signals" title="Permalink to this headline">¶</a></h2>
<p>Lists of signals are useful for many purposes. For example, they make
it easy to create a repetitive structure. Another application is the
description of memory behavior.</p>
<p>The converter output is non-hierarchical. That implies that all
signals are declared at the top-level in VHDL or Verilog (as VHDL
signals, or Verilog regs and wires.)  However, some signals that are a
list member at some level in the design hierarchy may be used as
a plain signal at a lower level. For such signals, a choice has to be
made whether to declare a Verilog memory or VHDL array, or a number of
plain signal names.</p>
<p>If possible, plain signal declarations are preferred, because Verilog
memories and arrays have some restrictions in usage and tool support.
This is possible if the list syntax is strictly used outside generator
code, for example when lists of signals are used to describe
structure.</p>
<p>Conversely, when list syntax is used in some generator, then a Verilog
memory or VHDL array will be declared. The typical example is the
description of RAM memories.</p>
<p>The converter in the previous MyHDL release had a severe restriction
on the latter case: it didn’t allow that, for a certain signal, list
syntax was used in some generator, and plain signal syntax in another.
This restriction, together with its rather obscure error message, has
caused regular user complaints. In this release, this restriction has
been lifted.</p>
</div>
<div class="section" id="conversion-of-test-benches">
<span id="new06-test"></span><h2>Conversion of test benches<a class="headerlink" href="#conversion-of-test-benches" title="Permalink to this headline">¶</a></h2>
<div class="section" id="background">
<h3>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h3>
<p>After conversion, we obviously want to verify that the VHDL or Verilog
code works correctly. In previous MyHDL versions, the proposed
verification technique was co-simulation: use the same MyHDL test
bench to simulate the converted Verilog code and the original MyHDL
code. While co-simulation works well, there are a number of issues
with it:</p>
<ul class="simple">
<li>Co-simulation requires that the HDL simulator has an interface to
its internal workings, such as <code class="docutils literal notranslate"><span class="pre">vpi</span></code> for Verilog and <code class="docutils literal notranslate"><span class="pre">vhpi</span></code> for
VHDL.</li>
<li><code class="docutils literal notranslate"><span class="pre">vpi</span></code> for Verilog is well-established and available for
open-source simulators such as Icarus and cver. However, <code class="docutils literal notranslate"><span class="pre">vhpi</span></code> for
VHDL is much less established; it is unclear whether there is an open
source solution that is powerful enough for MyHDL’s purposes.</li>
<li>Even though <code class="docutils literal notranslate"><span class="pre">vpi</span></code> is a “standard”, there are differences between
various simulators. Therefore, some customization is typically required
per Verilog simulator.</li>
<li>MyHDL co-simulation uses unix-style interprocess communication
that doesn’t work on Windows natively. This is an exception to the
rest of MyHDL that should run on any Python platform.</li>
</ul>
<p>The conclusion is that co-simulation is probably not a viable solution
for the VHDL case, and it has some disadvantages for Verilog as well.</p>
<p>The proposed alternative is to convert the test bench itself, so that
both test bench and design can be run in the HDL simulator. Of course,
this is not a fully general solution either, as there are important
restrictions on the kind of code that can be converted. However, with
the additional features that have been developed, it should be a
useful solution for verifying converted code.</p>
</div>
<div class="section" id="print-statement">
<h3>Print statement<a class="headerlink" href="#print-statement" title="Permalink to this headline">¶</a></h3>
<p>In previous MyHDL versions, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> statement conversion to Verilog was
supported in a quick and dirty way, by merely copying the format
string without checks. With the advent of VHDL conversion, this has
now been implemented more rigorously. This was necessary because VHDL
doesn’t work with format strings. Rather, the format string
specification has to be converted to a sequence of VHDL <code class="docutils literal notranslate"><span class="pre">write</span></code> and
<code class="docutils literal notranslate"><span class="pre">writeline</span></code> calls.</p>
<p>A <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> statement with multiple arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>is supported. However, there are restrictions on the arguments.
First, they should be of one of the following forms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arg</span>
<span class="n">formatstring</span> <span class="o">%</span> <span class="n">arg</span>
<span class="n">formatstring</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">arg</span></code> is a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">intbv</span></code>, <code class="docutils literal notranslate"><span class="pre">enum</span></code>, or a
<code class="docutils literal notranslate"><span class="pre">Signal</span></code> of these types.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">formatstring</span></code> contains ordinary characters and conversion
specifiers as in Python. However, the only supported conversion specifiers
are <code class="docutils literal notranslate"><span class="pre">%s</span></code> and <code class="docutils literal notranslate"><span class="pre">%d</span></code>.
Justification and width specification are thus not supported.</p>
<p>Printing without a newline:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">arg1</span> <span class="p">,</span>
</pre></div>
</div>
<p>is not supported. This is because the solution is based on
<code class="docutils literal notranslate"><span class="pre">std.textio</span></code>. In VHDL <code class="docutils literal notranslate"><span class="pre">std.textio</span></code>, subsequent <code class="docutils literal notranslate"><span class="pre">write()</span></code> calls to
a line are only printed upon a <code class="docutils literal notranslate"><span class="pre">writeline()</span></code> call. As a
normal <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> implies a newline, the correct behavior can be
guaranteed, but for a <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> without newline this is not
possible. In the future, other techniques may be used and this
restriction may be lifted.</p>
</div>
<div class="section" id="assert-statement">
<h3>Assert statement<a class="headerlink" href="#assert-statement" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> statement in Python looks as follow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">test_expression</span>
</pre></div>
</div>
<p>It can be converted provided <code class="docutils literal notranslate"><span class="pre">test_expression</span></code> is convertible.</p>
</div>
<div class="section" id="delay-objects">
<h3>Delay objects<a class="headerlink" href="#delay-objects" title="Permalink to this headline">¶</a></h3>
<p>Delay objects are constructed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">delay</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">t</span></code> an integer. They are used in <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#yield" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statements and
as the argument of <a class="reference internal" href="../manual/reference.html#myhdl.always" title="myhdl.always"><code class="xref py py-func docutils literal notranslate"><span class="pre">always</span></code></a> decorators, to specify delays.
They can now be converted.</p>
</div>
<div class="section" id="methodology-notes">
<h3>Methodology notes<a class="headerlink" href="#methodology-notes" title="Permalink to this headline">¶</a></h3>
<p>The question is whether the conversion restrictions permit one to develop
sufficiently complex test benches. In this section, we present some
insights about this.</p>
<p>The most important restrictions are the types that can be used. These
remain “hardware-oriented” as before.</p>
<p>Even in the previous MyHDL release, the “convertible subset” was much
wider than the “synthesis subset”. For example, <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#while" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> and
<a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#raise" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> statement were already convertible.</p>
<p>The support for <a class="reference internal" href="../manual/reference.html#myhdl.delay" title="myhdl.delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">delay</span></code></a> objects is the most important new feature
to write high-level models and test benches.</p>
<p>With the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> statement, simple debugging can be done.</p>
<p>Of particular interest is the <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> statement. Originally,
<a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> statements were only intended to insert debugging
assertions in code. Recently, there is a tendency to use them to write
self-checking unit tests, controlled by unit test frameworks such as
<code class="docutils literal notranslate"><span class="pre">py.test</span></code>. In particular, they are a powerful way to write
self-checking test benches for MyHDL designs. As <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a>
statements are now convertible, a whole test suite in MyHDL can be
converted to an equivalent test suite in Verilog and VHDL.</p>
<p>Finally, the same techniques as for synthesizable code can be used
to master complexity. In particular, any code outside generators
is executed during elaboration, and therefore not considered in
the conversion process. This feature can for example be used for
complex calculations that set up constants or expected results.
Furthermore, a tuple of ints can be used to hold a table of
values that will be mapped to a case statement in Verilog and VHDL.</p>
</div>
</div>
<div class="section" id="conversion-output-verification">
<h2>Conversion output verification<a class="headerlink" href="#conversion-output-verification" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This functionality is not needed in a typical
design flow. It is only relevant to debug the
MyHDL converter itself.</p>
</div>
<div class="section" id="id1">
<h3>Approach<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>To verify the converter output, a methodology has been developed and
implemented that doesn’t rely on co-simulation and works for both
Verilog and VHDL.</p>
<p>The solution builds on the features explained in section <a class="reference internal" href="#new06-test"><span class="std std-ref">Conversion of test benches</span></a>.
The idea is basically to convert the test bench as well as the
functional code. In particular, <code class="docutils literal notranslate"><span class="pre">print</span></code> statements in MyHDL are
converted to equivalent statements in the HDL. The verification
process consists of running both the MyHDL and the HDL simulation,
comparing the simulation output, and reporting any differences.</p>
<p>The goal is to make the verification process as easy as possible. The
use of <code class="docutils literal notranslate"><span class="pre">print</span></code> statements to debug a design is a very common and
simple technique. The verification process itself is implemented in a
single function with an interface that is identical to <code class="docutils literal notranslate"><span class="pre">toVHDL</span></code> and
<code class="docutils literal notranslate"><span class="pre">toVerilog</span></code>.</p>
<p>As this is a native Python solution, it runs on any platform on which
the HDL simulator runs. Moreover, any HDL simulator can be used as no
<code class="docutils literal notranslate"><span class="pre">vpi</span></code> or <code class="docutils literal notranslate"><span class="pre">vhpi</span></code> capabilities are needed. Of course, per HDL
simulator some customization is required to define the details on how
it is used. This needs to be done once per HDL simulator and is fully
under user control.</p>
</div>
<div class="section" id="verification-interface">
<h3>Verification interface<a class="headerlink" href="#verification-interface" title="Permalink to this headline">¶</a></h3>
<p>All functions related to conversion verification are implemented in
the <code class="docutils literal notranslate"><span class="pre">myhdl.conversion</span></code> package. (To keep the <code class="docutils literal notranslate"><span class="pre">myhdl</span></code> namespace
clean, they are not available from the <code class="docutils literal notranslate"><span class="pre">myhdl</span></code> namespace directly.)</p>
<dl class="function">
<dt id="myhdl.verify">
<code class="descname">verify</code><span class="sig-paren">(</span><em>func[, *args][, **kwargs]</em><span class="sig-paren">)</span><a class="headerlink" href="#myhdl.verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Used like <a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVHDL</span></code></a>. It converts MyHDL code,
simulates both the MyHDL code and the HDL code and reports any
differences. The default HDL simulator is GHDL.</p>
</dd></dl>

<dl class="function">
<dt id="myhdl.analyze">
<code class="descname">analyze</code><span class="sig-paren">(</span><em>func[, *args][, **kwargs]</em><span class="sig-paren">)</span><a class="headerlink" href="#myhdl.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Used like <a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVHDL</span></code></a>. It converts MyHDL code, and analyzes the
resulting HDL.
Used to verify whether the HDL output is syntactically correct.</p>
</dd></dl>

<p>The two previous functions have the following attribute:</p>
<dl class="attribute">
<dt id="myhdl.analyze.simulator">
<code class="descclassname">analyze.</code><code class="descname">simulator</code><a class="headerlink" href="#myhdl.analyze.simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to set the name of the HDL analyzer. GHDL
is the default.</p>
</dd></dl>

<dl class="attribute">
<dt id="myhdl.verify.simulator">
<code class="descclassname">verify.</code><code class="descname">simulator</code><a class="headerlink" href="#myhdl.verify.simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to set the name of the HDL simulator. GHDL
is the default.</p>
</dd></dl>

</div>
<div class="section" id="hdl-simulator-registration">
<h3>HDL simulator registration<a class="headerlink" href="#hdl-simulator-registration" title="Permalink to this headline">¶</a></h3>
<p>To be able to use a HDL simulator to verify conversions, it needs to
be registered first. This is needed once per simulator (or rather, per
set of analysis and simulation commands). Registering is done with the
following function:</p>
<dl class="function">
<dt id="myhdl.registerSimulator">
<code class="descname">registerSimulator</code><span class="sig-paren">(</span><em>name=None</em>, <em>hdl=None</em>, <em>analyze=None</em>, <em>elaborate=None</em>, <em>simulate=None</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#myhdl.registerSimulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a particular HDL simulator to be used by  <a class="reference internal" href="#myhdl.verify" title="myhdl.verify"><code class="xref py py-func docutils literal notranslate"><span class="pre">verify</span></code></a>
and <a class="reference internal" href="#myhdl.analyze" title="myhdl.analyze"><code class="xref py py-func docutils literal notranslate"><span class="pre">analyze</span></code></a>. <em>name</em> is the name of the simulator.
<em>hdl</em> specifies the HDL: <code class="docutils literal notranslate"><span class="pre">&quot;VHDL&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;Verilog&quot;</span></code>.
<em>analyze</em> is a command string to analyze the HDL source code.
<em>elaborate</em> is a command string to elaborate the HDL
code. This command is optional.
<em>simulate</em> is a command string to simulate the HDL code.
<em>offset</em> is an integer specifying the number of initial lines to be ignored
from the HDL simulator output.</p>
<p>The command strings should be string templates that refer to the
<code class="docutils literal notranslate"><span class="pre">topname</span></code> variable that specifies the design name. The templates
can also use the <code class="docutils literal notranslate"><span class="pre">unitname</span></code> variable which is the lower case
version of <code class="docutils literal notranslate"><span class="pre">topname</span></code>.
The command strings can assume that a subdirectory called
<code class="docutils literal notranslate"><span class="pre">work</span></code> is available in the current working directory. Analysis and
elaboration results can be put there if desired.</p>
<p>The <a class="reference internal" href="#myhdl.analyze" title="myhdl.analyze"><code class="xref py py-func docutils literal notranslate"><span class="pre">analyze</span></code></a> function runs the <em>analyze</em> command.
The <a class="reference internal" href="#myhdl.verify" title="myhdl.verify"><code class="xref py py-func docutils literal notranslate"><span class="pre">verify</span></code></a> function runs the <em>analyze</em> command, then the
<em>elaborate</em> command if any, and then the <em>simulate</em> command.</p>
<p>The GHDL simulator is registered by default, but its
registration can be overwritten if required.</p>
</dd></dl>

<div class="section" id="example-preregistered-hdl-simulators">
<h4>Example: preregistered HDL simulators<a class="headerlink" href="#example-preregistered-hdl-simulators" title="Permalink to this headline">¶</a></h4>
<p>A number of open-source HDL simulators are preregistered in the
MyHDL distribution. If they are installed in the typical way, they
are readily available for conversion verification.
We will illustrate the registration process by showing the
registrations of these simulators.</p>
<p>GHDL registration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">registerSimulator</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;GHDL&quot;</span><span class="p">,</span>
    <span class="n">hdl</span><span class="o">=</span><span class="s2">&quot;VHDL&quot;</span><span class="p">,</span>
    <span class="n">analyze</span><span class="o">=</span><span class="s2">&quot;ghdl -a --workdir=work pck_myhdl_</span><span class="si">%(version)s</span><span class="s2">.vhd </span><span class="si">%(topname)s</span><span class="s2">.vhd&quot;</span><span class="p">,</span>
    <span class="n">elaborate</span><span class="o">=</span><span class="s2">&quot;ghdl -e --workdir=work -o </span><span class="si">%(unitname)s</span><span class="s2">_ghdl </span><span class="si">%(topname)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">simulate</span><span class="o">=</span><span class="s2">&quot;ghdl -r </span><span class="si">%(unitname)s</span><span class="s2">_ghdl&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Icarus registration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">registerSimulator</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;icarus&quot;</span><span class="p">,</span>
    <span class="n">hdl</span><span class="o">=</span><span class="s2">&quot;Verilog&quot;</span><span class="p">,</span>
    <span class="n">analyze</span><span class="o">=</span><span class="s2">&quot;iverilog -o </span><span class="si">%(topname)s</span><span class="s2">.o </span><span class="si">%(topname)s</span><span class="s2">.v&quot;</span><span class="p">,</span>
    <span class="n">simulate</span><span class="o">=</span><span class="s2">&quot;vvp </span><span class="si">%(topname)s</span><span class="s2">.o&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>cver registration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">registerSimulator</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cver&quot;</span><span class="p">,</span>
    <span class="n">hdl</span><span class="o">=</span><span class="s2">&quot;Verilog&quot;</span><span class="p">,</span>
    <span class="n">analyze</span><span class="o">=</span><span class="s2">&quot;cver -c -q </span><span class="si">%(topname)s</span><span class="s2">.v&quot;</span><span class="p">,</span>
    <span class="n">simulate</span><span class="o">=</span><span class="s2">&quot;cver -q </span><span class="si">%(topname)s</span><span class="s2">.v&quot;</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">3</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="new-modeling-features">
<h2>New modeling features<a class="headerlink" href="#new-modeling-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="new-signed-method-for-intbv">
<h3>New signed() method for intbv<a class="headerlink" href="#new-signed-method-for-intbv" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object has a new method <code class="xref py py-meth docutils literal notranslate"><span class="pre">signed</span></code> that
implements sign extension. The extended bit is the msb bit of
the bit representation of the object.</p>
<p>Clearly, this method only has an effect for <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects
whose valid values are a finite range of positive integers.</p>
<p>This method can be converted to VHDL and Verilog.</p>
</div>
<div class="section" id="always-comb-and-list-of-signals">
<h3>always_comb and list of signals<a class="headerlink" href="#always-comb-and-list-of-signals" title="Permalink to this headline">¶</a></h3>
<p>In the previous MyHDL release, one could use lists of signals
in an <a class="reference internal" href="../manual/reference.html#myhdl.always_comb" title="myhdl.always_comb"><code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code></a> block, but they were not considered to infer
the sensitivity list. To several users, this was unexpected
behavior, or even a bug.</p>
<p>In the present release, lists of signals are considered and
the corresponding signals are added to the sensitivity list.
The converter to Verilog and VHDL is adapted accordingly.</p>
</div>
</div>
<div class="section" id="backwards-incompatible-changes">
<h2>Backwards incompatible changes<a class="headerlink" href="#backwards-incompatible-changes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="decorator-usage">
<span id="new06-deco"></span><h3>Decorator usage<a class="headerlink" href="#decorator-usage" title="Permalink to this headline">¶</a></h3>
<p>The basic building block of a MyHDL design is a specialized Python
generator.</p>
<p>In MyHDL 0.5, decorators were introduced to make it easier to create
useful MyHDL generators. Moreover, they make the code clearer. As a
result, they are now the de facto standard to describe hardware
modules in MyHDL.</p>
<p>The implementation of certain tasks, such a signal tracing and
conversion, can be simplified significantly if decorators are used to
create the generators. These simplifications have now been adopted in
the code. This means that decorator usage is assumed.  Legacy code
written for the mentioned purposes without decorators, can always be
easily converted into code with decorators.</p>
<p>For pure modeling, it doesn’t matter how generators are created and
this will remain so. Therefore, designers can continue to experiment
with innovative modeling concepts in the fullest generality.</p>
</div>
<div class="section" id="instances-function">
<h3>instances() function<a class="headerlink" href="#instances-function" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../manual/reference.html#myhdl.instances" title="myhdl.instances"><code class="xref py py-func docutils literal notranslate"><span class="pre">instances</span></code></a> function can be used to automatically lookup and
return the instances that are defined in a MyHDL module.  In accordance
with the section <a class="reference internal" href="#new06-deco"><span class="std std-ref">Decorator usage</span></a>, its functionality has been
changed. Only generators created by decorators are considered when
looking up instances.</p>
</div>
<div class="section" id="conversion-of-printing-without-a-newline">
<h3>Conversion of printing without a newline<a class="headerlink" href="#conversion-of-printing-without-a-newline" title="Permalink to this headline">¶</a></h3>
<p>Printing without a newline (a print statement followed by a comma) is
no longer supported by the converter to Verilog. This is done to be
compatible with the converter to VHDL. Currently, the VHDL solution
relies on <code class="docutils literal notranslate"><span class="pre">std.textio</span></code> and this implies that printing without a
newline cannot be reliably converted.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/whatsnew/0.6.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>