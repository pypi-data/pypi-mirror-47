
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What’s New in MyHDL 0.3 &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="What’s new in MyHDL 0.4: Conversion to Verilog" href="0.4.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">The MyHDL manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.6.html">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.5.html">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.4.html">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="0.4.html" title="previous chapter">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="whats-new-in-myhdl-0-3">
<h1>What’s New in MyHDL&nbsp;0.3<a class="headerlink" href="#whats-new-in-myhdl-0-3" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Jan Decaluwe</td>
</tr>
</tbody>
</table>
<div class="section" id="vcd-output-for-waveform-viewing">
<h2>VCD output for waveform viewing<a class="headerlink" href="#vcd-output-for-waveform-viewing" title="Permalink to this headline">¶</a></h2>
<p><img alt="image" src="../_images/tbfsm1.png" /></p>
<p>MyHDL&nbsp;now has support for waveform viewing. During simulation, signal
changes can be written to a VCD output file that can be loaded into a
waveform viewer tool such as <strong>gtkwave</strong>.</p>
<p>The user interface of this feature consists of a single function,
<code class="xref py py-func docutils literal notranslate"><span class="pre">traceSignals</span></code>. To explain how it works, recall that in MyHDL,
an instance is created by assigning the result of a function call to an
instance name. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tb_fsm</span> <span class="o">=</span> <span class="n">testbench</span><span class="p">()</span>
</pre></div>
</div>
<p>To enable VCD tracing, the instance should be created as follows
instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tb_fsm</span> <span class="o">=</span> <span class="n">traceSignals</span><span class="p">(</span><span class="n">testbench</span><span class="p">)</span>
</pre></div>
</div>
<p>All signals in the instance hierarchy will be traced in a VCD file
called . Note that first the argument of <code class="xref py py-func docutils literal notranslate"><span class="pre">traceSignals</span></code> consists
of the uncalled function. By calling the function under its control,
<code class="xref py py-func docutils literal notranslate"><span class="pre">traceSignals</span></code> gathers information about the hierarchy and the
signals to be traced. In addition to a function argument,
<code class="xref py py-func docutils literal notranslate"><span class="pre">traceSignals</span></code> accepts an arbitrary number of non-keyword and
keyword arguments that will be passed to the function call.</p>
<p>Signals are dumped in a suitable format. This format is inferred at the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> construction time, from the type of the initial value.
In particular, <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> signals are dumped as single bits. (This
only works starting with Python&nbsp;2.3, when <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> has become a
separate type). Likewise, <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> signals with a defined bit
width are dumped as bit vectors. To support the general case, other
types of signals are dumped as a string representation, as returned by
the standard <code class="xref py py-func docutils literal notranslate"><span class="pre">str</span></code> function.</p>
<p>[warning] Support for literal string representations is not part of the
VCD standard. It is specific to <strong>gtkwave</strong>. To generate a standard VCD
file, you need to use signals with a defined bit width only.</p>
</div>
<div class="section" id="enumeration-types">
<h2>Enumeration types<a class="headerlink" href="#enumeration-types" title="Permalink to this headline">¶</a></h2>
<p>It is often desirable to define a set of identifiers. A standard Python
idiom for this purpose is to assign a range of integers to a tuple of
identifiers, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SEARCH</span><span class="p">,</span> <span class="n">CONFIRM</span><span class="p">,</span> <span class="n">SYNC</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CONFIRM</span>
<span class="go">1</span>
</pre></div>
</div>
<p>However, this technique has some drawbacks. Though it is clearly the
intention that the identifiers belong together, this information is lost
as soon as they are defined. Also, the identifiers evaluate to integers,
whereas a string representation of the identifiers would be preferable.
To solve these issues, we need an <em>enumeration type</em>.</p>
<p>MyHDL&nbsp;0.3 supports enumeration types by providing a function
<code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code>. The arguments to <code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code> are the string
representations of the identifiers, and its return value is an
enumeration type. The identifiers are available as attributes of the
type. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_State</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="s1">&#39;SEARCH&#39;</span><span class="p">,</span> <span class="s1">&#39;CONFIRM&#39;</span><span class="p">,</span> <span class="s1">&#39;SYNC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_State</span>
<span class="go">&lt;Enum: SEARCH, CONFIRM, SYNC&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_State</span><span class="o">.</span><span class="n">CONFIRM</span>
<span class="go">CONFIRM</span>
</pre></div>
</div>
<p>Enumeration types are often used for the state variable in a finite
state machine. In the waveform in
Section&nbsp;<a class="reference external" href="#vcd-output-for-waveform-viewing">1</a>, you see a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> called <code class="docutils literal notranslate"><span class="pre">state</span></code>. Note how the waveforms show the string
representation of the enumeration type identifiers The <code class="docutils literal notranslate"><span class="pre">state</span></code> signal
has been constructed with an enumeration type identifier as its initial
value, as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="inferring-the-sensitivity-list-for-combinatorial-logic">
<h2>Inferring the sensitivity list for combinatorial logic<a class="headerlink" href="#inferring-the-sensitivity-list-for-combinatorial-logic" title="Permalink to this headline">¶</a></h2>
<p>In MyHDL, combinatorial logic is described by a generator function with
a sensitivity list that contains all inputs signals (the signals that
are read inside the function).</p>
<p>It may be easy to forget some input signals, especially it there are a
lot of them or if the code is being modified. There are various ways to
solve this. One way is to use a sophisticated editor. Another way is
direct language support. For example, recent versions of Verilog have
the <code class="docutils literal notranslate"><span class="pre">always&nbsp;&#64;*</span></code> construct, that infers all input signals. The
SystemVerilog&nbsp;3.1 standard improves on this by introducing the
<code class="docutils literal notranslate"><span class="pre">always_comb</span></code> block with slightly enhanced semantics.</p>
<p>MyHDL&nbsp;0.3 provides a function called <code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code> which is
named and modeled after the SystemVerilog counterpart.
<code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code> takes a classic local function as its argument.
This function should specify the combinatorial logic behavior.
<code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code> returns a generator that is sensitive to all
inputs, and that will run the function whenever an input changes.</p>
<p>For example, suppose that we have a mux module described as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mux</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Multiplexer.</span>

<span class="sd">    z -- mux output</span>
<span class="sd">    a, b -- data inputs</span>
<span class="sd">    sel -- control input</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">()</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sel</span>
            <span class="k">if</span> <span class="n">sel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">z</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">mux_logic</span> <span class="o">=</span> <span class="n">logic</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mux_logic</span>
</pre></div>
</div>
<p>Using <code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code>, we can describe it as follows instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mux</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Multiplexer.</span>

<span class="sd">    z -- mux output</span>
<span class="sd">    a, b -- data inputs</span>
<span class="sd">    sel -- control input</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">z</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">mux_logic</span> <span class="o">=</span> <span class="n">always_comb</span><span class="p">(</span><span class="n">logic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mux_logic</span>
</pre></div>
</div>
<p>Note that in the first version, the sensitivity list is at the beginning
of the generator function code. This is traditionally done in
synthesizable RTL style modeling. However, the semantics of this style
are not entirely correct: at the start of the simulation, the
combinatorial output will not reflect the initial state of the inputs.
<code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code> solves this by putting the sensitivity list at the
end of the code.</p>
</div>
<div class="section" id="inferring-the-list-of-instances">
<h2>Inferring the list of instances<a class="headerlink" href="#inferring-the-list-of-instances" title="Permalink to this headline">¶</a></h2>
<p>In MyHDL, the instances defined in a top level function need to be
returned explicitly. The following is a schematic example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">instance_1</span> <span class="o">=</span> <span class="n">module_1</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">instance_2</span> <span class="o">=</span> <span class="n">module_2</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">instance_n</span> <span class="o">=</span> <span class="n">module_n</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">instance_1</span><span class="p">,</span> <span class="n">instance_2</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="n">instance_n</span>
</pre></div>
</div>
<p>It may be convenient to assemble the list of instances automatically,
especially if there are many instances. For this purpose, MyHDL&nbsp;0.3
provides the function <code class="xref py py-func docutils literal notranslate"><span class="pre">instances</span></code>. It is used as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">instances</span>

<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">instance_1</span> <span class="o">=</span> <span class="n">module_1</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">instance_2</span> <span class="o">=</span> <span class="n">module_2</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">instance_n</span> <span class="o">=</span> <span class="n">module_n</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
<p>Function <code class="xref py py-func docutils literal notranslate"><span class="pre">instances</span></code> uses introspection to inspect the type of
the local variables defined by the calling function. All variables that
comply with the definition of an instance are assembled in a list, and
that list is returned.</p>
</div>
<div class="section" id="inferring-the-list-of-processes">
<h2>Inferring the list of processes<a class="headerlink" href="#inferring-the-list-of-processes" title="Permalink to this headline">¶</a></h2>
<p>In addition to instances, a top level function may also define local
generators functions, which I will call <em>processes</em> because of the
analogy with VHDL. Like instances, processes need to be returned
explicitly, with the qualification that they have to be called first to
turn them into generators. The following is a schematic example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">process_1</span><span class="p">():</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">process_2</span><span class="p">():</span>
        <span class="o">...</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">process_n</span><span class="p">():</span>
        <span class="o">...</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">process_1</span><span class="p">(),</span> <span class="n">process_2</span><span class="p">(),</span> <span class="o">...</span><span class="p">,</span> <span class="n">process_n</span><span class="p">()</span>
</pre></div>
</div>
<p>As for instances, it may be more convenient to assemble the list of
processes automatically. One option is to turn each process into an
instance by calling it and assigning the returned generator to a local
variable. Those instances will then be found by the <code class="xref py py-func docutils literal notranslate"><span class="pre">instances</span></code>
function described in
Section&nbsp;<a class="reference external" href="#inferring-the-list-of-instances">4</a>.</p>
<p>Another option is to use the function <code class="xref py py-func docutils literal notranslate"><span class="pre">processes</span></code> provided by
MyHDL&nbsp;0.3. This function uses introspection to find the processes, calls
each of them, and assembles the returned generators into a list. It can
be used as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">processes</span>

<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">process_1</span><span class="p">():</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">process_2</span><span class="p">():</span>
        <span class="o">...</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">process_n</span><span class="p">():</span>
        <span class="o">...</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">processes</span><span class="p">()</span>
</pre></div>
</div>
<p>To conclude, a top level function with both instances and processes can
use the following idiomatic code to return all of them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">instances</span><span class="p">(),</span> <span class="n">processes</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="class-intbv-enhancements">
<h2>Class <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> enhancements<a class="headerlink" href="#class-intbv-enhancements" title="Permalink to this headline">¶</a></h2>
<p>Class <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> has been enhanced with new features.</p>
<p>It is now possible to leave the left index of a slicing operation
unspecified. The meaning is to access “all” higher order bits. For
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">myhdl</span> <span class="k">import</span> <span class="n">intbv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;0x0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[:]</span> <span class="o">=</span> <span class="mh">0xde</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;0xde&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xfa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;0xfade&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[</span><span class="mi">8</span><span class="p">:]</span> <span class="o">=</span> <span class="mh">0xb4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;0xfab4&#39;</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> objects now have <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code> attributes that can
be specified at construction time. The meaning is that only values
within <code class="docutils literal notranslate"><span class="pre">range(min,</span> <span class="pre">max)</span></code> are permitted. The default value for these
attributes is <code class="docutils literal notranslate"><span class="pre">None</span></code>, meaning “infinite”. For example (traceback
output shortened for clarity):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="nb">min</span><span class="o">=-</span><span class="mi">17</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">53</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">intbv(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">min</span>
<span class="go">-17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">max</span>
<span class="go">53</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">intbv(28)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">18</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">intbv value -18 &lt; minimum -17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">53</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">intbv value 53 &gt;= maximum 53</span>
</pre></div>
</div>
<p>When a slice is taken from an <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object, the return value is
a new <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object with a defined bit width. As in Verilog, the
value of the new <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object is always positive, regardless of
the sign of the original value. In addition, the <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code>
attributes are set implicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">()[</span><span class="mi">6</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span>
<span class="go">intbv(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">min</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">max</span>
<span class="go">64</span>
</pre></div>
</div>
<p>Lastly, a small change was implemented with regard to binary operations.
In previous versions, both numeric and bit-wise operations always
returned a new <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object, even in mixed-mode operations with
<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> objects. This has changed: numeric operations return an
<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, and bitwise operations return a <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code>. In this
way, the return value corresponds better to the nature of the operation.</p>
</div>
<div class="section" id="function-concat">
<h2>Function <code class="xref py py-func docutils literal notranslate"><span class="pre">concat</span></code><a class="headerlink" href="#function-concat" title="Permalink to this headline">¶</a></h2>
<p>In previous versions, the <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> class provided a method. This
method is no longer available. Instead, there is now a <code class="xref py py-func docutils literal notranslate"><span class="pre">concat</span></code>
function that supports a much broader range of objects.</p>
<p>A function is more natural because MyHDL&nbsp;objects of various types can be
concatenated: <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> objects with a defined bit width,
<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> objects, the corresponding signal objects, and bit
strings. All these objects have a defined bit width. Moreover, the first
argument doesn’t need to have a defined bit width. It can also be an
unsized <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code>, an <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, a <code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code>, or a
corresponding signal object. Function <code class="xref py py-func docutils literal notranslate"><span class="pre">concat</span></code> returns an
<code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object.</p>
</div>
<div class="section" id="python-2-3-support">
<h2>Python 2.3 support<a class="headerlink" href="#python-2-3-support" title="Permalink to this headline">¶</a></h2>
<p>Python&nbsp;2.3 was released on July 29, 2003, and as of this writing, it is
the latest stable Python release. MyHDL&nbsp;0.3 works with both Python&nbsp;2.2
and Python&nbsp;2.3. In good Python tradition, MyHDL&nbsp;code developed with
Python&nbsp;2.2 should run without changes or problems in Python&nbsp;2.3.</p>
<p>In general, I am not that keen on early upgrading. However, as it
happens, the evolution of Python enables features that are really
important or even crucial to MyHDL. Python&nbsp;2.2 generators are the best
example: they are the cornerstone of MyHDL. But Python&nbsp;2.3 also has
significant benefits, which I will summarize below.</p>
<p>First, generators and the <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement are a default Python&nbsp;2.3
feature. This means that statements are no longer required.</p>
<p>Second, Python&nbsp;2.3 has a <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> type, which is implemented as a
subtype of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. For general Python use, the implications are
rather limited - the main difference is that logical result values will
print as <code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">True</span></code> instead of <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code>. However, in
MyHDL, I can use the <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> type to infer a bit width. If a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> is constructed with a <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> value, it is a
single bit <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code>. One application is waveform viewing as in
Section&nbsp;<a class="reference external" href="#vcd-output-for-waveform-viewing">1</a> In the waveform, note
how single bit signals are displayed as level changes. With Python 2.2,
the waveforms of these signals would only show value changes, which is
not as clear for single bits.</p>
<p>Finally, Python&nbsp;2.3 is significantly faster. MyHDL&nbsp;code runs 25–35%
faster in Python&nbsp;2.3. This is a very nice speedup compared to the small
burden of a straightforward upgrade.</p>
<p>Python is a very stable language, so upgrading to Python&nbsp;2.3 is
virtually risk free. Given the additional benefits, I recommend
MyHDL&nbsp;users to do so as soon as possible. For the next major
MyHDLrelease, the new features will become required and only Python&nbsp;2.3
(and higher) will be supported.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/whatsnew/0.3.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>