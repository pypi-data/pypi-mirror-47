
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What’s new in MyHDL 0.5 &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="What’s new in MyHDL 0.4: Conversion to Verilog" href="0.4.html" />
    <link rel="prev" title="What’s new in MyHDL 0.6" href="0.6.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">The MyHDL manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.6.html">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.4.html">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.3.html">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="0.6.html" title="previous chapter">What’s new in MyHDL 0.6</a></li>
      <li>Next: <a href="0.4.html" title="next chapter">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-myhdl-0-5">
<span id="new05"></span><h1>What’s new in MyHDL 0.5<a class="headerlink" href="#what-s-new-in-myhdl-0-5" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Jan Decaluwe</td>
</tr>
</tbody>
</table>
<div class="section" id="modeling">
<h2>Modeling<a class="headerlink" href="#modeling" title="Permalink to this headline">¶</a></h2>
<div class="section" id="creating-generators-with-decorators">
<h3>Creating generators with decorators<a class="headerlink" href="#creating-generators-with-decorators" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p>Python 2.4 introduced a new feature called <em>decorators</em>. A decorator consists
of special syntax in front of a function declaration. It refers to a decorator
function. The decorator function automatically transforms the declared function
into some other callable object.</p>
<p>MyHDL 0.5 defines decorators that can be used to create ready-to-run generators
from local functions. The use of decorators results in clearer, more explicit
code.</p>
</div>
<div class="section" id="the-instance-decorator">
<h4>The <code class="docutils literal notranslate"><span class="pre">&#64;instance</span></code> decorator<a class="headerlink" href="#the-instance-decorator" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;instance</span></code> decorator is the most general decorator in MyHDL.</p>
<p>In earlier versions of MyHDL, local generator functions are typically used as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">gen_func</span><span class="p">():</span>
        <span class="o">&lt;</span><span class="n">generator</span> <span class="n">body</span><span class="o">&gt;</span>
    <span class="o">...</span>
    <span class="n">inst</span> <span class="o">=</span> <span class="n">gen_func</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">inst</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>Note that the generator function <code class="xref py py-func docutils literal notranslate"><span class="pre">gen_func</span></code> is intended to be called
exactly once, and that its name is not necessary anymore afterwards. In MyHDL
0.5, this can be rewritten as follows, using the <code class="docutils literal notranslate"><span class="pre">&#64;instance</span></code> decorator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">inst</span><span class="p">():</span>
        <span class="o">&lt;</span><span class="n">generator</span> <span class="n">body</span><span class="o">&gt;</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">inst</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>Behind the curtains, the <code class="docutils literal notranslate"><span class="pre">&#64;instance</span></code> decorator automatically creates a
generator by calling the generator function, and by reusing its name. Note that
it is placed immediately in front of the corresponding generator function,
resulting in clearer code.</p>
</div>
<div class="section" id="the-always-decorator">
<h4>The <code class="docutils literal notranslate"><span class="pre">&#64;always</span></code> decorator<a class="headerlink" href="#the-always-decorator" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;always</span></code> decorator is a specialized decorator that targets a very
popular coding pattern. It is used as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="nd">@always</span><span class="p">(</span><span class="n">event1</span><span class="p">,</span> <span class="n">event2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inst</span><span class="p">()</span>
        <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">inst</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>The meaning of this code is that the decorated function is executed whenever
one of the events occurs. The argument list of the decorator corresponds to the
sensitivity list. Appropriate events are edge specifiers, signals, and delay
objects. The decorated function is a classic function instead of a generator
function.</p>
<p>Behind the curtains, the <code class="docutils literal notranslate"><span class="pre">always</span></code> decorator creates an enclosing <code class="docutils literal notranslate"><span class="pre">while</span>
<span class="pre">True</span></code> loop automatically, and inserts a <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement with the
sensitivity list.</p>
</div>
<div class="section" id="the-always-comb-decorator">
<h4>The <code class="docutils literal notranslate"><span class="pre">&#64;always_comb</span></code> decorator<a class="headerlink" href="#the-always-comb-decorator" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;always_comb</span></code> decorator is used to describe combinatorial logic. It is
nothing else than the <a class="reference internal" href="../manual/reference.html#myhdl.always_comb" title="myhdl.always_comb"><code class="xref py py-func docutils literal notranslate"><span class="pre">always_comb</span></code></a> function from earlier MyHDL versions
used as a decorator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">comb_inst</span><span class="p">():</span>
        <span class="o">&lt;</span><span class="n">combinatorial</span> <span class="n">body</span><span class="o">&gt;</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">comb_inst</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;always_comb</span></code> decorator infers the inputs of the combinatorial logic and
the corresponding sensitivity list automatically.</p>
</div>
<div class="section" id="more-information">
<h4>More information<a class="headerlink" href="#more-information" title="Permalink to this headline">¶</a></h4>
<p>For more information about the background and the design decisions regarding
MyHDL decorators, see <a class="reference external" href="http://dev.myhdl.org/meps/mep-100.html">mep-100</a>.</p>
</div>
</div>
<div class="section" id="recommended-style-changes">
<h3>Recommended style changes<a class="headerlink" href="#recommended-style-changes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="decorator-usage">
<h4>Decorator usage<a class="headerlink" href="#decorator-usage" title="Permalink to this headline">¶</a></h4>
<p>The use of decorators has clear advantages in terms of code clarity. Therefore,
it is recommended that all local generators be created using decorators.</p>
</div>
<div class="section" id="edge-specifiers">
<h4>Edge specifiers<a class="headerlink" href="#edge-specifiers" title="Permalink to this headline">¶</a></h4>
<p>Signal edges are typically specified using the <code class="xref py py-func docutils literal notranslate"><span class="pre">posedge</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">negedge</span></code> functions in MyHDL. However, these functions are simply
wrappers around attributes with the same name. The design decision to use
functions have been reviewed and found questionable. In fact, using the
attributes directly instead has significant advantages, listed in order of
increasing significance:</p>
<blockquote>
<div><ul class="simple">
<li>one character less to type</li>
<li>more object-oriented style</li>
<li>less symbols in the <code class="docutils literal notranslate"><span class="pre">myhdl</span></code> namespace</li>
<li>no brackets, which is better for clarity</li>
<li>no function call overhead</li>
</ul>
</div></blockquote>
<p>From MyHDL 0.5 on, it is therefore recommended to use the edge specifier
attributes. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span> <span class="c1"># instead of posedge(clk)</span>
<span class="n">rst</span><span class="o">.</span><span class="n">negedge</span> <span class="c1"># instead of negedge(clk)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="deprecated-features">
<h3>Deprecated features<a class="headerlink" href="#deprecated-features" title="Permalink to this headline">¶</a></h3>
<div class="section" id="edge-specifier-functions">
<h4>Edge specifier functions<a class="headerlink" href="#edge-specifier-functions" title="Permalink to this headline">¶</a></h4>
<p>Functions <code class="xref py py-func docutils literal notranslate"><span class="pre">posedge</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">negedge</span></code> are deprecated. As discussed
before, it is recommended to use the signal attributes with the same name
instead.</p>
<p>In MyHDL 0.5, the functions will be removed from all documentation and
examples. They will be removed from MyHDL in a future version.</p>
</div>
<div class="section" id="processes-function">
<h4>processes() function<a class="headerlink" href="#processes-function" title="Permalink to this headline">¶</a></h4>
<p>Function <code class="xref py py-func docutils literal notranslate"><span class="pre">processes</span></code> is deprecated. It looks up local generator functions and
calls them to create generators. When MyHDL 0.5 decorators are used as
recommended, this functionality becomes superfluous as it is part of the
decorator functionality.</p>
<p>On the other hand, the companion function <a class="reference internal" href="../manual/reference.html#myhdl.instances" title="myhdl.instances"><code class="xref py py-func docutils literal notranslate"><span class="pre">instances</span></code></a> continues to be
relevant and useful. It merely looks up instances in a local namespace. Having
a single lookup function will also improve usability.</p>
<p>In MyHDL 0.5, the <code class="xref py py-func docutils literal notranslate"><span class="pre">processes</span></code> function will be removed from all documentation
and examples. It will be removed from MyHDL in a future version.</p>
</div>
</div>
<div class="section" id="backwards-incompatible-changes">
<h3>Backwards incompatible changes<a class="headerlink" href="#backwards-incompatible-changes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="default-initial-value-of-an-intbv-instance">
<h4>Default initial value of an intbv instance<a class="headerlink" href="#default-initial-value-of-an-intbv-instance" title="Permalink to this headline">¶</a></h4>
<p>It has always been possible to construct an <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> instance without
explicit initial value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">()</span>
</pre></div>
</div>
<p>Prior to MyHDL 0.4, the default initial value was <code class="docutils literal notranslate"><span class="pre">0</span></code>. In MyHDL 0.5, this has
been changed to <code class="docutils literal notranslate"><span class="pre">None</span></code>. This is a first step towards support for <code class="docutils literal notranslate"><span class="pre">X</span></code> and
<code class="docutils literal notranslate"><span class="pre">Z</span></code> functionality as found in other HDLs. This may be occasionally useful :-)
For example, it may be meaningful to initialize memory locations to <code class="docutils literal notranslate"><span class="pre">None</span></code> to
make sure that they will not be read before they have been initialized. If
<code class="docutils literal notranslate"><span class="pre">None</span></code> is supported, it seems also logical to make it the default initial
value, to be interpreted as “No value”.</p>
<p><strong>Warning</strong>: if you have calls like the above in your code, it will probably
fail with MyHDL 0.5, as many integer-like operations are not supported with
<cite>None</cite> values.</p>
<p><strong>Workaround</strong>: change your existing code by using <code class="docutils literal notranslate"><span class="pre">0</span></code> as an explicit initial
value, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="python-version">
<h3>Python version<a class="headerlink" href="#python-version" title="Permalink to this headline">¶</a></h3>
<p>Because of the usage of new features such as decorators, MyHDL 0.5 requires
upgrading to Python 2.4 or higher.</p>
</div>
</div>
<div class="section" id="verilog-conversion">
<h2>Verilog conversion<a class="headerlink" href="#verilog-conversion" title="Permalink to this headline">¶</a></h2>
<div class="section" id="decorator-support">
<h3>Decorator support<a class="headerlink" href="#decorator-support" title="Permalink to this headline">¶</a></h3>
<p>The Verilog converter was enhanced to support the proposed decorators.</p>
</div>
<div class="section" id="mapping-a-list-of-signals-to-a-ram-memory">
<h3>Mapping a list of signals to a RAM memory<a class="headerlink" href="#mapping-a-list-of-signals-to-a-ram-memory" title="Permalink to this headline">¶</a></h3>
<p>Certain synthesis tools can map Verilog memories to memory structures. For
example, this is supported by the Xilinx toolset. To support this interesting
feature, the Verilog converter now maps lists of signals in MyHDL to Verilog
memories.</p>
<p>The following MyHDL example is a ram model that uses a list of signals to model
the internal memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RAM</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">din</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">we</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  Ram model &quot;&quot;&quot;</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">)]</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">we</span><span class="p">:</span>
            <span class="n">mem</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">)]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">din</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
        <span class="n">dout</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">write</span><span class="p">,</span> <span class="n">read</span>
</pre></div>
</div>
<p>With the appropriate signal definitions for the interface ports, it is mapped
by <a class="reference internal" href="../manual/reference.html#myhdl.toVerilog" title="myhdl.toVerilog"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVerilog</span></code></a> to the following Verilog code. Note how the list of signals
<code class="docutils literal notranslate"><span class="pre">mem</span></code> is mapped to a Verilog memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">RAM</span> <span class="p">(</span>
    <span class="n">dout</span><span class="p">,</span>
    <span class="n">din</span><span class="p">,</span>
    <span class="n">addr</span><span class="p">,</span>
    <span class="n">we</span><span class="p">,</span>
    <span class="n">clk</span>
<span class="p">);</span>

<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="n">wire</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="nb">input</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">din</span><span class="p">;</span>
<span class="nb">input</span> <span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">we</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">clk</span><span class="p">;</span>

<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">mem</span> <span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">128</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">_RAM_write</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">we</span><span class="p">)</span> <span class="n">begin</span>
        <span class="n">mem</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">din</span><span class="p">;</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">assign</span> <span class="n">dout</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>

<span class="n">endmodule</span>
</pre></div>
</div>
<p>Lists of signals can also be used in MyHDL to elegantly describe iterative
hierarchical structures. (See the MyHDL manual.) However, there is an important
difference: such signals will have a name at some level of the hierarchy, while
in the case described above, the individual signals are anonymous. The
<a class="reference internal" href="../manual/reference.html#myhdl.toVerilog" title="myhdl.toVerilog"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVerilog</span></code></a> converter detects which case we are in. In the first case,
the individual signals will still be declared in the Verilog output, using the
highest-level hierarchical name. It is only in the second case that the list of
signals is declared as a Verilog memory.</p>
</div>
<div class="section" id="mapping-combinatorial-logic-to-assign-statements">
<h3>Mapping combinatorial logic to assign statements<a class="headerlink" href="#mapping-combinatorial-logic-to-assign-statements" title="Permalink to this headline">¶</a></h3>
<p>When possible, combinatorial logic is now converted to Verilog assign
statements. There are two conditions for this to happen. First, the logic has
to be explicitly described as a combinatorial function using the
<code class="docutils literal notranslate"><span class="pre">&#64;always_comb</span></code> decorator. Secondly, the function has to be simple enough so
that a mapping to assign statements is possible: only signal assignments are
permitted.  Otherwise, a Verilog always block is used as previously.</p>
<p>See the RAM model of the previous section for an example.</p>
<p>This was done because certain synthesis tools require assign statements to
recognize code templates.</p>
</div>
<div class="section" id="mapping-a-tuple-of-integers-to-a-rom-memory">
<h3>Mapping a tuple of integers to a ROM memory<a class="headerlink" href="#mapping-a-tuple-of-integers-to-a-rom-memory" title="Permalink to this headline">¶</a></h3>
<p>Some synthesis tools, such as the Xilinx tool, can infer a ROM memory from a
case statement. <a class="reference internal" href="../manual/reference.html#myhdl.toVerilog" title="myhdl.toVerilog"><code class="xref py py-func docutils literal notranslate"><span class="pre">toVerilog</span></code></a> has been enhanced to do the expansion into a
case statement automatically, based on a higher level description. The rom
access is described in a single line, by indexing into a tuple of integers. The
tuple can be described manually, but also by programmatical means. Note that a
tuple is used instead of a list to stress the read-only character of the
memory.</p>
<p>The following example illustrates this functionality.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rom</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">CONTENT</span><span class="p">):</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">():</span>
        <span class="n">dout</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">CONTENT</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">read</span>

<span class="n">dout</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:])</span>
<span class="n">addr</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">4</span><span class="p">:])</span>
<span class="n">CONTENT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">134</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

<span class="n">toVerilog</span><span class="p">(</span><span class="n">rom</span><span class="p">,</span> <span class="n">dout</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">CONTENT</span><span class="p">)</span>
</pre></div>
</div>
<p>The output Verilog code is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">rom</span> <span class="p">(</span>
    <span class="n">dout</span><span class="p">,</span>
    <span class="n">addr</span>
<span class="p">);</span>

<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">dout</span><span class="p">;</span>
<span class="nb">input</span> <span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">;</span>

<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">_rom_read</span>
    <span class="o">//</span> <span class="n">synthesis</span> <span class="n">parallel_case</span> <span class="n">full_case</span>
    <span class="n">case</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="mi">0</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">17</span><span class="p">;</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">134</span><span class="p">;</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">52</span><span class="p">;</span>
        <span class="n">default</span><span class="p">:</span> <span class="n">dout</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">endcase</span>
<span class="n">end</span>

<span class="n">endmodule</span>
</pre></div>
</div>
</div>
<div class="section" id="support-for-signed-arithmetic">
<h3>Support for signed arithmetic<a class="headerlink" href="#support-for-signed-arithmetic" title="Permalink to this headline">¶</a></h3>
<p>Getting signed representations right in Verilog is tricky. One issue is that a
signed representation is treated as a special case, and unsigned as the rule.
For example, whenever one of the operands in an expression is unsigned, all
others are also treated like unsigned. While this is understandable from a
historical perspective (for backwards compatibility reasons) it is the opposite
from what one expects from a high-level point of view, when working with
negative numbers. The basic problem is that a Verilog user has to deal with
representation explicitly in all cases, even for abstract integer operations.
It would be much better to leave representational issues to a tool.</p>
<p>MyHDL doesn’t make the distinction between signed and unsigned. The
<a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> class can handle any kind of integer, including negative ones.
If required, you can access the 2’s complement representation of an
<a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> object, but for integer operations such a counting, there is no
need to worry about this.</p>
<p>Of course, the Verilog converter has to deal with the representation carefully.
MyHDL 0.4 avoided the issue by simply prohibiting <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects with
negative values. MyHDL 0.5 adds support for negative values and uses the signed
Verilog representation to accomplish this.</p>
<p>The problematic cases are those when signed and unsigned representations are
mixed in Verilog expressions. The converter avoids this by making sure that
signed arithmetic is used whenever one of the operands is signed. Note that
this is exactly the opposite of the Verilog default. More specifically, the
converter may convert an unsigned operand by adding a sign bit and casting to a
signed interpretation, using the Verilog <code class="docutils literal notranslate"><span class="pre">$signed</span></code> function. Operands that
are treated like this are positive <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects, slices and
subscripts of <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code></a> objects, and <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> objects.</p>
<p>Integer constants are treated as a special case. Unsized integer numbers were
always treated as signed numbers in Verilog. However, as their representation
is minimally 32 bits wide, they usually don’t give problems when mixed with
unsigned numbers. Therefore, integer constants don’t cause signed casting of
other operands in the same expression: users would actually find it surprizing
if they did.</p>
</div>
<div class="section" id="support-for-user-defined-verilog-code">
<h3>Support for user-defined Verilog code<a class="headerlink" href="#support-for-user-defined-verilog-code" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>In order to provide a path to implementation, MyHDL code can be converted to
Verilog. However, in some cases the conversion may fail or the result may not
be acceptable. For example:</p>
<ul class="simple">
<li>conversion will fail if the MyHDL code doesn’t follow the rules of the convertible subset</li>
<li>a user may want to explicitly instantiate an existing Verilog module, instead of converting the corresponding MyHDL code</li>
<li>it may be necessary to include technology-dependent modules in the Verilog output</li>
</ul>
<p>As a conclusion, MyHDL users need a method to include user-defined Verilog code
during the conversion process.</p>
</div>
<div class="section" id="solution">
<h4>Solution<a class="headerlink" href="#solution" title="Permalink to this headline">¶</a></h4>
<p>MyHDL 0.5 defines a hook that is understood by <code class="docutils literal notranslate"><span class="pre">toVerilog</span></code> but ignored by the
MyHDL simulator. The hook is called <code class="docutils literal notranslate"><span class="pre">__verilog__</span></code>. Its operation can be
understood as a special return value. When a MyHDL function defines
<code class="docutils literal notranslate"><span class="pre">__verilog__</span></code>, the Verilog converter will use its value instead of the
regular return value.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">__verilog__</span></code> should be a format string that uses keys in its
format specifiers. The keys refer to the variable names in the context of the
string.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">inc_comb</span><span class="p">(</span><span class="n">nextCount</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="n">nextCount</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>

    <span class="n">__verilog__</span> <span class="o">=</span> \
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">assign %(nextCount)s = (%(count)s + 1) %% %(n)s;</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">nextCount</span><span class="o">.</span><span class="n">driven</span> <span class="o">=</span> <span class="s2">&quot;wire&quot;</span>

    <span class="k">return</span> <span class="n">logic</span>
</pre></div>
</div>
<p>In this example, conversion of the <code class="docutils literal notranslate"><span class="pre">inc_comb</span></code> function is bypassed and the
user-defined Verilog code is inserted instead. Note that the user-defined code
refers to signals and parameters in the MyHDL context by using format
specifiers. During conversion, the appropriate hierarchical names and parameter
values will be filled in. Note also that the format specifier indicator <cite>%</cite>
needs to be escaped (by doubling it) if it is required in the user-defined
code.</p>
<p>There is one more issue that needs user attention. Normally, the Verilog
converter infers inputs, internal signals, and outputs. It also detects
undriven and multiple driven signals. To do this, it assumes that signals are
not driven by default. It then processes the code to find out which signals are
driven from where. However, it cannot do this for user-defined code. Without
additional help, this will result in warnings or errors during the inference
process, or in compilation errors from invalid Verilog code. The user should
solve this by setting the <code class="docutils literal notranslate"><span class="pre">driven</span></code> attribute for signals that are driven from
the user-defined code. In the example code above, note the following
assignment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nextCount</span><span class="o">.</span><span class="n">driven</span> <span class="o">=</span> <span class="s2">&quot;wire&quot;</span>
</pre></div>
</div>
<p>This specifies that the <code class="docutils literal notranslate"><span class="pre">nextCount</span></code> signal is driven as a Verilog wire from
this module. The allowed values of the <code class="docutils literal notranslate"><span class="pre">driven</span></code> attribute are <code class="docutils literal notranslate"><span class="pre">&quot;wire&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&quot;reg&quot;</span></code>. The value specifies how the user-defined Verilog code drives the
signal in Verilog. To decide which value to use, consider how the signal should
be declared in Verilog after the user-defined code is inserted.</p>
</div>
<div class="section" id="limitations">
<h4>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h4>
<p>It is not possible to use the <code class="docutils literal notranslate"><span class="pre">__verilog__</span></code> hook in a generator function -
it should be in a classic function. This is because in MyHDL those functions
are completely run (elaborated) before the conversion starts, while generator
functions are not.</p>
</div>
<div class="section" id="more-info">
<h4>More info<a class="headerlink" href="#more-info" title="Permalink to this headline">¶</a></h4>
<p>For more information about the background and the design decisions regarding
user-defined Verilog code, see <a class="reference external" href="http://dev.myhdl.org/meps/mep-101.html">mep-101</a>.</p>
</div>
</div>
<div class="section" id="id2">
<h3>Backwards incompatible changes<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="verilog-conversion-output-filename">
<h4>Verilog conversion output filename<a class="headerlink" href="#verilog-conversion-output-filename" title="Permalink to this headline">¶</a></h4>
<p>A Verilog conversion is performed with a call that looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">instance_name</span> <span class="o">=</span> <span class="n">toVerilog</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>In MyHDL 0.4, the Verilog output filename was called <code class="docutils literal notranslate"><span class="pre">instance_name.v</span></code>. In
MyHDL 0.5, the default output filename is <code class="docutils literal notranslate"><span class="pre">func_name.v</span></code>, where <code class="docutils literal notranslate"><span class="pre">func_name</span></code>
is the name of the function, available as the <code class="docutils literal notranslate"><span class="pre">func.func_name</span></code> attribute.</p>
<p>This was done for the following reasons. The MyHDL 0.4 was overly clever and
therefore complicated. It involves frame handling and parsing the source file
for the assignment pattern. Besides being too clever, it also had awkward
limitations. For example, it was not possible to construct a dynamic name for
the instance, which is very un-Pythonic behavior.</p>
<p>Both the implementation complexity and the limitations are gone with the new
behavior: the name of the top-level function argument is simply used. In
addition, it is now possible to specify a user-defined name for the instance as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">toVerilog</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;my_name&quot;</span>
<span class="n">toVerilog</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">....</span><span class="p">)</span>
</pre></div>
</div>
<p>To support this feature, it was necessary to make toVerilog an instance of a
class with a call interface.</p>
<p><strong>Warning</strong>: When existing converting code is re-run, the Verilog output
filename will be different than in 0.4.</p>
</div>
</div>
</div>
<div class="section" id="simulation">
<h2>Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="performance-optimizations">
<h3>Performance optimizations<a class="headerlink" href="#performance-optimizations" title="Permalink to this headline">¶</a></h3>
<p>To improve the simulation performance of MyHDL, we mainly put our trust in
Python development itself. There are good reasons to be optimistic.</p>
<p>What MyHDL itself can do is to minimize the overhead of the simulation loop. In
MyHDL 0.5, a first step was taken in  this respect.</p>
<p>MyHDL supports a number of “trigger objects”. These are the objects that can
occur in <code class="docutils literal notranslate"><span class="pre">yield</span></code> statements, for example <a class="reference internal" href="../manual/reference.html#myhdl.delay" title="myhdl.delay"><code class="xref py py-class docutils literal notranslate"><span class="pre">delay</span></code></a>, <code class="docutils literal notranslate"><span class="pre">posedge</span></code>,
<a class="reference internal" href="../manual/reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a>, and generator objects. Each of these are handled differently
and so the simulation loop has to account for the object type. Prior to MyHDL
0.5, this type check was explicitly done for each occurrence of a <code class="docutils literal notranslate"><span class="pre">yield</span></code>
statement during simulation. As many generators will loop endlessly, it is
clear that the same things will be checked over and over again, resulting in an
important overhead.</p>
<p>In MyHDL 0.5, all generators are predigested. Certain trigger object patterns
that tend to occur often are given specialized simulation handlers, so that
continuously performing the same type check is avoided. More specifically, they
consist of generators that only contain <code class="docutils literal notranslate"><span class="pre">yield</span></code> statements with a specific
argument. Currently, 5 different kinds of generators are recognized and
accelerated, corresponding to the following <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement arguments:</p>
<blockquote>
<div><ul class="simple">
<li>a <a class="reference internal" href="../manual/reference.html#myhdl.delay" title="myhdl.delay"><code class="xref py py-class docutils literal notranslate"><span class="pre">delay</span></code></a> object</li>
<li>a <a class="reference internal" href="../manual/reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object</li>
<li>a tuple of <a class="reference internal" href="../manual/reference.html#myhdl.Signal" title="myhdl.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> objects</li>
<li>a <code class="docutils literal notranslate"><span class="pre">posedge</span></code> or <code class="docutils literal notranslate"><span class="pre">negedge</span></code> object</li>
<li>a tuple of <code class="docutils literal notranslate"><span class="pre">posedge</span></code> and/or <code class="docutils literal notranslate"><span class="pre">negedge</span></code> objects</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id3">
<h3>Backwards incompatible changes<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="section" id="waveform-tracing-output-filename">
<h4>Waveform tracing output filename<a class="headerlink" href="#waveform-tracing-output-filename" title="Permalink to this headline">¶</a></h4>
<p>Waveform tracing is initiated by a call that looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">instance_name</span> <span class="o">=</span> <span class="n">traceSignals</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>In MyHDL 0.4, the output filename was called <cite>instance_name.vcd</cite>. In MyHDL 0.5,
the default output filename is <cite>func_name.vcd</cite>, where <cite>func_name</cite> is the name
of the function, available as the <cite>func.func_name</cite> attribute.</p>
<p>This was done for the same reasons as in the similar case for <cite>toVerilog</cite>, as
described earlier.</p>
<p>A user-defined name for the output file can be specified as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">traceSignals</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;my_name&quot;</span>
<span class="n">inst</span> <span class="o">=</span> <span class="n">traceSignals</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">....</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Warning</strong>: When existing converting code is re-run, the vcd output filename
will be different than in 0.4.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/whatsnew/0.5.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>