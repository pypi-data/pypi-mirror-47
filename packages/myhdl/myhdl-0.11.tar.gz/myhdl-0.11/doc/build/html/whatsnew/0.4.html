
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What’s new in MyHDL 0.4: Conversion to Verilog &#8212; MyHDL 0.10 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="What’s New in MyHDL 0.3" href="0.3.html" />
    <link rel="prev" title="What’s new in MyHDL 0.5" href="0.5.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MyHDL</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">The MyHDL manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.10.html">What’s new in MyHDL 0.10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python3.html">Python 3 Support</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0.9.html">What’s new in MyHDL 0.9</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.8.html">What’s new in MyHDL 0.8</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.7.html">What’s new in MyHDL 0.7</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.6.html">What’s new in MyHDL 0.6</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.5.html">What’s new in MyHDL 0.5</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">What’s new in MyHDL&nbsp;0.4: Conversion to Verilog</a></li>
<li class="toctree-l1"><a class="reference internal" href="0.3.html">What’s New in MyHDL&nbsp;0.3</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="0.5.html" title="previous chapter">What’s new in MyHDL 0.5</a></li>
      <li>Next: <a href="0.3.html" title="next chapter">What’s New in MyHDL&nbsp;0.3</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-myhdl-0-4-conversion-to-verilog">
<h1>What’s new in MyHDL&nbsp;0.4: Conversion to Verilog<a class="headerlink" href="#what-s-new-in-myhdl-0-4-conversion-to-verilog" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Jan Decaluwe</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>MyHDL&nbsp;0.4 supports the automatic conversion of a subset of MyHDL&nbsp;code to
synthesizable Verilog code. This feature provides a direct path from
Python to an FPGA or ASIC implementation.</p>
<p>MyHDL&nbsp;aims to be a complete design language, for tasks such as high
level modeling and verification, but also for implementation. However,
prior to 0.4 a user had to translate MyHDL&nbsp;code manually to Verilog or
VHDL. Needless to say, this was inconvenient. With MyHDL0.4, this manual
step is no longer necessary.</p>
</div>
<div class="section" id="solution-description">
<h2>Solution description<a class="headerlink" href="#solution-description" title="Permalink to this headline">¶</a></h2>
<p>The solution works as follows. The hardware description should be
modeled in MyHDL&nbsp;style, and satisfy certain constraints that are typical
for implementation-oriented hardware modeling. Subsequently, such a
design is converted to an equivalent model in the Verilog language,
using the function <code class="xref py py-func docutils literal notranslate"><span class="pre">toVerilog</span></code> from the MyHDLlibrary. Finally, a
third-party <em>synthesis tool</em> is used to convert the Verilog design to a
gate implementation for an ASIC or FPGA. There are a number of Verilog
synthesis tools available, varying in price, capabilities, and target
implementation technology.</p>
<p>The conversion does not start from source files, but from a design that
has been <em>elaborated</em> by the Python interpreter. The converter uses the
Python profiler to track the interpreter’s operation and to infer the
design structure and name spaces. It then selectively compiles pieces of
source code for additional analysis and for conversion. This is done
using the Python compiler package.</p>
</div>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-design-is-converted-after-elaboration">
<h3>The design is converted after elaboration<a class="headerlink" href="#the-design-is-converted-after-elaboration" title="Permalink to this headline">¶</a></h3>
<p><em>Elaboration</em> refers to the initial processing of a hardware description
to achieve a representation of a design instance that is ready for
simulation or synthesis. In particular, structural parameters and
constructs are processed in this step. In MyHDL, the Python interpreter
itself is used for elaboration. A <code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code> object is
constructed with elaborated design instances as arguments. Likewise, the
Verilog conversion works on an elaborated design instance. The Python
interpreter is thus used as much as possible.</p>
</div>
<div class="section" id="the-structural-description-can-be-arbitrarily-complex-and-hierarchical">
<h3>The structural description can be arbitrarily complex and hierarchical<a class="headerlink" href="#the-structural-description-can-be-arbitrarily-complex-and-hierarchical" title="Permalink to this headline">¶</a></h3>
<p>As the conversion works on an elaborated design instance, any modeling
constraints only apply to the leaf elements of the design structure,
that is, the co-operating generators. In other words, there are no
restrictions on the description of the design structure: Python’s full
power can be used for that purpose. Also, the design hierarchy can be
arbitrarily deep.</p>
</div>
<div class="section" id="generators-are-mapped-to-verilog-always-or-initial-blocks">
<h3>Generators are mapped to Verilog always or initial blocks<a class="headerlink" href="#generators-are-mapped-to-verilog-always-or-initial-blocks" title="Permalink to this headline">¶</a></h3>
<p>The converter analyzes the code of each generator and maps it to a
Verilog <code class="docutils literal notranslate"><span class="pre">always</span></code> blocks if possible, and to an <code class="docutils literal notranslate"><span class="pre">initial</span></code> block
otherwise. The converted Verilog design will be a flat “net list of
blocks”.</p>
</div>
<div class="section" id="the-verilog-module-interface-is-inferred-from-signal-usage">
<h3>The Verilog module interface is inferred from signal usage<a class="headerlink" href="#the-verilog-module-interface-is-inferred-from-signal-usage" title="Permalink to this headline">¶</a></h3>
<p>In MyHDL, the input or output direction of interface signals is not
explicitly declared. The converter investigates signal usage in the
design hierarchy to infer whether a signal is used as input, output, or
as an internal signal. Internal signals are given a hierarchical name in
the Verilog output.</p>
</div>
<div class="section" id="function-calls-are-mapped-to-a-unique-verilog-function-or-task-call">
<h3>Function calls are mapped to a unique Verilog function or task call<a class="headerlink" href="#function-calls-are-mapped-to-a-unique-verilog-function-or-task-call" title="Permalink to this headline">¶</a></h3>
<p>The converter analyzes function calls and function code to see if they
should be mapped to Verilog functions or to tasks. Python functions are
much more powerful than Verilog subprograms; for example, they are
inherently generic, and they can be called with named association. To
support this power in Verilog, a unique Verilog function or task is
generated per Python function call.</p>
</div>
<div class="section" id="if-then-else-structures-may-be-mapped-to-verilog-case-statements">
<h3>If-then-else structures may be mapped to Verilog case statements<a class="headerlink" href="#if-then-else-structures-may-be-mapped-to-verilog-case-statements" title="Permalink to this headline">¶</a></h3>
<p>Python does not provide a case statement. However, the converter
recognizes if-then-else structures in which a variable is sequentially
compared to items of an enumeration type, and maps such a structure to a
Verilog case statement with the appropriate synthesis attributes.</p>
</div>
<div class="section" id="choice-of-encoding-schemes-for-enumeration-types">
<h3>Choice of encoding schemes for enumeration types<a class="headerlink" href="#choice-of-encoding-schemes-for-enumeration-types" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code> function in MyHDL&nbsp;returns an enumeration type. This
function takes an additional parameter <code class="docutils literal notranslate"><span class="pre">encoding</span></code> that specifies the
desired encoding in the implementation: binary, one hot, or one cold.
The Verilog converter generates the appropriate code.</p>
</div>
</div>
<div class="section" id="the-convertible-subset">
<h2>The convertible subset<a class="headerlink" href="#the-convertible-subset" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Unsurprisingly, not all MyHDL&nbsp;code can be converted to Verilog. In fact,
there are very important restrictions. As the goal of the conversion
functionality is implementation, this should not be a big issue: anyone
familiar with synthesis is used to similar restrictions in the
<em>synthesizable subset</em> of Verilog and VHDL. The converter attempts to
issue clear error messages when it encounters a construct that cannot be
converted.</p>
<p>In practice, the synthesizable subset usually refers to RTL synthesis,
which is by far the most popular type of synthesis today. There are
industry standards that define the RTL synthesis subset. However, those
were not used as a model for the restrictions of the MyHDL converter,
but as a minimal starting point. On that basis, whenever it was judged
easy or useful to support an additional feature, this was done. For
example, it is actually easier to convert <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#while" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> loops than
<a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#for" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> loops even though they are not RTL-synthesizable. As
another example, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> is supported because it’s so useful
for debugging, even though it’s not synthesizable. In summary, the
convertible subset is a superset of the standard RTL synthesis subset,
and supports synthesis tools with more advanced capabilities, such as
behavioral synthesis.</p>
<p>Recall that any restrictions only apply to the design post elaboration.
In practice, this means that they apply only to the code of the
generators, that are the leaf functional blocks in a MyHDL design.</p>
</div>
<div class="section" id="coding-style">
<h3>Coding style<a class="headerlink" href="#coding-style" title="Permalink to this headline">¶</a></h3>
<p>A natural restriction on convertible code is that it should be written
in MyHDL style: cooperating generators, communicating through signals,
and with <code class="docutils literal notranslate"><span class="pre">yield</span></code> statements specifying wait points and resume
conditions. Supported resume conditions are a signal edge, a signal
change, or a tuple of such conditions.</p>
</div>
<div class="section" id="supported-types">
<h3>Supported types<a class="headerlink" href="#supported-types" title="Permalink to this headline">¶</a></h3>
<p>The most important restriction regards object types. Verilog is an
almost typeless language, while Python is strongly (albeit dynamically)
typed. The converter has to infer the types of names used in the code,
and map those names to Verilog variables.</p>
<p>Only a limited amount of types can be converted. Python <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code> objects are mapped to Verilog integers. All other
supported types are mapped to Verilog regs (or wires), and therefore
need to have a defined bit width. The supported types are the Python
<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> type, the MyHDL <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> type, and MyHDL enumeration
types returned by function <code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code>. The latter objects can also be
used as the base object of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code>.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> objects must be constructed so that a bit width can be
inferred. This can be done by specifying minimum and maximum values,
e.g. as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, a slice can be taken from an <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">N</span><span class="p">:]</span>
</pre></div>
</div>
<p>Such as slice returns a new <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object, with minimum value
<code class="docutils literal notranslate"><span class="pre">0</span></code> , and maximum value <code class="docutils literal notranslate"><span class="pre">2**N</span></code>.</p>
</div>
<div class="section" id="supported-statements">
<h3>Supported statements<a class="headerlink" href="#supported-statements" title="Permalink to this headline">¶</a></h3>
<p>The following is a list of the statements that are supported by the
Verilog converter, possibly qualified with restrictions or usage notes.</p>
<p>The <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#break" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> statement.</p>
<p>The <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#continue" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> statement.</p>
<p>The <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#def" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> statement.</p>
<dl class="docutils">
<dt>The <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#for" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> statement.</dt>
<dd>The only supported iteration scheme is iterating through sequences
of integers returned by built-in function <code class="xref py py-func docutils literal notranslate"><span class="pre">range</span></code> or
MyHDLfunction <code class="xref py py-func docutils literal notranslate"><span class="pre">downrange</span></code>. The optional <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#else" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> clause
is not supported.</dd>
<dt>The <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#if" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> statement.</dt>
<dd><a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#if" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#elif" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">elif</span></code></a>, and <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#else" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> clauses are
fully supported.</dd>
</dl>
<p>The <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#pass" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a> statement.</p>
<dl class="docutils">
<dt>The <code class="xref std std-keyword docutils literal notranslate"><span class="pre">print</span></code> statement.</dt>
<dd>When printing an interpolated string, the format specifiers are
copied verbatim to the Verilog output. Printing to a file (with
syntax <code class="docutils literal notranslate"><span class="pre">’&gt;&gt;’</span></code>) is not supported.</dd>
<dt>The <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#raise" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> statement.</dt>
<dd>This statement is mapped to Verilog statements that end the
simulation with an error message.</dd>
</dl>
<p>The <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#return" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> statement.</p>
<dl class="docutils">
<dt>The <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#yield" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement.</dt>
<dd>The yielded expression can be a signal, a signal edge as specified
by MyHDL&nbsp;functions <code class="xref py py-func docutils literal notranslate"><span class="pre">posedge</span></code> or <code class="xref py py-func docutils literal notranslate"><span class="pre">negedge</span></code>, or a tuple of
signals and edge specifications.</dd>
<dt>The <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#while" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> statement.</dt>
<dd>The optional <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#else" title="(in Python v3.7)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> clause is not supported.</dd>
</dl>
</div>
</div>
<div class="section" id="methodology-notes">
<h2>Methodology notes<a class="headerlink" href="#methodology-notes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="simulation">
<h3>Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline">¶</a></h3>
<p>In the Python philosophy, the run-time rules. The Python compiler
doesn’t attempt to detect a lot of errors beyond syntax errors, which
given Python’s ultra-dynamic nature would be an almost impossible task
anyway. To verify a Python program, one should run it, preferably using
unit testing to verify each feature.</p>
<p>The same philosophy should be used when converting a MyHDL description
to Verilog: make sure the simulation runs fine first. Although the
converter checks many things and attempts to issue clear error messages,
there is no guarantee that it does a meaningful job unless the
simulation runs fine.</p>
</div>
<div class="section" id="conversion-output-verification">
<h3>Conversion output verification<a class="headerlink" href="#conversion-output-verification" title="Permalink to this headline">¶</a></h3>
<p>It is always prudent to verify the converted Verilog output. To make
this task easier, the converter also generates a test bench that makes
it possible to simulate the Verilog design using the Verilog
co-simulation interface. This permits one to verify the Verilog code with
the same test bench used for the MyHDL&nbsp;code. This is also how the
Verilog converter development is being verified.</p>
</div>
<div class="section" id="assignment-issues">
<h3>Assignment issues<a class="headerlink" href="#assignment-issues" title="Permalink to this headline">¶</a></h3>
<div class="section" id="name-assignment-in-python">
<h4>Name assignment in Python<a class="headerlink" href="#name-assignment-in-python" title="Permalink to this headline">¶</a></h4>
<p>Name assignment in Python is a different concept than in many other
languages. This point is very important for effective modeling in
Python, and even more so for synthesizable MyHDL&nbsp;code. Therefore, the
issues are discussed here explicitly.</p>
<p>Consider the following name assignments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>a = 4
a = ``a string&#39;&#39;
a = False
</pre></div>
</div>
<p>In many languages, the meaning would be that an existing variable <code class="docutils literal notranslate"><span class="pre">a</span></code>
gets a number of different values. In Python, such a concept of a
variable doesn’t exist. Instead, assignment merely creates a new binding
of a name to a certain object, that replaces any previous binding. So in
the example, the name <code class="docutils literal notranslate"><span class="pre">a</span></code> is bound a number of different objects in
sequence.</p>
<p>The Verilog converter has to investigate name assignment and usage in
MyHDL&nbsp;code, and to map names to Verilog variables. To achieve that, it
tries to infer the type and possibly the bit width of each expression
that is assigned to a name.</p>
<p>Multiple assignments to the same name can be supported if it can be
determined that a consistent type and bit width is being used in the
assignments. This can be done for boolean expressions, numeric
expressions, and enumeration type literals. In Verilog, the
corresponding name is mapped to a single bit <code class="docutils literal notranslate"><span class="pre">reg</span></code>, an <code class="docutils literal notranslate"><span class="pre">integer</span></code>, or
a <code class="docutils literal notranslate"><span class="pre">reg</span></code> with the appropriate width, respectively.</p>
<p>In other cases, a single assignment should be used when an object is
created. Subsequent value changes are then achieved by modification of
an existing object. This technique should be used for <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> objects.</p>
</div>
<div class="section" id="signal-assignment">
<h4>Signal assignment<a class="headerlink" href="#signal-assignment" title="Permalink to this headline">¶</a></h4>
<p>Signal assignment in MyHDL&nbsp;is implemented using attribute assignment to
attribute <code class="docutils literal notranslate"><span class="pre">next</span></code>. Value changes are thus modeled by modification of
the existing object. The converter investigates the <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code>
object to infer the type and bit width of the corresponding Verilog
variable.</p>
</div>
<div class="section" id="intbv-objects">
<h4><code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> objects<a class="headerlink" href="#intbv-objects" title="Permalink to this headline">¶</a></h4>
<p>Type <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> is likely to be the workhorse for synthesizable
modeling in MyHDL. An <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> instance behaves like a (mutable)
integer whose individual bits can be accessed and modified. Also, it is
possible to constrain its set of values. In addition to error checking,
this makes it possible to infer a bit width, which is required for
implementation.</p>
<p>In Verilog, an <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> instance will be mapped to a <code class="docutils literal notranslate"><span class="pre">reg</span></code> with
an appropriate width. As noted before, it is not possible to modify its
value using name assignment. In the following, we will show how it can
be done instead. Consider:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">8</span><span class="p">:]</span>
</pre></div>
</div>
<p>This is an <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> object with initial value <code class="docutils literal notranslate"><span class="pre">0</span></code> and bit width
8. The change its value to <code class="docutils literal notranslate"><span class="pre">5</span></code>, we can use slice assignment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>The same can be achieved by leaving the bit width unspecified, which has
the meaning to change “all” bits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Often the new value will depend on the old one. For example, to
increment an <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> with the technique above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Python also provides <em>augmented</em> assignment operators, which can be used
to implement in-place operations. These are supported on <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code>
objects and by the converter, so that the increment can also be done as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="converter-usage">
<h2>Converter usage<a class="headerlink" href="#converter-usage" title="Permalink to this headline">¶</a></h2>
<p>We will demonstrate the conversion process by showing some examples.</p>
<div class="section" id="a-small-design-with-a-single-generator">
<h3>A small design with a single generator<a class="headerlink" href="#a-small-design-with-a-single-generator" title="Permalink to this headline">¶</a></h3>
<p>Consider the following MyHDL code for an incrementer module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Incrementer with enable.</span>

<span class="sd">    count -- output</span>
<span class="sd">    enable -- control input, increment when 1</span>
<span class="sd">    clock -- clock input</span>
<span class="sd">    reset -- asynchronous reset input</span>
<span class="sd">    n -- counter max value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">incProcess</span><span class="p">():</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">posedge</span><span class="p">(</span><span class="n">clock</span><span class="p">),</span> <span class="n">negedge</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reset</span> <span class="o">==</span> <span class="n">ACTIVE_LOW</span><span class="p">:</span>
                <span class="n">count</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">enable</span><span class="p">:</span>
                    <span class="n">count</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">incProcess</span><span class="p">()</span>
</pre></div>
</div>
<p>In Verilog terminology, function <code class="xref py py-func docutils literal notranslate"><span class="pre">inc</span></code> corresponds to a module,
while generator function <code class="xref py py-func docutils literal notranslate"><span class="pre">incProcess</span></code> roughly corresponds to an
always block.</p>
<p>Normally, to simulate the design, we would “elaborate” an instance as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">m</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">m</span><span class="p">:])</span>
<span class="n">enable</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">clock</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>

<span class="n">inc_inst</span> <span class="o">=</span> <span class="n">inc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">incinst</span></code> is an elaborated design instance that can be simulated. To
convert it to Verilog, we change the last line as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inc_inst</span> <span class="o">=</span> <span class="n">toVerilog</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, this creates an instance that can be simulated, but as a side
effect, it also generates an equivalent Verilog module in file . The
Verilog code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">inc_inst</span> <span class="p">(</span>
    <span class="n">count</span><span class="p">,</span>
    <span class="n">enable</span><span class="p">,</span>
    <span class="n">clock</span><span class="p">,</span>
    <span class="n">reset</span>
<span class="p">);</span>

<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">count</span><span class="p">;</span>
<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">count</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">enable</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">clock</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">reset</span><span class="p">;</span>


<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">posedge</span> <span class="n">clock</span> <span class="ow">or</span> <span class="n">negedge</span> <span class="n">reset</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">_MYHDL1_BLOCK</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">reset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="n">begin</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">end</span>
    <span class="k">else</span> <span class="n">begin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="n">begin</span>
            <span class="n">count</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">);</span>
        <span class="n">end</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">endmodule</span>
</pre></div>
</div>
<p>You can see the module interface and the always block, as expected from
the MyHDL design.</p>
</div>
<div class="section" id="converting-a-generator-directly">
<h3>Converting a generator directly<a class="headerlink" href="#converting-a-generator-directly" title="Permalink to this headline">¶</a></h3>
<p>It is also possible to convert a generator directly. For example,
consider the following generator function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bin2gray</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Gray encoder.</span>

<span class="sd">    B -- input intbv signal, binary encoded</span>
<span class="sd">    G -- output intbv signal, gray encoded</span>
<span class="sd">    width -- bit width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Bext</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">B</span>
        <span class="n">Bext</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">B</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Bext</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">Bext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>As before, you can create an instance and convert to Verilog as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">width</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="p">:])</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">width</span><span class="p">:])</span>

<span class="n">bin2gray_inst</span> <span class="o">=</span> <span class="n">toVerilog</span><span class="p">(</span><span class="n">bin2gray</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p>The generated Verilog code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">bin2gray_inst</span> <span class="p">(</span>
    <span class="n">B</span><span class="p">,</span>
    <span class="n">G</span>
<span class="p">);</span>

<span class="nb">input</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">B</span><span class="p">;</span>
<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">G</span><span class="p">;</span>
<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">G</span><span class="p">;</span>

<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">_MYHDL1_BLOCK</span>
    <span class="n">integer</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">reg</span> <span class="p">[</span><span class="mi">9</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">Bext</span><span class="p">;</span>
    <span class="n">Bext</span><span class="p">[</span><span class="mi">9</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">begin</span>
        <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">Bext</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">^</span> <span class="n">Bext</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">endmodule</span>
</pre></div>
</div>
</div>
<div class="section" id="a-hierarchical-design">
<h3>A hierarchical design<a class="headerlink" href="#a-hierarchical-design" title="Permalink to this headline">¶</a></h3>
<p>The hierarchy of convertible designs can be arbitrarily deep.</p>
<p>For example, suppose we want to design an incrementer with Gray code
output. Using the designs from previous sections, we can proceed as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GrayInc</span><span class="p">(</span><span class="n">graycnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>

    <span class="n">bincnt</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">()[</span><span class="n">width</span><span class="p">:])</span>

    <span class="n">INC_1</span> <span class="o">=</span> <span class="n">inc</span><span class="p">(</span><span class="n">bincnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="n">width</span><span class="p">)</span>
    <span class="n">BIN2GRAY_1</span> <span class="o">=</span> <span class="n">bin2gray</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="n">bincnt</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">graycnt</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">INC_1</span><span class="p">,</span> <span class="n">BIN2GRAY_1</span>
</pre></div>
</div>
<p>According to Gray code properties, only a single bit will change in
consecutive values. However, as the <code class="docutils literal notranslate"><span class="pre">bin2gray</span></code> module is
combinatorial, the output bits may have transient glitches, which may
not be desirable. To solve this, let’s create an additional level of
hierarchy and add an output register to the design. (This will create an
additional latency of a clock cycle, which may not be acceptable, but we
will ignore that here.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GrayIncReg</span><span class="p">(</span><span class="n">graycnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>

    <span class="n">graycnt_comb</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">()[</span><span class="n">width</span><span class="p">:])</span>

    <span class="n">GRAY_INC_1</span> <span class="o">=</span> <span class="n">GrayInc</span><span class="p">(</span><span class="n">graycnt_comb</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reg</span><span class="p">():</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">posedge</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span>
            <span class="n">graycnt</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">graycnt_comb</span>
    <span class="n">REG_1</span> <span class="o">=</span> <span class="n">reg</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">GRAY_INC_1</span><span class="p">,</span> <span class="n">REG_1</span>
</pre></div>
</div>
<p>We can convert this hierarchical design as before:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">width</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">graycnt</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">()[</span><span class="n">width</span><span class="p">:])</span>
<span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>

<span class="n">GRAY_INC_REG_1</span> <span class="o">=</span> <span class="n">toVerilog</span><span class="p">(</span><span class="n">GrayIncReg</span><span class="p">,</span> <span class="n">graycnt</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p>The Verilog output code looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">GRAY_INC_REG_1</span> <span class="p">(</span>
    <span class="n">graycnt</span><span class="p">,</span>
    <span class="n">enable</span><span class="p">,</span>
    <span class="n">clock</span><span class="p">,</span>
    <span class="n">reset</span>
<span class="p">);</span>

<span class="n">output</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">graycnt</span><span class="p">;</span>
<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">graycnt</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">enable</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">clock</span><span class="p">;</span>
<span class="nb">input</span> <span class="n">reset</span><span class="p">;</span>

<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">graycnt_comb</span><span class="p">;</span>
<span class="n">reg</span> <span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">_GRAY_INC_1_bincnt</span><span class="p">;</span>

<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">posedge</span> <span class="n">clock</span> <span class="ow">or</span> <span class="n">negedge</span> <span class="n">reset</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">_MYHDL1_BLOCK</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">reset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="n">begin</span>
        <span class="n">_GRAY_INC_1_bincnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">end</span>
    <span class="k">else</span> <span class="n">begin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="n">begin</span>
            <span class="n">_GRAY_INC_1_bincnt</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">_GRAY_INC_1_bincnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">);</span>
        <span class="n">end</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">_GRAY_INC_1_bincnt</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">_MYHDL4_BLOCK</span>
    <span class="n">integer</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">reg</span> <span class="p">[</span><span class="mi">9</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">Bext</span><span class="p">;</span>
    <span class="n">Bext</span><span class="p">[</span><span class="mi">9</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_GRAY_INC_1_bincnt</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">begin</span>
        <span class="n">graycnt_comb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">Bext</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">^</span> <span class="n">Bext</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">always</span> <span class="o">@</span><span class="p">(</span><span class="n">posedge</span> <span class="n">clock</span><span class="p">)</span> <span class="n">begin</span><span class="p">:</span> <span class="n">_MYHDL9_BLOCK</span>
    <span class="n">graycnt</span> <span class="o">&lt;=</span> <span class="n">graycnt_comb</span><span class="p">;</span>
<span class="n">end</span>

<span class="n">endmodule</span>
</pre></div>
</div>
<p>Note that the output is a flat “net list of blocks”, and that
hierarchical signal names are generated as necessary.</p>
</div>
<div class="section" id="optimizations-for-finite-state-machines">
<h3>Optimizations for finite state machines<a class="headerlink" href="#optimizations-for-finite-state-machines" title="Permalink to this headline">¶</a></h3>
<p>As often in hardware design, finite state machines deserve special
attention.</p>
<p>In Verilog and VHDL, finite state machines are typically described using
case statements. Python doesn’t have a case statement, but the converter
recognizes particular if-then-else structures and maps them to case
statements. This optimization occurs when a variable whose type is an
enumerated type is sequentially tested against enumeration items in an
if-then-else structure. Also, the appropriate synthesis pragmas for
efficient synthesis are generated in the Verilog code.</p>
<p>As a further optimization, function <code class="xref py py-func docutils literal notranslate"><span class="pre">enum</span></code> was enhanced to support
alternative encoding schemes elegantly, using an additional parameter
<code class="docutils literal notranslate"><span class="pre">encoding</span></code>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t_State</span> <span class="o">=</span> <span class="n">enum</span><span class="p">(</span><span class="s1">&#39;SEARCH&#39;</span><span class="p">,</span> <span class="s1">&#39;CONFIRM&#39;</span><span class="p">,</span> <span class="s1">&#39;SYNC&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;one_hot&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The default encoding is <code class="docutils literal notranslate"><span class="pre">’binary’</span></code>; the other possibilities are
<code class="docutils literal notranslate"><span class="pre">’onehot’</span></code> and <code class="docutils literal notranslate"><span class="pre">’onecold’</span></code>. This parameter only affects the
conversion output, not the behavior of the type. The generated Verilog
code for case statements is optimized for an efficient implementation
according to the encoding. Note that in contrast, a Verilog designer has
to make nontrivial code changes to implement a different encoding
scheme.</p>
<p>As an example, consider the following finite state machine, whose state
variable uses the enumeration type defined above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FRAME_SIZE</span> <span class="o">=</span> <span class="mi">8</span>

<span class="k">def</span> <span class="nf">FramerCtrl</span><span class="p">(</span><span class="n">SOF</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">syncFlag</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset_n</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Framing control FSM.</span>

<span class="sd">    SOF -- start-of-frame output bit</span>
<span class="sd">    state -- FramerState output</span>
<span class="sd">    syncFlag -- sync pattern found indication input</span>
<span class="sd">    clk -- clock input</span>
<span class="sd">    reset_n -- active low reset</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># position in frame</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">posedge</span><span class="p">(</span><span class="n">clk</span><span class="p">),</span> <span class="n">negedge</span><span class="p">(</span><span class="n">reset_n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reset_n</span> <span class="o">==</span> <span class="n">ACTIVE_LOW</span><span class="p">:</span>
            <span class="n">SOF</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">SOF</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span><span class="p">:</span>
                <span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">syncFlag</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">CONFIRM</span>
            <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="n">t_State</span><span class="o">.</span><span class="n">CONFIRM</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">syncFlag</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SYNC</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span>
            <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SYNC</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">syncFlag</span><span class="p">:</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span>
                <span class="n">SOF</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">FRAME_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Undefined state&quot;</span><span class="p">)</span>
            <span class="n">index</span><span class="p">[:]</span><span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">FRAME_SIZE</span>
</pre></div>
</div>
<p>The conversion is done as before:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SOF</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">syncFlag</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">clk</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">reset_n</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">t_State</span><span class="o">.</span><span class="n">SEARCH</span><span class="p">)</span>
<span class="n">framerctrl_inst</span> <span class="o">=</span> <span class="n">toVerilog</span><span class="p">(</span><span class="n">FramerCtrl</span><span class="p">,</span> <span class="n">SOF</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">syncFlag</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset_n</span><span class="p">)</span>
</pre></div>
</div>
<p>The Verilog output looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>module framerctrl_inst (
    SOF,
    state,
    syncFlag,
    clk,
    reset_n
);
output SOF;
reg SOF;
output [2:0] state;
reg [2:0] state;
input syncFlag;
input clk;
input reset_n;

always @(posedge clk or negedge reset_n) begin: _MYHDL1_BLOCK
    reg [3-1:0] index;
    if ((reset_n == 0)) begin
        SOF &lt;= 0;
        index[3-1:0] = 0;
        state &lt;= 3&#39;b001;
    end
    else begin
        SOF &lt;= 0;
        // synthesis parallel_case full_case
        casez (state)
            3&#39;b??1: begin
                index[3-1:0] = 0;
                if (syncFlag) begin
                    state &lt;= 3&#39;b010;
                end
            end
            3&#39;b?1?: begin
                if ((index == 0)) begin
                    if (syncFlag) begin
                        state &lt;= 3&#39;b100;
                    end
                    else begin
                        state &lt;= 3&#39;b001;
                    end
                end
            end
            3&#39;b1??: begin
                if ((index == 0)) begin
                    if ((!syncFlag)) begin
                        state &lt;= 3&#39;b001;
                    end
                end
                SOF &lt;= (index == (8 - 1));
            end
            default: begin
                $display(&quot;Verilog: ValueError(Undefined state)&quot;);
                $finish;
            end
        endcase
        index[3-1:0] = ((index + 1) % 8);
    end
end
endmodule
</pre></div>
</div>
</div>
</div>
<div class="section" id="known-issues">
<h2>Known issues<a class="headerlink" href="#known-issues" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Negative values of <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> instances are not supported.</dt>
<dd>The <code class="xref py py-class docutils literal notranslate"><span class="pre">intbv</span></code> class is quite capable of representing negative
values. However, the <code class="docutils literal notranslate"><span class="pre">signed</span></code> type support in Verilog is
relatively recent and mapping to it may be tricky. In my judgment,
this was not the most urgent requirement, so I decided to leave this
for later.</dd>
<dt>Verilog integers are 32 bit wide</dt>
<dd>Usually, Verilog integers are 32 bit wide. In contrast, Python is
moving toward integers with undefined width. Python <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code> variables are mapped to Verilog integers; so for
values wider than 32 bit this mapping is incorrect.</dd>
<dt>Synthesis pragmas are specified as Verilog comments.</dt>
<dd>The recommended way to specify synthesis pragmas in Verilog is
through attribute lists. However, my Verilog simulator (Icarus)
doesn’t support them for <code class="docutils literal notranslate"><span class="pre">case</span></code> statements (to specify
<code class="docutils literal notranslate"><span class="pre">parallelcase</span></code> and <code class="docutils literal notranslate"><span class="pre">fullcase</span></code> pragmas). Therefore, I still used
the old but deprecated method of synthesis pragmas in Verilog
comments.</dd>
<dt>Inconsistent place of the sensitivity list inferred from <code class="docutils literal notranslate"><span class="pre">alwayscomb</span></code>.</dt>
<dd>The semantics of <code class="docutils literal notranslate"><span class="pre">alwayscomb</span></code>, both in Verilog and MyHDL, is to
have an implicit sensitivity list at the end of the code. However,
this may not be synthesizable. Therefore, the inferred sensitivity
list is put at the top of the corresponding <code class="docutils literal notranslate"><span class="pre">always</span></code> block. This
may cause inconsistent behavior at the start of the simulation. The
workaround is to create events at time 0.</dd>
<dt>Non-blocking assignments to task arguments don’t work.</dt>
<dd>I didn’t get non-blocking (signal) assignments to task arguments to
work. I don’t know yet whether the issue is my own, a Verilog issue,
or an issue with my Verilog simulator Icarus. I’ll need to check
this further.</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Jan Decaluwe.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/whatsnew/0.4.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>