
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="Orange Textable documentation, Count widget" name="description" />
<meta content="Orange, Textable, documentation, Count, widget" name="keywords" />

    <title>Count &#8212; Textable v3.1.0 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Length" href="length.html" />
    <link rel="prev" title="Table construction widgets" href="table_construction_widgets.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="length.html" title="Length"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="table_construction_widgets.html" title="Table construction widgets"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Textable v3.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="reference.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="table_construction_widgets.html" accesskey="U">Table construction widgets</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="count">
<span id="id1"></span><h1>Count<a class="headerlink" href="#count" title="Permalink to this headline">¶</a></h1>
<img alt="_images/Count_54.png" src="_images/Count_54.png" />
<p>Count segment types.</p>
<div class="section" id="signals">
<h2>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h2>
<p>Inputs:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Segmentation</span></code> (multiple)</p>
<p>Segmentation whose segments constitute the units to be counted or
the contexts in which the units will be counted</p>
</li>
</ul>
<p>Outputs:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Pivot</span> <span class="pre">Crosstab</span></code></p>
<p>Table displaying the absolute frequency of units</p>
</li>
</ul>
</div>
<div class="section" id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>This widget inputs one or several segmentations, counts the frequency of
segments defined by one of the segmentations (potentially within segments
defined by another), and sends the result in the form of a <em>contingency
table</em> (or <em>co-occurrence matrix</em> or also <em>term–document matrix</em>).</p>
<p>The contingency tables produced by this widget are of <em>PivotCrosstab</em> type,
a subtype of the generic <em>Table</em> format (see <a class="reference internal" href="convert.html#convert"><span class="std std-ref">Convert</span></a> widget, section
<a class="reference internal" href="convert.html#anchor-to-table-formats"><span class="std std-ref">Table formats</span></a>). In such a table, each column
corresponds to a <em>unit</em> type, each line corresponds to a <em>context</em> type, and
the cell at the intersection of a given column and line contains the count (or
<em>absolute frequency</em>, or also number of occurrences) of this unit type in this
context type.</p>
<p>To take a simple example, consider two segmentations of the string <em>a simple
example</em> <a class="footnote-reference" href="#id5" id="id2">[1]</a>:</p>
<ol class="upperalpha simple">
<li>label = <em>words</em></li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="12%" />
<col width="9%" />
<col width="31%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">content</th>
<th class="head">start</th>
<th class="head">end</th>
<th class="head"><em>part of speech</em></th>
<th class="head"><em>word category</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>a</em></td>
<td>1</td>
<td>1</td>
<td><em>article</em></td>
<td><em>grammatical</em></td>
</tr>
<tr class="row-odd"><td><em>simple</em></td>
<td>3</td>
<td>8</td>
<td><em>adjective</em></td>
<td><em>lexical</em></td>
</tr>
<tr class="row-even"><td><em>example</em></td>
<td>10</td>
<td>16</td>
<td><em>noun</em></td>
<td><em>lexical</em></td>
</tr>
</tbody>
</table>
<ol class="upperalpha simple" start="2">
<li>label = <em>letters</em> (extract)</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="18%" />
<col width="13%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">content</th>
<th class="head">start</th>
<th class="head">end</th>
<th class="head"><em>letter category</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>a</em></td>
<td>1</td>
<td>1</td>
<td><em>vowel</em></td>
</tr>
<tr class="row-odd"><td><em>s</em></td>
<td>3</td>
<td>3</td>
<td><em>consonant</em></td>
</tr>
<tr class="row-even"><td><em>i</em></td>
<td>4</td>
<td>4</td>
<td><em>vowel</em></td>
</tr>
<tr class="row-odd"><td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="row-even"><td><em>e</em></td>
<td>16</td>
<td>16</td>
<td><em>vowel</em></td>
</tr>
</tbody>
</table>
<p>Typically, we could define unit types based on the content of the segments
of the <em>letters</em> segmentations, and context types based on the content of
the segments of the <em>words</em> segmentations. Counting these unit types in these
contexts types would thus produce the following contingency table <a class="footnote-reference" href="#id6" id="id3">[2]</a>:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="27%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>a</em></th>
<th class="head"><em>s</em></th>
<th class="head"><em>i</em></th>
<th class="head"><em>m</em></th>
<th class="head"><em>p</em></th>
<th class="head"><em>l</em></th>
<th class="head"><em>e</em></th>
<th class="head"><em>x</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub"><em>a</em></th>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><th class="stub"><em>simple</em></th>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><th class="stub"><em>example</em></th>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Alternatively, we could rather count the <em>annotation values</em> (instead of
the content) of the units and/or of the contexts. For example, by defining
units on the basis of the annotations associated to the key <em>letter category</em>
in the <em>letters</em> segmentation, and contexts on the basis of the annotations
associated to the key <em>word category</em> in the <em>words</em> segmentation, we would
obtain the following table:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="38%" />
<col width="25%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>vowel</em></th>
<th class="head"><em>consonant</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub"><em>grammatical</em></th>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-odd"><th class="stub"><em>lexical</em></th>
<td>5</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>This way of selecting segmentations and annotation keys constitutes an
extremely flexible mechanism which enables the user to easily produce a
variety of contingency tables. Note that it is up to the user to provide a
coherent definition of the units and contexts. In general, a given unit is
considered to occur in a given context if, (a) the segment corresponding
to the unit and the context are both be associated to the same string, (b)
the initial position of the unit segment in the string is higher or equal to
that of the context segment, and (c) conversely the final position of the unit
is lower or equal to that of the context. In short, the unit must be
<em>contained</em> within the context.</p>
<p>A borderline case made possible by this <em>modus operandi</em> consists of defining
units and contexts on the basis of the same segmentation. Indeed since every
segment is contained in itself, nothing keeps us from using a single
segmentation, <em>words</em> for example, and defining units with the key <em>part of
speech</em> and contexts with the key <em>word category</em>:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="33%" />
<col width="22%" />
<col width="22%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>article</em></th>
<th class="head"><em>noun</em></th>
<th class="head"><em>verb</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub"><em>grammatical</em></th>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><th class="stub"><em>lexical</em></th>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Orange Textable offers two other ways to define contexts while still using a
single segmentation. The first relies on the notion of a “window” of <em>n</em>
segments that we progressively “slide” from the beginning to the end of the
segmentation. In our example, by applying this principle to the <em>letters</em>
segmentation and by setting the window size to 11 segments, we thus define
the following contexts:</p>
<blockquote>
<div><ol class="arabic simple">
<li><em>a simple exam</em></li>
<li><em>simple examp</em></li>
<li><em>imple exampl</em></li>
<li><em>mple example</em></li>
</ol>
</div></blockquote>
<p>By otherwise defining the units based on the <em>letter category</em> annotations for
example, we thus obtain the following counts (where the contexts are
represented by their successive positions):</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="38%" />
<col width="25%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>vowel</em></th>
<th class="head"><em>consonant</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub">1</th>
<td>5</td>
<td>6</td>
</tr>
<tr class="row-odd"><th class="stub">2</th>
<td>4</td>
<td>7</td>
</tr>
<tr class="row-even"><th class="stub">3</th>
<td>4</td>
<td>7</td>
</tr>
<tr class="row-odd"><th class="stub">4</th>
<td>4</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>The last context specification mode that Count offers and which involves a
single segmentation consists of defining the contexts as <em>n</em> segments
immediately to the left and/or to the right of each segment. For example,
based on the <em>letter category</em> annotations of segmentation <em>letters</em>, defining
the contexts as the two segments immediately on the left and on the right of
the segment results in the following contingency table (where the ‘+’ symbol
separates the successive segments of the context and the underscore symbol ‘_’
separates the left and right parts of the context):</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="57%" />
<col width="29%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>consonant</em></th>
<th class="head"><em>vowel</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub"><em>vowel+consonant_consonant</em></th>
<td>2</td>
<td>2</td>
</tr>
<tr class="row-odd"><th class="stub"><em>consonant+vowel_consonant</em></th>
<td>2</td>
<td>1</td>
</tr>
<tr class="row-even"><th class="stub"><em>consonant+consonant_vowel</em></th>
<td>2</td>
<td>1</td>
</tr>
<tr class="row-odd"><th class="stub"><em>vowel+vowel_vowel</em></th>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Such a table notably indicates that in a context composed, on the left, of a
<em>vowel+consonant</em> sequence and, on the right, of a consonant (for example
<em>ex_m</em> or <em>am_l</em>), we have twice observed a vowel and thrice a consonant. A
particular case of this type of table is that of the <em>transition matrix</em> that
defines a <em>Markov chain</em>, where we only consider the context on the left of
the segments:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="38%" />
<col width="25%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>vowel</em></th>
<th class="head"><em>consonant</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub"><em>vowel</em></th>
<td>o</td>
<td>5</td>
</tr>
<tr class="row-odd"><th class="stub"><em>consonant</em></th>
<td>5</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Let us also note that context specification, unlike unit specification, is
optional. Indeed, it is always possible to globally count the frequency of
segmentation units and thus produce a table that only contains a single row
corresponding to the whole concerned segmentation (thus <em>letters</em>, in the
following example):</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="27%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>a</em></th>
<th class="head"><em>s</em></th>
<th class="head"><em>i</em></th>
<th class="head"><em>m</em></th>
<th class="head"><em>p</em></th>
<th class="head"><em>l</em></th>
<th class="head"><em>e</em></th>
<th class="head"><em>x</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub"><em>__global__</em></th>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Finally, in every scenario considered here, we could also take an interest for
the frequency of the sequences from 2, 3, …, <em>n</em> segments  (or <em>n–grams</em>)
rather that to the frequency of isolated segments:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="25%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head stub"><em>__context__</em></th>
<th class="head"><em>as</em></th>
<th class="head"><em>si</em></th>
<th class="head"><em>im</em></th>
<th class="head"><em>mp</em></th>
<th class="head"><em>pl</em></th>
<th class="head"><em>le</em></th>
<th class="head"><em>ex</em></th>
<th class="head"><em>xa</em></th>
<th class="head"><em>am</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><th class="stub"><em>__global__</em></th>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>After having thus outlined the range of contingency table types that the
<strong>Count</strong> widget can produce, we can take a look at its interface (see
figures <a class="reference internal" href="#count-fig1"><span class="std std-ref">1</span></a> to <a class="reference internal" href="#count-fig4"><span class="std std-ref">4</span></a>). It contains two
separate sections for unit definition (<strong>Units</strong>) and context definition
(<strong>Contexts</strong>).</p>
<div class="figure align-center" id="id8">
<span id="count-fig1"></span><img alt="Count widget in mode &quot;No context&quot;" src="_images/count_example.png" />
<p class="caption"><span class="caption-text">Figure 1: <strong>Count</strong> widget (<strong>No context</strong> mode).</span></p>
</div>
<p>In the <strong>Units</strong> section, the <strong>Segmentation</strong> drop-down menu allows the user
to select among the input segmentations the one whose segment types will be
counted. The <strong>Annotation key</strong> menu displays the annotation keys associated
to the chosen segmentation, if any; if one of the keys is selected, the
corresponding annotation values will be counted; if on the other hand the
value <em>(none)</em> is selected, the <em>content</em> of the segments will be counted. The
<strong>Sequence length</strong> drop-down menu allows the user to indicate if isolated
segments or segment <em>n–grams</em> should be counted; in this latter case, the
(optional) string specified in the <strong>Intra sequence delimiter</strong> text field
will be used to separate the content or the annotation value corresponding to
each segment in the column headers. <a class="footnote-reference" href="#id7" id="id4">[3]</a></p>
<p>The <strong>Contexts</strong> section is available in several variants, depending on the
selected value in the <strong>Mode</strong> drop-down menu. The latter allows the user to
choose between the different ways of defining contexts described earlier. The
<strong>No context</strong> mode (see <a class="reference internal" href="#count-fig1"><span class="std std-ref">figure 1</span></a>) corresponds to the case
where units are counted globally in the whole segmentation specified in the
<strong>Units</strong> section (to which we will refer by the term <em>unit segmentation</em>).</p>
<p>The <strong>Sliding window</strong> mode (see <a class="reference internal" href="#count-fig2"><span class="std std-ref">figure 2</span></a>) implements the
notion of a “sliding window” introduced earlier. Typically it allows the user
to observe the evolution of frequency throughout the unit segmentation. The
only parameter is the window size (in number of segments), defined by the
<strong>Window size</strong> cursor.</p>
<div class="figure align-center" id="id9">
<span id="count-fig2"></span><img alt="Count widget in mode &quot;Sliding window&quot;" src="_images/count_mode_sliding_window_example.png" />
<p class="caption"><span class="caption-text">Figure 2: <strong>Count</strong> widget (<strong>Sliding window</strong> mode).</span></p>
</div>
<div class="figure align-center" id="id10">
<span id="count-fig3"></span><img alt="Count widget in mode &quot;Left-right neighborhood&quot;" src="_images/count_mode_left_right_neighborhood_example.png" />
<p class="caption"><span class="caption-text">Figure 3: <strong>Count</strong> widget (<strong>Left–right neighborhood</strong> mode).</span></p>
</div>
<div class="figure align-center" id="id11">
<span id="count-fig4"></span><img alt="Count widget in mode &quot;Containing segmentation&quot;" src="_images/count_mode_containing_segmentation.png" />
<p class="caption"><span class="caption-text">Figure 4: <strong>Count</strong> widget (<strong>Containing segmentation</strong> mode).</span></p>
</div>
<p>The <strong>Left–right neighborhood</strong> mode (see <a class="reference internal" href="#count-fig3"><span class="std std-ref">figure 3</span></a>)
allows the user to specifycontext types based on the <em>n</em> segments immediately
to the left and/or right of each segment; this mode notably allows the user to
build a Markov chain transition matrix. The <strong>Left context size</strong> and <strong>Right
context size</strong> parameters determine the number of segments taken into
consideration in each part of the context. The <strong>Unit position marker</strong> text
field allows the user to specify the (possibly empty) character chain to
insert in-between the left and right parts of the context in the row headers.</p>
<p>Finally, the <strong>Containing segmentation</strong> mode (see <a class="reference internal" href="#count-fig4"><span class="std std-ref">figure 4</span></a>) corresponds to the case where contexts are defined by the
segment types that appear in a segmentation (which can be that of the units or
another). This segmentation, that we will call <em>context segmentation</em> by
analogy, is selected among the input segmentations by means of the
<strong>Segmentation</strong> drop-down menu. The <strong>Annotation key</strong> menu displays the
annotation keys associated with the context segmentation, if any; if one of
the keys is selected, the corresponding annotation value types will constitute
the row headers; if however the value <em>(none)</em> is selected, the <em>content</em> of
the segments will be exploited. The <strong>Merge</strong> contexts checkbox enables the
program to globally count the units in the whole context segmentation.</p>
<p>The <strong>Info</strong> section indicates the sum of frequencies in the output table, or
the reasons why not table is emitted (no input data or total frequency is
zero).</p>
<p>The <strong>Compute</strong> button triggers the emission of a table in the internal format
of Orange Textable, to the output connection(s). When it is selected, the
<strong>Compute automatically</strong> checkbox disables the button and the widget attempts
to automatically emit a segmentation at every modification of its interface or
when its input data are modified (by deletion or addition of a connection, or
because modified data is received through an existing connection).</p>
</div>
<div class="section" id="messages">
<h2>Messages<a class="headerlink" href="#messages" title="Permalink to this headline">¶</a></h2>
<div class="section" id="information">
<h3>Information<a class="headerlink" href="#information" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><em>Data correctly sent to output: total count is &lt;n&gt;.</em></dt>
<dd>This confirms that the widget has operated properly.</dd>
<dt><em>Settings were</em> (or <em>Input has</em>) <em>changed, please click ‘Compute’ when ready.</em></dt>
<dd>Settings and/or input have changed but the <strong>Compute automatically</strong>
checkbox has not been selected, so the user is prompted to click the
<strong>Compute</strong> button (or equivalently check the box) in order for computation
and data emission to proceed.</dd>
<dt><em>No data sent to output yet: no input segmentation.</em></dt>
<dd>The widget instance is not able to emit data to output because it receives
none on its input channel(s).</dd>
<dt><em>No data sent to output yet, see ‘Widget state’ below.</em></dt>
<dd>A problem with the instance’s parameters and/or input data prevents it
from operating properly, and additional diagnostic information can be
found in the <strong>Widget state</strong> box at the bottom of the instance’s
interface (see <a class="reference internal" href="#warnings">Warnings</a> below).</dd>
</dl>
</div>
<div class="section" id="warnings">
<h3>Warnings<a class="headerlink" href="#warnings" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><em>Resulting table is empty.</em></dt>
<dd>No table has been emitted because the widget instance couldn’t find a
single element in its input segmentation(s). A likely cause for this
problem (when using the <strong>Containing segmentation</strong> mode) is that the unit
and context segmentations do not refer to the same strings, so that the
units are in effect <em>not</em> contained in the contexts. This is typically a
consequence of the improper use of widgets <a class="reference internal" href="preprocess.html#preprocess"><span class="std std-ref">Preprocess</span></a> and/or
<a class="reference internal" href="recode.html#recode"><span class="std std-ref">Recode</span></a> (see <a class="reference internal" href="preprocess.html#anchor-to-caveat"><span class="std std-ref">Caveat</span></a>).</dd>
</dl>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="counting_segment_types.html"><span class="doc">Getting started: Counting segment types</span></a></li>
<li><a class="reference internal" href="counting_specific_contexts.html"><span class="doc">Getting started: Counting in specific contexts</span></a></li>
<li><a class="reference internal" href="count_unit_frequency.html"><span class="doc">Cookbook: Count unit frequency</span></a></li>
<li><a class="reference internal" href="count_occurrences_smaller_units_larger_segments.html"><span class="doc">Cookbook: Count occurrences of smaller units in larger segments</span></a></li>
<li><a class="reference internal" href="count_transition_frequency_adjacent_units.html"><span class="doc">Cookbook: Count transition frequency between adjacent units</span></a></li>
<li><a class="reference internal" href="examine_evolution_unit_frequency.html"><span class="doc">Cookbook: Examine the evolution of unit frequency along the text</span></a></li>
</ul>
</div>
<div class="section" id="see-also">
<h2>See also<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="convert.html#anchor-to-table-formats"><span class="std std-ref">Reference: Convert widget (section “Table formats”)</span></a></li>
</ul>
</div>
<div class="section" id="footnotes">
<h2>Footnotes<a class="headerlink" href="#footnotes" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>By convention, we do not indicate here the string index associated with
each segment but only its start and end positions, along with the
various annotation values associated with it; moreover, for the sake of
readability, we do indicate the content of each segment, though it is
not formally part of the segmentation (but rather of the string to
which the segmentation refers).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>The first column header, <em>__context__</em>, is a name predefined by Orange
Textable.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>The same character string will be inserted between the successive
segments that build up the left and/or right context if the
<strong>Left–right neighborhood</strong> mode is selected.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Count</a><ul>
<li><a class="reference internal" href="#signals">Signals</a></li>
<li><a class="reference internal" href="#description">Description</a></li>
<li><a class="reference internal" href="#messages">Messages</a><ul>
<li><a class="reference internal" href="#information">Information</a></li>
<li><a class="reference internal" href="#warnings">Warnings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#see-also">See also</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="table_construction_widgets.html"
                        title="previous chapter">Table construction widgets</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="length.html"
                        title="next chapter">Length</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/count.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="length.html" title="Length"
             >next</a> |</li>
        <li class="right" >
          <a href="table_construction_widgets.html" title="Table construction widgets"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Textable v3.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="reference.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="table_construction_widgets.html" >Table construction widgets</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2018 LangTech Sarl, translation © 2014-2018 University of Lausanne.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.0.
    </div>
  </body>
</html>