<script type="text/javascript">
    /**
     * Function, that defines App's launch environment: Cordova or not.
     * @return {boolean}
     */
    function isCordova() {
        if(window.cordova) {
            return true;
        } else if(window.parent && window.parent.cordova) {
            return true;
        }
        return false;
    }

    /**
     * Function, that turns load type of js files.
     * loadType('js').
     * loadType('eval').
     * loadType('js-inline').
     * @param {boolean} type
     * @return {string}
     */
    function loadType(type) {
        if(type !== undefined) {
            window.localStorage['loadType'] = type;
        }

        return window.localStorage['loadType'];
    }

    /**
     * Function, that turns use_cache modes (true/false).
     * True - use_cache.
     * False - no_cache.
     * useCache(true).
     * useCache(false).
     * @param {boolean} mode
     * @return {boolean}
     */
    function useCache(mode) {
        if(mode !== undefined) {
            loadType(mode ? 'inline-js': 'js');
            window.localStorage['useCache'] = JSON.stringify(mode);
        }

        // return JSON.parse(window.localStorage['useCache']);
        return window.localStorage['useCache'] == 'true';
    }

    /**
     * Handler for window.onerror event, that should be called during Files loading.
     */
    function onLoadingErrorHandler(event) {
        if(window && window.guiFilesLoader && window.guiFilesLoader.appendError &&
            typeof window.guiFilesLoader.appendError == "function") {
            window.guiFilesLoader.appendError(event.error);
        }
    }

    /**
     * Function selects DOM elements by selector and push them into JQ Class constructor.
     * If typeof selector is 'string', function will find DOM element,
     * appropriate to this selector.
     * If typeof selector is 'object' function will push selector.
     * @param {string, object} selector DOM element or DOM elements' selector.
     * @return {object} JQ Class instance.
     */
    function jqConstructor(selector) {
        function _getElement(selector) {
            if(typeof selector == "object") {
                return selector;
            }

            if(typeof selector != "string") {
                return;
            }

            selector = selector.trim();
            let method = 'getElementsByTagName';

            if(selector[0] == "#") {
                method = 'getElementById';
                selector = selector.slice(1);
            } else if(selector[0] == ".") {
                method = 'getElementsByClassName';
                selector = selector.slice(1);
            }

            return document[method](selector);
        }

        return new JQ(_getElement(selector));
    }

    /**
     * Class, that provides some methods, that make DOM manipulations easier.
     * Simple analog of JQuery, has only basic methods.
     */
    class JQ {
        /**
         * Constructor of JQ Class.
         * @param {object, HTMLCollection} elements DOM elements, that should be edited.
         */
        constructor(elements) {
            if(!elements) {
                this.length = 0;
            } else {
                if (elements.length) {
                    for (let i = 0; i < elements.length; i++) {
                        this[i] = elements[i];
                    }
                    this.length = elements.length;
                } else {
                    this[0] = elements;
                    this.length = 1;
                }

                let props = [];
                for(let i = 0; i < this.length; i++) {
                    if(!this[i]) {
                        continue;
                    }
                    props.push(this[i]);
                }

                Object.defineProperty(this, 'elements', {
                    value: props,
                });
            }
        }
        /**
         * Static method.
         * This method is supposed to be called from fadeIn and fadeOut methods.
         * @param {number, string} speed Animation speed.
         */
        static getSpeed(speed) {
            let speed_props = {
                fast: 50,
                normal: 150,
                slow: 300,
            };

            if(typeof speed == "string") {
                if(speed_props[speed]) {
                    speed = speed_props[speed];
                }
            }

            if(!speed) {
                speed = 50;
            }
            return speed;
        }
        /**
         * Method, that inserts into end of DOM element some HTML.
         * @param {string} html HTML, that should be appended.
         */
        append(html) {
            this.elements.forEach(el => {
                el.innerHTML = el.innerHTML + html;
            });
        }
        /**
         * Method, that inserts into beginning of DOM element some HTML.
         * @param {string} html HTML, that should be appended.
         */
        prepend(html) {
            this.elements.forEach(el => {
                el.innerHTML = html + el.innerHTML;
            });
        }
        /**
         * Method, that shows DOM element.
         */
        show() {
            this.elements.forEach(el => {
                let prop = "";
                if(el.jq_props && el.jq_props && el.jq_props.style) {
                    prop = el.jq_props.style.display || "";
                }
                el.style.display = prop;
            });
        }
        /**
         * Method, that hides DOM element.
         */
        hide() {
            this.elements.forEach(el => {
                if(el.style.display && el.style.display != "none") {
                    if(!el.jq_props) {
                        el.jq_props = {};
                    }

                    if(!el.jq_props.style) {
                        el.jq_props.style = {};
                    }
                    el.jq_props.style.display = el.style.display;
                }
                el.style.display = "none";
            });
        }
        /**
         * Method, that adds CSS class to DOM element.
         * @param {string} item CSS class, that should be added.
         */
        addClass(item) {
            this.elements.forEach(el => {
                if(el.className.indexOf(item) == -1) {
                    el.className += " " + item;
                }
            });
        }
        /**
         * Method, that removes CSS class from DOM element.
         * @param {string} item CSS class, that should be removed.
         */
        removeClass(item) {
            this.elements.forEach(el => {
                el.className = el.className.replace(item, "");
            });
        }
        /**
         * Method, that smoothly shows DOM element.
         * @param {number, string} speed Animation speed.
         */
        fadeIn(speed) {
            speed = this.constructor.getSpeed(speed);

            this.elements.forEach(el => {
                let prop = 1;
                if(el.jq_props && el.jq_props.style && el.jq_props.style.opacity) {
                    prop = el.jq_props.style.opacity;
                }
                let interval_id = setInterval(() => {
                    jqConstructor(el).show();

                    if (!el.style.opacity || el.style.opacity == "0") {
                        el.style.opacity = 0;
                    }

                    if (el.style.opacity < prop) {
                        el.style.opacity = Number(el.style.opacity) + 0.1;
                    } else {
                        if(!(el.jq_props && el.jq_props.style &&
                                el.jq_props.style.opacity)) {
                            el.style.opacity = "";
                        }
                        clearInterval(interval_id);
                    }
                }, speed);
            });
        }
        /**
         * Method, that smoothly hides DOM element.
         * @param {number, string} speed Animation speed.
         */
        fadeOut(speed) {
            speed = this.constructor.getSpeed(speed);

            this.elements.forEach(el => {
                let prop = 1;
                if(el.style.opacity && el.style.opacity != "0") {
                    if(!el.jq_props) {
                        el.jq_props = {};
                    }

                    if(!el.jq_props.style) {
                        el.jq_props.style = {};
                    }
                    prop = el.jq_props.style.opacity = el.style.opacity;
                }

                let interval_id = setInterval(() => {
                    if (!el.style.opacity) {
                        el.style.opacity = prop;
                    }
                    if (el.style.opacity > 0) {
                        el.style.opacity -= 0.1;
                    } else {
                        jqConstructor(el).hide();
                        clearInterval(interval_id);
                    }
                }, speed);
            });
        }
    }

    /**
     * Class, that creates FilesCache instances - Objects, that communicate with indexedDB.
     * More about indexedDB:
     * - https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB
     * - https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB
     */
    class FilesCache {
        /**
         * Constructor of FilesCache class.
         * @param {object} opt Object with options for FilesCache instance.
         */
        constructor(opt) {
            this.indexed_db = window.indexedDB || window.mozIndexedDB ||
                window.webkitIndexedDB || window.msIndexedDB;
            // this.host_id = window.location.host;
            this.host_id = "{{host_url}}".replace(/[^0-9A-z]/img, "_");
            this.db_name = 'cache_' + this.host_id + "__";
            this.db_version = 1;
            this.store_name = 'cache_store';
            this.use_cache = true;

            for(let key in opt) {
                this[key] = opt[key];
            }
        }
        /**
         * Method, that returns promise of connection to FilesCache indexedDB.
         */
        connectDB() {
            return new Promise((resolve, reject) => {
                let request = this.indexed_db.open(this.db_name, this.db_version);

                request.onerror = (err) => {
                    console.error("Error in FilesCache.connectDB().", err);
                    reject(err);
                };

                request.onsuccess = (event) => {
                    let db = event.target.result;

                    db.onerror = function(event) {
                        console.log('indexedDB - db.onerror ', event);
                    };

                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    let db = event.target.result;
                    db.createObjectStore(
                        this.store_name, { keyPath: "path", autoIncrement: true }
                    );
                    this.connectDB().then(resolve, reject)
                }
            })
        }
        /**
         * Method, that returns promise to get file from FilesCache.
         */
        getFile(file_url) {
            return new Promise((resolve, reject) => {
                if(!this.use_cache) {
                    reject();
                }

                this.connectDB().then(db => {
                    let transaction = db.transaction([this.store_name], "readonly");
                    let request = transaction.objectStore(this.store_name).get(file_url);

                    transaction.oncomplete = function(event) {
                        db.close();
                    };

                    request.onerror = (err) => {
                        console.error("Error in FilesCache.getFile()", err);
                        reject(err);
                    };

                    request.onsuccess = () => {
                        if(!request.result) {
                            reject();
                            return;
                        }

                        resolve(request.result ? request.result : -1);
                    }
                }, reject);
            });
        }
        /**
         * Method, that returns promise to save file in FilesCache.
         */
        setFile(file_url, file_data) {
            return new Promise((resolve, reject) => {
                this.connectDB().then(db => {
                    let transaction = db.transaction([this.store_name],"readwrite");
                    transaction.oncomplete = (event) => {
                        db.close();
                    };

                    transaction.onerror = (event) => {
                        console.error("Error in FilesCache.setFile().", event);
                    };

                    let objectStore = transaction.objectStore(this.store_name);

                    let request = objectStore.put({path: file_url, data: file_data});

                    request.onerror = (err) => {
                        console.error("Error in FilesCache.setFile()", err);
                        reject(err);
                    };

                    request.onsuccess = () => {
                        if(!request.result) {
                            reject();
                            return;
                        }
                        resolve(request.result ? request.result : -1);
                    }
                }, reject);
            });
        }
        /**
         * Method, that returns promise to delete file from FilesCache.
         */
        delFile(file_url) {
            return new Promise((resolve, reject) => {
                this.connectDB().then(db => {
                    let transaction = db.transaction([this.store_name],"readwrite");
                    transaction.oncomplete = (event) => {
                        db.close();
                    };

                    transaction.onerror = (event) => {
                        console.error("Error in FilesCache.delFile()", event);
                    };

                    let objectStore = transaction.objectStore(this.store_name);
                    let request = objectStore.delete(file_url);

                    request.onerror = (err) => {
                        console.error("Error in FilesCache.detFile()", err);
                        reject(err);
                    };

                    request.onsuccess = () => {
                        resolve(true);
                    }
                }, reject);
            });
        }
        /**
         * Method, that returns promise to delete all file from FilesCache (delete FilesCache indexedDB).
         */
        deleteAllCache() {
            return new Promise((resolve, reject) => {
                let DBDeleteRequest = this.indexed_db.deleteDatabase(this.db_name);

                DBDeleteRequest.onerror = (event) => {
                    console.error("Error during 'deleteAllCache' method execution. ", event);
                    reject(event);
                };

                DBDeleteRequest.onblocked = (event) => {
                    console.error("Error during 'deleteAllCache' method execution. DB blocked ", event);
                    reject(event);
                };

                DBDeleteRequest.onsuccess = (event) => {
                    resolve(event);
                };
            });
        }
        /**
         * Method, that returns promise to delete all file from FilesCache (delete FilesCache indexedDB)
         * and after promise resolving/rejecting updates page.
         */
        deleteAllCacheAndUpdatePage() {
            let callback = () => {
                return setTimeout(() => {
                    window.location.reload();
                }, 500);
            };

            return this.deleteAllCache().then(response => {
                callback();
            }).catch(error => {
                callback();
            });
        }
    }

    /**
     * Class, that manages loading static files (tpl, css, js, events)
     * and appending them to html document.
     */
    class FilesLoader {
        /**
         * Constructor of FilesLoader Class.
         */
        constructor(files_cache, resource_list) {
            /**
             * Dict of JS objects - files, that should be loaded.
             * File (JS object) has properties about it's type, source url,
             * status (appended/appending), response status code (200, 404, and so on).
             */
            this.files_to_load = {};
            /**
             * Instance of FilesCache Class.
             * This property communicates with indexedDB, where cache is stored.
             */
            this.files_cache = files_cache;
            /**
             * Array of JS objects, that contain info about files, that should be loaded.
             */
            this.resource_list = resource_list;
            /**
             * Object, that contents properties about loading progress.
             * steps_sum - amount of files to be loaded.
             * step - number of loaded files.
             */
            this.loading_progress = {
                step: 0,
                steps_sum: 0,
            };
            /**
             * Property - simple analog of JQuery.
             * FilesLoader use it, because at the moment of files loading
             * there is no JQuery yet.
             */
            this.jq = jqConstructor;
        }
        /**
         * Method, that changes loading progress bar value.
         * @param {number} width Value of loading progress bar width.
         */
        setLoadingProgress(width) {
            let elem = document.getElementById("LoadingProgressBarLine");

            if(!elem) {
                return;
            }

            elem.style.width = Math.ceil(width) + '%';

            elem = document.getElementById("LoadingProgressBarCount");

            if(!elem) {
                return;
            }

            elem.style.width = Math.ceil(width) + '%';
            elem.innerHTML = Math.ceil(width) * 1  + '%';
        }
        /**
         * Method, that hides loading progress bar and shows App content.
         */
        hideLoadingProgress() {
            this.jq("#RealBody").show();

            this.jq("#LoadingProgressBar").fadeOut();
        }
        /**
         * Method, needed for sorting of files array.
         * @param {object} a Array property 1
         * @param {object} b Array property 2
         */
        _compareNumeric(a, b) {
            if (!a.prioritet && a.prioritet !== 0) a.prioritet = 999;
            if (!b.prioritet && b.prioritet !== 0) b.prioritet = 999;

            if (a.prioritet > b.prioritet) return 1;
            if (a.prioritet < b.prioritet) return -1;

            return 0;
        }
        /**
         * Method, that returns array with sorted filed from this.files_to_load.
         */
        getSortedFiles() {
            let files = [];

            for(let item in this.files_to_load) {
                files.push(this.files_to_load[item]);
            }

            return files.sort(this._compareNumeric);
        }
        /**
         * Method, that creates DOM element for file content.
         * @param {string} type Type (tag) of DOM element.
         * @param {array} attributes Array of objects -
         * DOM element attributes(key, value).
         * @param {object} props Object with properties of DOM element.
         */
        createFileDomElement(type, attributes, props) {
            let el = document.createElement(type);

            attributes.forEach(attr => {
                el.setAttribute(attr.key, attr.value);
            });

            for(let key in props) {
                el[key] = props[key];
            }

            return el;
        }
        /**
         *  Method, that inserts file content's DOM element into html document,
         *  adds info about in to logs and changes file status.
         *  @param {string} target Name of parent element - container of file DOM element.
         *  @param {object} el File content's DOM element.
         *  @param {object} file File object.
         *  @param {string} file Message, that should be added into logs.
         */
        appendFileDomElement(target, el, file, log_msg) {
            if(!log_msg) {
                log_msg = "Appended " + file.url;
            }
            document.getElementsByTagName(target)[0].appendChild(el);
            this.appendLog(log_msg);
            file.appended = true;
        }
        /**
         * Method, that adds TPL file content to html document.
         * @param {object} file Object of TPL file.
         */
        addFileToPage_tpl(file) {
            $("body").append(file.response);
            file.appended = true;
            this.appendLog("Appended "+file.url);
            return this.addToPage();
        }
        /**
         * Method, that adds JS file content to html document.
         * @param {object} file Object of JS file.
         */
        addFileToPage_js(file) {
            if(loadType() == 'js') {
                let attributes = [
                    {key: "type", value: "text/javascript"},
                    {key: "src", value: file.url},
                ];
                let props = {
                    onload: () => {
                        file.appended = true;
                        this.appendLog("Appended "+file.url);
                        this.addToPage();
                    }
                };
                let link = this.createFileDomElement("script", attributes, props);

                document.getElementsByTagName("head")[0].appendChild(link);
            } else {
                let attributes = [
                    {key: "type", value: "text/javascript"},
                    {key: "data-url", value: file.url},
                ];
                let props = {
                    innerHTML: file.response,
                };
                let link = this.createFileDomElement("script", attributes, props);

                this.appendFileDomElement("head", link, file);

                return this.addToPage();
            }
        }
        /**
         * Method, that adds CSS file content to html document.
         * @param {object} file Object of CSS file.
         */
        addFileToPage_css(file) {
            let attributes = [
                {key: "rel", value: "stylesheet"}, {key: "type", value: "text/css"},
                {key: "media", value: "text/css"}, {key: "data-url", value: file.url},

            ];
            let props = {
                rel: 'stylesheet',
                type: 'text/css',
                media: 'all',
                innerHTML: file.response.replace(
                    /\.\.\/fonts/gmi, hostname + window.guiStaticPath + "fonts"
                ),
            };
            let link = this.createFileDomElement("style", attributes, props);

            this.appendFileDomElement("body", link, file);

            return this.addToPage();
        }
        /**
         * Method, that emits EVENT, from EVENT file.
         * @param {object} file Object of EVENT file.
         */
        addFileToPage_event(file) {
            tabSignal.emit(file.name);
            file.appended = true;
            this.appendLog("Appended signal" + file.name);

            return this.addToPage();
        }
        /**
         * Method, that handles adding of file (of different types) to the html document.
         * @param {object} file File, that should be added to the html document.
         */
        addFileToPage(file) {
            try {
                let handler = 'addFileToPage_' + file.type;
                if(this[handler] && typeof this[handler] == 'function') {
                    return this[handler](file);
                }
            }
            catch (exception) {
                this.appendError(exception, {name:file.url, type:'error'});
                debugger;
            }
        }
        /**
         * Method, that adds sorted filed to the html documnet.
         */
        addToPage() {
            let files = this.files_to_load_sorted;

            if(!files) {
                files = this.files_to_load_sorted = this.getSortedFiles();
            }

            let last_file;

            for(let i in files) {
                let file = files[i];

                if(file.appended) {
                    last_file = file;
                    continue;
                }

                if(file.status!= 200) {
                    return;
                }

                if(file.appending === true && !file.appended) {
                    setTimeout(() => {
                        this.addToPage();
                    }, 200);
                    return;
                }

                if(last_file && !last_file.appended) {
                    setTimeout(() => {
                        this.addToPage();
                    }, 200);
                    return;
                }

                if(file.status == 200) {
                    if(file.appending === true && file.appended !== true) {
                        setTimeout(() => {
                            this.addToPage();
                        }, 200);
                        return;
                    }

                    file.appending = true;

                    return this.addFileToPage(file);
                }
            }
        }
        /**
         * Method, that adds logs of files loading.
         * @param {object, string} data Logging message.
         * @param {object} extendData Additional logging message.
         */
        appendLog(data, extendData) {
            try {
                let text = "";

                if(!extendData) {
                    extendData = {type:'Log', name:""};
                }

                text += "Type:"+extendData.type+"\t";

                if(extendData.name) text += "Name:"+extendData.name+"\t";

                if(typeof data == "string") {
                    text += data;
                } else {
                    text += "JSON:"+JSON.stringify(data);
                }

                text = '<pre class="LoadingProgressBar-success">' + text + '</pre>';
                this.jq('.LoadingProgressBar-logger-wrapper').append(text);
            } catch(e) {
                this.appendError(e);
            }
        }
        /**
         * Method, that adds to the html document info about file loading error.
         * @param {object, string} exception Error object or string.
         * @param {object} extendData Additional logging message.
         */
        appendError(exception, extendData) {
            try {
                console.error(exception);

                let text = "";

                if(!extendData) {
                    extendData = {type:'Error', name:""};
                }

                text += "Type:"+extendData.type+"\t";

                if(extendData.name) text += "Name:"+extendData.name+"\n";

                if(exception && exception.message) {
                    text += exception.message + "\nstack:\n"+exception.stack;
                } else {
                    text += "JSON exeption:\n"+JSON.stringify(exception);
                }


                text = '<pre class="LoadingProgressBar-error">' + text + '</pre>';
                this.jq('.LoadingProgressBar-logger-wrapper').append(text);
                this.jq(".LoadingProgressBar-logger-wrapper").show();
                this.jq(".LoadingProgressBar-error-msg").show();

                this.jq(".loadInfoWrapper").addClass("need-reload");
            } catch(e) {
                debugger;
                alert("Error in appendError function\n"+JSON.stringify(e));
            }
        }
        /**
         * Method, that gets file content (loads it or gets from cache).
         * @param {object} item File object.
         */
        loadData(item) {
            if(item.type == 'event') {
                item.status = 200;
                this.addToPage();
                return;
            }

            if(!this.loading_progress.steps_sum) {
                this.loading_progress.steps_sum = 0;
                this.loading_progress.step = 0;
            }

            this.loading_progress.steps_sum++;

            this.files_cache.getFile(item.url).then(file => {
                console.log("use from cache");
                item.response = file.data;
                this.loading_progress.step++;
                let prog = this.loading_progress.step/this.loading_progress.steps_sum;
                this.setLoadingProgress(prog * 100);
                item.status = 200;
                this.addToPage();
            }).catch(error => {
                let request = new XMLHttpRequest();

                request.onreadystatechange = () => {
                    if (!(request.readyState === 4 && request.status === 200)) {
                        return;
                    }

                    item.response = request.responseText;
                    this.loading_progress.step++;
                    let prog = this.loading_progress.step/this.loading_progress.steps_sum;
                    this.setLoadingProgress(prog * 100);
                    item.status = request.status;
                    this.addToPage();
                    this.files_cache.setFile(item.url, request.responseText);
                };

                request.open("GET", item.url);

                request.send();
            });
        }
        /**
         * Method, that init files loading.
         */
        onReady() {
            console.log("onReady");
            this.setLoadingProgress(0);

            this.resource_list.push(
                {prioritet:10000, type:'event', name: "resource.loaded"}
            );

            for(let i in this.resource_list) {
                let item = Object.assign({}, this.resource_list[i]);

                item.url = hostname + item.name;
                item.status = 0;
                item.index =+ i;

                this.files_to_load[item.url] = item;
            }

            for(let i in this.files_to_load) {
                this.loadData(this.files_to_load[i]);
            }
        }
    }

    ///////////////////////////////////code execution/////////////////////////////////////

    window.guiFilesCache = new FilesCache({ use_cache: useCache() });
    window.guiFilesLoader = new FilesLoader(window.guiFilesCache, window.resourceList);

    if (localStorage['gui_version'] !== gui_version) {
        localStorage['gui_version'] = gui_version;
        window.guiFilesCache.deleteAllCacheAndUpdatePage();
    } else {
        localStorage['gui_version'] = gui_version;

        window.addEventListener("error", onLoadingErrorHandler);

        window.guiFilesLoader.onReady();
    }
</script>