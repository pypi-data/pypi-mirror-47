#!/usr/bin/env python3

import os
import sys
from threading import Thread
import gt.sources

def die(*args, **kwargs):
    kwargs['file']=sys.stderr
    print("ERROR:", *args, **kwargs)
    sys.exit(-1)


GITCMD = None

for cmd in os.environ['PATH'].split(":"):
    cmd = os.path.join(cmd, "git")
    if os.path.exists(cmd):
        GITCMD = cmd

if not GITCMD:
    die('Could not find git in PATH, please ensure it is installed.')

CFG_FILE = os.path.join(os.environ['HOME'], '.gtrc')

def assert_existence(repos):
    for src, repo in repos:
        if repo not in [ r[0] for r in src.repos ]:
            die('%s/%s does not exist.' % (src.name, repo))

#Returns a list of tuples of the form (<GitSource>, <Repo Name>)

def parse_repos(args):
    repos = []
    source_repos = {}

    for repo in args:
        if '/' not in repo:
            die('%s must be of the form <source>/<repo name>' % repo)

        src, name = repo.split('/')
        if src not in g_sources:
            die('%s is not a valid git source.' % src)

        repos.append((g_sources[src], name))

    return repos

def delete(args):
    if len(args) == 0:
        die('Usage: gt create <source>/<repo name>...')

    repos = parse_repos(args)
    assert_existence(repos)

    for src, repo in repos:
        print(src.name + '/' + repo)

    r = input('The repos listed above will be deleted type YES to confirm: ')
    if r != 'YES':
        print('ABORTING')
        exit(1)

    for src, repo in repos:
        print('Deleting %s/%s' % (src.name, repo))
        src.delete(repo)

def create(args):
    if len(args) == 0:
        die('Usage: gt create <source>/<repo name>...')

    for src,repo in parse_repos(args):
        print('Creating %s/%s' % (src.name, repo))
        src.create(repo)

def ls(args):
    if len(args) != 1:
        die('Usage: gt ls [ \'*\' | <source>... ]')

    if args[0] == '*':
        args = g_sources.keys()

    for src in args:
        if src not in g_sources:
            die('%s is not a valid git source.' % src)

    threads = []
    results = []

    def _(src):
        results.extend([
            '%s/%s' % (src, repo) 
            for repo, _ in g_sources[src].repos ])

    for src in args:
        t = Thread(target=_, args=(src,))
        threads.append(t)

    for t in threads:
        t.start()
    for t in threads:
        t.join()

    print('\n'.join(results))
        

def info(args):
    if len(args) != 1:
        die('Usage: gt info <git source>')

    repos = {}
    for src, repo in parse_repos(args):
        src.list

    # Some of these operations block, so we 
    # build a string to aggregate the delays
    # for printing.

    r =  "Project Name: " + repo.name + "\n"
    r += "Source: " + repo.source.name + "\n"
    r += "Location: " + repo.location() + "\n"
    r += "Public: " + str(repo.public())
    print(r)

def clone(args):
    if len(args) != 1:
        print('Usage: gt clone <git source/repo>')

    src, repo = parse_repos(args)[0]

    git_url = src.git_url(repo)
    os.execl(GITCMD, GITCMD, 'clone', git_url)


#Main

usage = "Usage: {0} < ls | init | create | rm | clone | info > [args]"\
        .format(sys.argv[0])

if len(sys.argv) < 2:
    die(usage)
    
target = sys.argv[1]
args = sys.argv[2:]

commands = {
        'ls': ls,
        'create': create,
        'delete': delete,
        'rm': delete,
        'clone': clone,
}
if target not in commands:
    die('ERROR: %s is not a valid command.' % target)

g_sources = gt.sources.get_sources('%s/.gtrc' % os.getenv('HOME'))
commands[target](args)
