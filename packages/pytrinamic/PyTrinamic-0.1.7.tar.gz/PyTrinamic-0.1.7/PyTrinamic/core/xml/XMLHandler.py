#!/usr/bin/env python3
'''
Created: 31.05.2019

@author: LK
'''

import PyTrinamic
import re
import xml.etree.ElementTree as ET
from PyTrinamic.helpers import v_func
from PyTrinamic.Strings import Strings

class Format(object):
    @staticmethod
    def from_string(name):
        if(name == "c_header"):
            return FormatCHeader()
        elif(name == "python"):
            return FormatPython()
        elif(name == "latex"):
            return FormatLatex()

    @staticmethod
    def get_extension():
        raise NotImplementedError()

class FormatCHeader(Format):
    __EXTENSION = "h"
    __COMMENT = "//"
    @staticmethod
    def get_extension():
        return FormatCHeader.__EXTENSION
    @staticmethod
    def get_comment():
        return FormatCHeader.__COMMENT

class FormatPython(Format):
    __EXTENSION = "py"
    __COMMENT = "#"
    @staticmethod
    def get_extension():
        return FormatPython.__EXTENSION
    @staticmethod
    def get_comment():
        return FormatPython.__COMMENT

class FormatLatex(Format):
    __EXTENSION = "tex"
    @staticmethod
    def get_extension():
        return FormatLatex.__EXTENSION

class RenameMode(object):
    @staticmethod
    def from_string(name):
        if(name == "remove"):
            return RenameModeRemove()
        elif(name == "replace"):
            return RenameModeReplace()

class RenameModeRemove(RenameMode):
    pass

class RenameModeReplace(RenameMode):
    pass

class DuplicateMode(object):
    @staticmethod
    def from_string(name):
        if(name == "comment"):
            return DuplicateModeComment()
        elif(name == "keep"):
            return DuplicateModeKeep()
        elif(name == "ignore"):
            return DuplicateModeIgnore()
        elif(name == "remove"):
            return DuplicateModeRemove()
        elif(name == "error"):
            return DuplicateModeError()

class DuplicateModeComment(DuplicateMode):
    pass

class DuplicateModeKeep(DuplicateMode):
    pass

class DuplicateModeIgnore(DuplicateMode):
    pass

class DuplicateModeRemove(DuplicateMode):
    pass

class DuplicateModeError(DuplicateMode):
    pass

class XMLHandler():
    __VERSION = "1.0"

    def __init__(self, file, rename_mode, duplicate_mode, verbosity=0):
        self._rename_mode = rename_mode
        self._duplicate_mode = duplicate_mode
        self._tree = ET.parse(file)
        self._root = self._tree.getroot()
        self._verbosity = verbosity

    def convert(self, to):
        if(isinstance(to, FormatCHeader)):
            out = "// Autogenerated C header for register fields in %(ic)s\n// Version: %(version)s\n\n#ifndef %(ic)s_FIELDS\n#define %(ic)s_FIELDS\n\n%%(fields)s\n#endif"
            convert_name = self._name_c_header
            convert_field = self._field_c_header
            wspace = self._wspace_c_header
        elif(isinstance(to, FormatPython)):
            out = "# Autogenerated Python class for register fields in %(ic)s\n# Version: %(version)s\n\nclass %(ic)s_fields(object):\n%%(fields)s"
            convert_name = self._name_python
            convert_field = self._field_python
            wspace = self._wspace_python
        else:
            raise NotImplementedError()
        ic = convert_name(self._root.attrib["name"], self._rename_mode)
        out = out % { "ic": ic, "version": self.__VERSION }
        fstr = ""
        list = []
        remove = []
        max = 0
        for register in self._root.findall('.//{http://www.trinamic.com}value_register'):
            for field in register.findall('.//{http://www.trinamic.com}value_register_field'):
                field_name = convert_name(field.attrib["name"], self._rename_mode)
                v_func(self._verbosity, 2, lambda: print(Strings.CLI_INFO, "Field:", field_name))
                if(len(field_name) > max):
                    max = len(field_name)
                if(field_name in [i[0] for i in list]):
                    v_func(self._verbosity, 1, lambda: print(Strings.CLI_WARNING, "Redefinition:", field_name))
                    if(isinstance(self._duplicate_mode, DuplicateModeComment)):
                        v_func(self._verbosity, 2, lambda: print(Strings.CLI_WARNING, "  Commenting out..."))
                        list.append((field_name, convert_field(field_name, register.attrib["address"], field.attrib["mask"], field.attrib["shift"], comment=True)))
                    elif(isinstance(self._duplicate_mode, DuplicateModeKeep)):
                        v_func(self._verbosity, 2, lambda: print(Strings.CLI_WARNING, "  Keeping..."))
                        list.append((field_name, convert_field(field_name, register.attrib["address"], field.attrib["mask"], field.attrib["shift"], comment=False)))
                    elif(isinstance(self._duplicate_mode, DuplicateModeIgnore)):
                        v_func(self._verbosity, 2, lambda: print(Strings.CLI_WARNING, "  Ignoring..."))
                        pass
                    elif(isinstance(self._duplicate_mode, DuplicateModeRemove)):
                        v_func(self._verbosity, 2, lambda: print(Strings.CLI_WARNING, "  Removing all occurences.."))
                        if(field_name not in remove):
                            remove.append(field_name)
                    elif(isinstance(self._duplicate_mode, DuplicateModeError)):
                        v_func(self._verbosity, 2, lambda: print(Strings.CLI_WARNING, "  Raising error.."))
                        raise IOError("Duplicate: %s" % field_name)
                else:
                    list.append((field_name, convert_field(field_name, register.attrib["address"], field.attrib["mask"], field.attrib["shift"], comment=False)))
        for r in remove:
            v_func(self._verbosity, 2, lambda: print(Strings.CLI_INFO, "Removing occurences of", r, "..."))
            list = [f for f in list if f[0] == r]
        for field in list:
            fstr += wspace(field, max) + "\n"
        return (out % { "fields": fstr })

    def to_c_header(self):
        return convert(FormatCHeader())

    def to_python(self):
        return convert(FormatPython())

    def to_latex(self):
        pass

    @staticmethod
    def _name_c_header(input, rename_mode):
        out = re.sub(r"(\[)(\d+)(\])", r"_\1", input.upper())
        if(isinstance(rename_mode, RenameModeRemove)):
            out = re.sub(r"[^\w\d_]", "", out)
        elif(isinstance(rename_mode, RenameModeReplace)):
            out = re.sub(r"[^\w\d_]", "_", out)
        return out

    @staticmethod
    def _name_python(input, rename_mode):
        out = re.sub(r"(\[)(\d+)(\])", r"_\1", input.upper())
        if(isinstance(rename_mode, RenameModeRemove)):
            out = re.sub(r"[^\w\d_]", "", out)
        elif(isinstance(rename_mode, RenameModeReplace)):
            out = re.sub(r"[^\w\d_]", "_", out)
        return out

    @staticmethod
    def _field_c_header(name, address, mask, shift, comment=False):
        return ("%(comment)s#define %(field)s_MASK %%(wspace_mask)s0x%(mask)s\n%(comment)s#define %(field)s_SHIFT %%(wspace_shift)s%(shift)s"
            % { "comment": FormatCHeader.get_comment() if comment else "", "field": name, "mask": mask, "shift": shift })

    @staticmethod
    def _field_python(name, address, mask, shift, comment=False):
        return ("%(comment)s%(field)s %%(wspace)s= ( %(address)s, 0x%(mask)s, %(shift)s )"
            % { "comment": FormatPython.get_comment() if comment else "", "field": name, "address": address, "mask": mask, "shift": shift })

    @staticmethod
    def _wspace_c_header(field, max):
        return (field[1] % { "wspace_mask": " " * (1 + max - len(field[0])), "wspace_shift": " " * (max - len(field[0])) })

    @staticmethod
    def _wspace_python(field, max):
        return ("\t" + (field[1] % { "wspace": " " * (max - len(field[0])) }))
